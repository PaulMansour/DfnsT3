'rslt ← {larg) (op ##.redblack) rarg                 ⍝ Red-black trees.⍞000D⍞000D     T∆ ← T ∪ avl (key val)     ⍝ tree ⍺ with key=val ⍵.⍞000D     T∆ ← T ~ avl key           ⍝ tree ⍺ without key ⍵.⍞000D     T∆ ← T ⍎ avl key           ⍝ value for key ⍵ in tree ⍺.⍞000D    fmt ←   ⍕ avl T             ⍝ format of tree ⍵.⍞000D    vec ←   ∊ avl T             ⍝ enlist of tree ⍵.⍞000D    chk ←   ? avl T             ⍝ stats for tree ⍵: ok size mean_depth height.⍞000D⍞000DSee →BST←⍞000D⍞000DIn  contrast  with the notes for →sbst←, →splay← and →avl←, when discussing red-⍞000Dblacktrees, it is convenient to show null subtrees (nulls) explicitly.⍞000D⍞000D    AVL/Splay diagram           Equivalent Red-black diagram⍞000D    -----------------           ----------------------------⍞000D            E                             E⍞000D           / \                           / \⍞000D          /   \                         /   \⍞000D         /     \                       /     \⍞000D        B       F                     B       F⍞000D       / \                           / \     / \⍞000D      /   \                         /   \   ∘   ∘⍞000D     /     \                       /     \⍞000D    A       C                     A       C⍞000D             \                   / \     / \⍞000D              D                 ∘   ∘   ∘   D⍞000D                                           / \⍞000D                                          ∘   ∘⍞000D⍞000DDefn:  A  red-black tree is a binary search tree (→BST←) with the properties (or⍞000D"restrictions" or "rules"):⍞000D⍞000D[C] Every node is coloured either <red> or [black],⍞000D[I] Only internal nodes (other than the root or nulls) may be <red>,⍞000D[R] Both children of a <red> node are [black],⍞000D[B] The path from a node to any leaf contains the same number of [black] nodes.⍞000D⍞000DRed  nodes  are  annotated <N> and black nodes [N]. The following tree satisfies⍞000Drules C-B:⍞000D               ·⍞000D              [E]⍞000D              / \⍞000D             /   \⍞000D            /     \⍞000D          <B>     [F]⍞000D          / \     / \⍞000D         /   \  [∘] [∘]⍞000D        /     \⍞000D      [A]     [C]⍞000D      / \     / \⍞000D    [∘] [∘] [∘] <D>⍞000D                / \⍞000D              [∘] [∘]⍞000D⍞000DRules  R  and  B  keep the tree in reasonable balance; to construct a worst case⍞000D(greatest height/size ratio), we could take an all-black (and therefore, by rule⍞000DB, perfectly balanced) tree and increase its height by injecting red nodes (only⍞000Dalternately by rule R) all down one side.⍞000D                 ·⍞000D                [b]⍞000D                / \⍞000D               /   \                Height 4⍞000D              /     \               Size   6 (excluding nulls).⍞000D             /       \⍞000D            /         \⍞000D           /           \            In general, a red-black tree with ⍵ non-⍞000D          /             \           null nodes has height at most 2×2⍟⍵+1.⍞000D        [b]             <r>⍞000D        / \             / \⍞000D       /   \           /   \⍞000D      /     \         /     \⍞000D    [∘]     [∘]     [b]     [b]⍞000D                    / \     / \⍞000D                  [∘] [∘] [∘] <r>⍞000D                              / \⍞000D                            [∘] [∘]⍞000D⍞000DRed-black  trees are implemented here using a recursive triple with 0 represent-⍞000Ding the null tree:⍞000D⍞000D    (key val) red (lft rgt)⍞000D⍞000Dwhere:⍞000D⍞000D    key : numeric scalar or character vector⍞000D    val : any array value⍞000D    red : colour of node 0=black, 1=red *⍞000D    lft : left subtree or 0 (null).⍞000D    rgt : right subtree or 0 (null)⍞000D⍞000D* The  choice  of  0  for black means that a structure assignment of a null node⍞000D  shows it as black:⍞000D⍞000D        inf col(lft rgt)←⍺      ⍝ (possibly null) node colour and subs.⍞000D⍞000DInsertion⍞000D---------⍞000DThree generations of node are of interest:⍞000D⍞000D    G grandparent⍞000D    P parent⍞000D    C child⍞000D⍞000DNew node C is inserted in the normal fashion (see →BST←) and coloured red <C>.⍞000D⍞000DThere are 4 cases: [ins#] [insB] [insRR] [insRB].⍞000DCase [insRB] has 2 subcases: [insRBo] [insRBi].⍞000D⍞000DIf <C> is the root: recolour it [black].                                [ins#]⍞000D·⍞000D        <C>     →   [C]                             <C> → [C]⍞000D        / \         / \⍞000D      [∘] [∘]     [∘] [∘]⍞000D⍞000DOtherwise, <C> has a parent:⍞000D⍞000DIf <C>''s parent [P] is black: no change.                                [insB]⍞000D·⍞000D        [P]     →       [P]                         (no change)⍞000D        /               /⍞000D      <C>             <C>⍞000D      / \             / \⍞000D    [∘] [∘]         [∘] [∘]⍞000D⍞000DOtherwise, <C>''s parent <P> is red.                                     [insR]⍞000D⍞000DThis  means  that, from rule I, <P> cannot be the root and so must itself have a⍞000Dparent G, which is <C>''s grandparent.⍞000D·⍞000D           G⍞000D          /⍞000D        <P>⍞000D        /⍞000D      <C>⍞000D      / \⍞000D    [∘] [∘]⍞000D⍞000DRule [R] ensures that [G] must be black as its child <P> is red.⍞000D·⍞000D          [G]⍞000D          /⍞000D        <P>⍞000D        /⍞000D      <C>⍞000D      / \⍞000D    [∘] [∘]⍞000D⍞000DCall <P>''s possibly null sibling U (C''s Uncle).⍞000D·⍞000D          [G]⍞000D          / \⍞000D        <P>  U⍞000D        /⍞000D      <C>⍞000D      / \⍞000D    [∘] [∘]⍞000D                                        ¯⍞000DIf <U> is red, change the colours of G, P and U.                        [insRR]⍞000D·⍞000D          [G]       →       <G>                     [G] → <G>⍞000D          / \               / \                     <P> → [P]⍞000D        <P> <U>           [P] [U]                   <U> → [U]⍞000D        / \               / \⍞000D      <C>  S            <C>  S⍞000D      / \               / \⍞000D    [∘] [∘]           [∘] [∘]⍞000D⍞000D    In this case, <G> becomes the new <red> node and is⍞000D    handled  recursively  as  if _it_ had been inserted.⍞000D    In  other  words, the algorithm next looks at <G>''s⍞000D    parent  and  grandparent  to  determine  if further⍞000D    balancing is necessary, and so on.⍞000D⍞000DOtherwise, [U] is black.                                                [inaRB]⍞000D⍞000DIf <C> is <P>''s outer child, swap colours and rotate G-P.               [insRBo]⍞000D                ¯¯¯¯¯⍞000D          [G]       →       [P]                     [G] → <G>⍞000D          / \               / \                     <P> → [P]⍞000D        <P> [U]           <C> <G>                       ⌽ G-P⍞000D        / \                   / \⍞000D      <C> [S]               [S] [U]⍞000D⍞000DOtherwise <C> is inner child, rotate P-C and proceed as in [insRBo].    [insRBi]⍞000D                 ¯¯¯¯¯⍞000D          [G]       →       [G]                     ⌽ P-C⍞000D          / \               / \                       [insRBo]⍞000D        <P> [U]           <C> [U]⍞000D        / \               / \⍞000D       S  <C>           <P>  q⍞000D          / \           / \⍞000D         p   q         S   p⍞000D⍞000DAll possibilities are covered:⍞000D                                                          [ins]⍞000D    C is the root:          [ins#]                       / \⍞000D    C''s parent black:       [insB]                 [insR]   [insB]⍞000D    C''s uncle red:          [insRR]                   / \⍞000D    C is P''s inner child:   [insRBi]           [insRR]   [insRB]⍞000D    Otherwise:              [insRBo]                     / \⍞000D                                                 [insRBi]   [insRBo]⍞000DRemoval⍞000D-------⍞000DTo remove a node from a red-black tree, there are three phases:⍞000D⍞000D[loc] Locate X, the node to be deleted.⍞000D[rep] Repaint the removed node''s child.⍞000D[bal] Rebalance the tree by absorbing any "double-black" nodes.⍞000D⍞000D[loc]----------------------------------------------------------------------[loc]⍞000D⍞000DSearch the tree for the node to be deleted in the normal way (→BST←):⍞000D⍞000D    If the node is a leaf (only null subtrees),                         [loc0]⍞000D        replace it with a null:⍞000D·⍞000D           X    =>      [∘]⍞000D          / \⍞000D        [∘] [∘]⍞000D⍞000D    Otherwise, if the node has only a single (non-null) child,          [loc1]⍞000D        replace the node with its child:⍞000D·⍞000D            X   =>  C               X   =>  C⍞000D           / \                     / \⍞000D         [∘]  C                   C  [∘]⍞000D⍞000D    Otherwise (the node has two non-null children),                     [loc2]⍞000D        exchange the node key=value with that of its right (say) successor node,⍞000D        which  by  definition  does not have a left (say) child, then remove the⍞000D        successor as in [loc0] or [loc1] above:⍞000D⍞000D             target node X:      X  ~ X     =>     X∆ ~ X    =>     X∆⍞000D                                / \               / \              / \⍞000D                               A   B             A   B            A   B⍞000D                                  / \               /                /⍞000D                                ...               ...              ...⍞000D                                /                 /                /⍞000D    X''s right successor:       X∆                X                X  ~ X⍞000D                              / \               / \              / \⍞000D                            [∘]  C            [∘]  C           [∘]  C⍞000D⍞000DAll possibilities are covered:⍞000D⍞000D    Both subtrees null:     [loc0]⍞000D    One subtree null:       [loc1]⍞000D    Neither sutree null:    [loc2]⍞000D⍞000DOn deletion of X, it may be necessary to repaint X''s child C:⍞000D⍞000D[rep]----------------------------------------------------------------------[rep]⍞000D⍞000DRepaint the removed node''s child.⍞000D⍞000DIf X was red, no more need be done:                                     [repR]⍞000D·⍞000D        <X>     =>      [C]⍞000D          \⍞000D          [C]⍞000D⍞000DOtherwise, if [X]''s child C is red, paint it black:                     [repBR]⍞000D·⍞000D        [X]     =>      [C]⍞000D          \⍞000D          <C>⍞000D⍞000DOtherwise, repaint [C] double-black.                                    [repBB]⍞000D·⍞000D        [X]     =>      [[C]]⍞000D          \⍞000D          [C]⍞000D⍞000DIn all cases, if we count double-black as 2, rule B continues to hold.⍞000D⍞000DAll possibilities are covered:⍞000D                                                      [rep]⍞000D    X red:      [repR]                               / \⍞000D    C red:      [repBR]                        [repR]   [repB]⍞000D    C black:    [repBB]                                 / \⍞000D                                                 [repBR]   [repBB]⍞000D(⍞000D    In some treatments,  the double-black node is described as a separate "black⍞000D    token", which is associated with the node. It amounts to the same thing:⍞000D·⍞000D        [X]     =>      [[C]]       <= double-black node.⍞000D          \⍞000D          [C]⍞000D⍞000D⍞000D        [X]     =>      [C] []      <= black node with associated black token.⍞000D          \⍞000D          [C]⍞000D⍞000D    In a particular implementation, the choice probably depends on how a null is⍞000D    represented.  As  we use a scalar 0 for null, there is no structure in which⍞000D    to  keep the double-blackness property, so a separate black token is prefer-⍞000D    able.  However, the double brackets look more pleasing in diagrams, where we⍞000D    will continue to use them ...⍞000D)⍞000D⍞000D[bal]----------------------------------------------------------------------[bal]⍞000D⍞000DRebalance the tree by absorbing any double-black nodes [[N]].⍞000D⍞000DNotice how each of the transformations below preserves rules [C] [I] [R] & [B].⍞000DIn particular:⍞000D⍞000D    The colour of the root of the subtree remains unchanged for rule R.⍞000D⍞000D    Apart from the root case [bal#], the  number of black nodes (square brack-⍞000D    ets) from the root of the subtree downwards remains unchanged for rule B.⍞000D⍞000DIn  the  following diagrams, (N) means that the colour of N is immaterial to the⍞000Dtransformation.⍞000D⍞000DIf [[N]] is the root, repaint it black:                                 [bal#]⍞000D·⍞000D        [[N]]   =>  [N]⍞000D         / \        / \⍞000D⍞000D    (this maintains rule B by decrementing the black count on every path).⍞000D⍞000DOtherwise, N has a parent and a (possibly null) sibling.⍞000D⍞000DIf N''s sibling S is red,⍞000D    Swap the colours of P and S and rotate P left.                      [balR]⍞000D    N''s new sibling is black, so proceed from [balB].⍞000D·⍞000D        [P]         =>     [S]                      [P] → <P>⍞000D        / \                / \                      <S> → [S]⍞000D       /   \              /   \                         ⌽ P-S⍞000D    [[N]]  <S>          <P>   [f]                         [balB]⍞000D           / \          / \⍞000D          /   \        /   \⍞000D        [n]   [f]   [[N]]  [n]⍞000D⍞000D    Note that, after the transformation, [[N]]''s parent <P> is red.⍞000D    This means that [balB] will, at worst,  produce a singly-black⍞000D    parent and so complete the rebalance. In particular, it is not⍞000D    necessary  to check for double-blackness on return of [balR]''s⍞000D    call to [balB].⍞000D⍞000DOtherwise N''s sibling is black.                                         [balB]⍞000D⍞000DIf both nephews are black,⍞000D    paint sibling S red and blacken parent P.                           [balBbb]⍞000D·⍞000D        (P)     =>    [(P)]                         (P) → [(P)] *⍞000D        / \            / \                        [[N]] →  [N]⍞000D       /   \          /   \                         [S] →  <S>⍞000D    [[N]]  [S]      [N]  <S>⍞000D           / \           / \⍞000D         [n] [f]       [n] [f]⍞000D⍞000D    * (P) => [(P)] means "blacken",⍞000D      red goes to black      <P> → [P]⍞000D      black to double-black  [P] → [[P]]⍞000D⍞000DOtherwise, if the far nephew f is red,⍞000D    Move N''s extra brackets to the far nephew and rotate P-S.           [balB_r]⍞000D·⍞000D        (P)         =>       (S)                    (S) → (P) *⍞000D        / \                  / \                    (P) → [P]⍞000D       /   \                /   \                 [[N]] → [N]⍞000D      /     \              /     \                  <f> → [f]⍞000D   [[N]]    [S]          [P]     [f]                    ⌽ P-S⍞000D             / \         / \     / \⍞000D           (n) <f>     [N] (n) [a] [b]⍞000D·   ·   ·      / \⍞000D             [a] [b]⍞000D⍞000D    * (P) → (S) means that P''s colour is transferred to S.⍞000D⍞000DOtherwise, the far nephew f is black (and the near one must be red),⍞000D    Swap the colours of S and l and rotate S right.                     [balBrb]⍞000D    Then proceed as in [balB_r].⍞000D·⍞000D        (P)         =>     (P)                      [S] → <S>⍞000D        / \                / \                      <n> → [n]⍞000D       /   \              /   \                         ⌽ S-n⍞000D    [[N]]  [S]         [[N]]  [n]                         [balB_r]⍞000D           / \                / \⍞000D         <n> [f]            [a] <S>⍞000D         / \                    / \⍞000D       [a] [b]                [b] [f]⍞000D⍞000DAll possibilities are covered:                            [bal]⍞000D                                                          / \⍞000D    [[N]] is the root:  [bal#]                      [balR]   [balB]⍞000D    N''s sibling red:    [balR]      [1]                      / \⍞000D    Both nephews black: [balBbb]    [2]              [balB_r]   [balB_b]⍞000D    Far nephew red:     [balB_r]                                / \⍞000D    Otherwise           [balBrb]                        [balBrb]   [balBbb]⍞000D⍞000D[1] If N has a parent, it must have a (possibly null) sibling.⍞000D⍞000D[2] As N is double-black,  its parent must have had at least two black⍞000D    nodes in each subtree (rule B). Therefore, N''s sibling is not null⍞000D    and so has two (possibly null) nephews.⍞000D⍞000DTechnical notes:⍞000D⍞000DInsertion  and removal require information about the node''s parent, grandparent,⍞000Duncle  or  nephews. In a language with pointers, we might arrange that each node⍞000Dinclude  a  pointer  to  its  parent,  although  this would increase complexity.⍞000DSimilarly,  we  could use namespaces to implement nodes and include a ref to the⍞000Dparent space.⍞000D⍞000DWe  choose  instead, to have the subject node''s (grand) parent do the processing⍞000Dby returning a path (vector of directions) to the child in question. The (grand)⍞000Dparent  can then check the length of this path to see if it must accommodate any⍞000Dchanges.  Any node that decides that no further attention is required, returns a⍞000Dpath  that is long enough to be ignored by all ancestors. (0 0 0) will always do⍞000Dthe trick.⍞000D⍞000DReferences:⍞000D⍞000D[1] http://en.wikipedia.org/wiki/Red-black_tree⍞000D[2] Internet: search for "red black tree"⍞000D[3] "Paint It Black/Long Long While", Jagger/Richards, Decca F12395 (1966).⍞000D⍞000DExamples:⍞000D⍞000D⍝ derive red-black tree functions:⍞000D⍞000D    put ← ∪ redblack            ⍝ tree ⍺ with key=val ⍵.⍞000D    rem ← ~ redblack            ⍝ tree ⍺ without key ⍵.⍞000D    get ← ⍎ redblack            ⍝ value for key ⍺ from tree ⍵.⍞000D    fmt ← ⍕ redblack            ⍝ format of tree ⍵.⍞000D    vec ← ~ redblack            ⍝ enlist of tree ⍵.⍞000D    chk ← ? redblack            ⍝ stats for tree ⍵: ok size mean_depth height.⍞000D⍞000D    tt ← 0                      ⍝ null tree⍞000D⍞000D    tt ← tt put ''one'' 1         ⍝ single node tree: (key val) red (lft rgt)⍞000D⍞000D    fmt tt                      ⍝ root is [black]⍞000D       ┌[∘]⍞000D[one=1]┤⍞000D       └[∘]⍞000D⍞000D    tt ← tt put ''two''   2       ⍝ insert second node⍞000D⍞000D    fmt tt                      ⍝ new node is <red>⍞000D       ┌[∘]⍞000D[one=1]┤⍞000D       │       ┌[∘]⍞000D       └<two=2>┤⍞000D               └[∘]⍞000D⍞000D    tt ← tt put ''three'' 3       ⍝ insert third node.⍞000D⍞000D    fmt tt⍞000D                 ┌[∘]⍞000D         ┌<one=1>┤⍞000D         │       └[∘]⍞000D[three=3]┤⍞000D         │       ┌[∘]⍞000D         └<two=2>┤⍞000D                 └[∘]⍞000D⍞000D    tt ← tt put foldl (''four'' 4) (''five'' 5) (''six'' 6) (''seven'' 7)⍞000D⍞000D    fmt tt⍞000D                           ┌[∘]⍞000D                  ┌[five=5]┤⍞000D                  │        └[∘]⍞000D         ┌<four=4>┤⍞000D         │        │                 ┌[∘]⍞000D         │        │         ┌<one=1>┤⍞000D         │        │         │       └[∘]⍞000D         │        └[seven=7]┤⍞000D         │                  │       ┌[∘]⍞000D         │                  └<six=6>┤⍞000D         │                          └[∘]⍞000D[three=3]┤⍞000D         │       ┌[∘]⍞000D         └[two=2]┤⍞000D                 └[∘]⍞000D⍞000D    chk tt                      ⍝ tree stats.⍞000D1 7 2 4⍞000D⍞000D    ⍪ fmt¨ 0 put foldl¨ 1↓¨,\0,⍳6               ⍝ successive inserts 1 2 .. 6⍞000D┌───────────────────────────┐⍞000D│[∘]                        │⍞000D├───────────────────────────┤⍞000D│     ┌[∘]                  │⍞000D│[1=1]┤                     │⍞000D│     └[∘]                  │⍞000D├───────────────────────────┤⍞000D│     ┌[∘]                  │⍞000D│[1=1]┤                     │⍞000D│     │     ┌[∘]            │⍞000D│     └<2=2>┤               │⍞000D│           └[∘]            │⍞000D├───────────────────────────┤⍞000D│           ┌[∘]            │⍞000D│     ┌<1=1>┤               │⍞000D│     │     └[∘]            │⍞000D│[2=2]┤                     │⍞000D│     │     ┌[∘]            │⍞000D│     └<3=3>┤               │⍞000D│           └[∘]            │⍞000D├───────────────────────────┤⍞000D│           ┌[∘]            │⍞000D│     ┌[1=1]┤               │⍞000D│     │     └[∘]            │⍞000D│[2=2]┤                     │⍞000D│     │     ┌[∘]            │⍞000D│     └[3=3]┤               │⍞000D│           │     ┌[∘]      │⍞000D│           └<4=4>┤         │⍞000D│                 └[∘]      │⍞000D├───────────────────────────┤⍞000D│           ┌[∘]            │⍞000D│     ┌[1=1]┤               │⍞000D│     │     └[∘]            │⍞000D│[2=2]┤                     │⍞000D│     │           ┌[∘]      │⍞000D│     │     ┌<3=3>┤         │⍞000D│     │     │     └[∘]      │⍞000D│     └[4=4]┤               │⍞000D│           │     ┌[∘]      │⍞000D│           └<5=5>┤         │⍞000D│                 └[∘]      │⍞000D├───────────────────────────┤⍞000D│           ┌[∘]            │⍞000D│     ┌[1=1]┤               │⍞000D│     │     └[∘]            │⍞000D│[2=2]┤                     │⍞000D│     │           ┌[∘]      │⍞000D│     │     ┌[3=3]┤         │⍞000D│     │     │     └[∘]      │⍞000D│     └<4=4>┤               │⍞000D│           │     ┌[∘]      │⍞000D│           └[5=5]┤         │⍞000D│                 │     ┌[∘]│⍞000D│                 └<6=6>┤   │⍞000D│                       └[∘]│⍞000D└───────────────────────────┘⍞000D⍞000D    tt ← 0 put foldl ⍳6                         ⍝ 6 nodes, ascending order.⍞000D⍞000D    ⍪ fmt¨(⊂tt)rem foldl¨1↓¨,\0,⍳6              ⍝ successive removals 1 2 .. 6⍞000D┌───────────────────────────┐⍞000D│           ┌[∘]            │⍞000D│     ┌[1=1]┤               │⍞000D│     │     └[∘]            │⍞000D│[2=2]┤                     │⍞000D│     │           ┌[∘]      │⍞000D│     │     ┌[3=3]┤         │⍞000D│     │     │     └[∘]      │⍞000D│     └<4=4>┤               │⍞000D│           │     ┌[∘]      │⍞000D│           └[5=5]┤         │⍞000D│                 │     ┌[∘]│⍞000D│                 └<6=6>┤   │⍞000D│                       └[∘]│⍞000D├───────────────────────────┤⍞000D│           ┌[∘]            │⍞000D│     ┌[2=2]┤               │⍞000D│     │     │     ┌[∘]      │⍞000D│     │     └<3=3>┤         │⍞000D│     │           └[∘]      │⍞000D│[4=4]┤                     │⍞000D│     │     ┌[∘]            │⍞000D│     └[5=5]┤               │⍞000D│           │     ┌[∘]      │⍞000D│           └<6=6>┤         │⍞000D│                 └[∘]      │⍞000D├───────────────────────────┤⍞000D│           ┌[∘]            │⍞000D│     ┌[3=3]┤               │⍞000D│     │     └[∘]            │⍞000D│[4=4]┤                     │⍞000D│     │     ┌[∘]            │⍞000D│     └[5=5]┤               │⍞000D│           │     ┌[∘]      │⍞000D│           └<6=6>┤         │⍞000D│                 └[∘]      │⍞000D├───────────────────────────┤⍞000D│           ┌[∘]            │⍞000D│     ┌[4=4]┤               │⍞000D│     │     └[∘]            │⍞000D│[5=5]┤                     │⍞000D│     │     ┌[∘]            │⍞000D│     └[6=6]┤               │⍞000D│           └[∘]            │⍞000D├───────────────────────────┤⍞000D│     ┌[∘]                  │⍞000D│[5=5]┤                     │⍞000D│     │     ┌[∘]            │⍞000D│     └<6=6>┤               │⍞000D│           └[∘]            │⍞000D├───────────────────────────┤⍞000D│     ┌[∘]                  │⍞000D│[6=6]┤                     │⍞000D│     └[∘]                  │⍞000D├───────────────────────────┤⍞000D│[∘]                        │⍞000D└───────────────────────────┘⍞000D⍞000DSee also: BST sbst avl splay foldl alists⍞000D⍞000DIndex:tree|red-black trees|binary search tree|enlist' 
