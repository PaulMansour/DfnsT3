'rslt ← ival (func ##.foldl) vals            ⍝ Fold (reduce) from the left.⍞000D⍞000DPhil  Last''s  operator  uses  dyadic operand function [func] to accumulate items⍞000Dfrom vector right argument [vals] starting with initial value [ival]. In effect:⍞000D⍞000D    a f foldl i j k ··· →  (((a f i)f j)f k) ···⍞000D⍞000D[foldl] is equivalent to, but faster than, the traditional operator:⍞000D⍞000D    ∇ rslt←ival(func foldl)vals;val⍞000D[1]   rslt←ival⍞000D[2]   :For val :In vals⍞000D[3]       rslt←rslt func val    ⍝ accumulate result.⍞000D[4]   :End⍞000D    ∇⍞000D⍞000DA related cumulative left-to-right scan operator might look like this:⍞000D⍞000D    scanl←{⎕ML←0                ⍝ Scan from the left.⍞000D        2>⊃⌽⍴⍵:⍵                ⍝ few items: done.⍞000D        ⌽↑⍺⍺{⍞000D            (⊂(⊃⍵)⍺⍺ ⍺),⍵⍞000D        }/(⌽⍵),⊂⊂⍺⍞000D    }⍞000D⍞000D    ''hello'' ⌽⍨ scanl 1 1 0 ¯1 ¯1            ⍝ cf ascan in →scan←⍞000D┌─────┬─────┬─────┬─────┬─────┬─────┐⍞000D│hello│elloh│llohe│llohe│elloh│hello│⍞000D└─────┴─────┴─────┴─────┴─────┴─────┘⍞000D⍞000DTechnical note:⍞000D⍞000DThe domain or "type" of left argument [ival] is in general distinct from that of⍞000Dthe  items  of  right  argument  vector [vals]. In the  text replacement example⍞000Dbelow,  the  left  argument is a character vector (text string) and the right, a⍞000Dvector of from/to pairs.⍞000D⍞000DTo show what''s going on, we could invent a type notation:⍞000D⍞000D    ::                  "is of type",⍞000D    ⍺, ⍵, ∊, ⍳, ⍴, ···  arbitrary types ("type variables"),⍞000D    ∇, ∇∇               place marker for function, operator,⍞000D    → ···               "to a ···" result type ···⍞000D    [⍺]                 vector of ⍺s⍞000D    [⍺;]                matrix of ⍺s.⍞000D⍞000DThen:⍞000D⍞000D    foldl :: ⍺ (⍺ ∇ ⍵ → ⍺) ∇∇ [⍵] → ⍺⍞000D⍞000DFrom this we can see that:⍞000D⍞000D- the type of the result of the derived function is the same as the type of its⍞000D  left argument, which is also  ¯¯¯¯¯¯¯⍞000D⍞000D- the type of the result of the operand function and the type of its left argu-⍞000D  ment;                         ¯¯¯¯¯¯¯⍞000D⍞000D- the type of the right argument of the operand function is the same as the type⍞000D  of each item of the derived function''s right argument array.⍞000D⍞000DThis  topic is explored in a little more depth in supplied workspace Max; search⍞000Dfor "type of" and "foldl" in max.dws/Introduction.⍞000D⍞000DSimilarly, the type of scanl, above, is:⍞000D⍞000D    scanl :: ⍺ (⍺ ∇ ⍵ → ⍺) ∇∇ [⍵] → [⍺]⍞000D⍞000DComparison with primitive (vector) reduction:⍞000D⍞000DIf the right argument of a  primitive reduction is "homogeneous", in that all of⍞000Dits items are of the same type, the type of a vector reduction is:⍞000D⍞000D    / :: (⍺ ∇ ⍺ → ⍺) ∇∇ [⍺] → ⍺         ⍝ homogeneous vector reduction⍞000D                                          ¯¯¯¯⍞000DHowever, APL allows vectors to be "heterogeneous".  In particular, if the right-⍞000Dmost item is of a distinct type, we could say the argument is of type [⍺],⊂⍵ and⍞000Dthe type of primitive reduction is:⍞000D⍞000D    / :: (⍺ ∇ ⍵ → ⍵) ∇∇ [⍺],⊂⍵ → ⊂⍵     ⍝ heterogeneous vector reduction⍞000D                                          ¯¯¯¯¯¯⍞000DComposition of types:⍞000D⍞000D     f :: {x} ∇ ⍵ → ∊       ⍝ optional left argument {x}⍞000D     g ::     ∇ ⍺ → ⍵⍞000D=> f∘g :: {x} ∇ ⍺ → ∊⍞000D⍞000DVariations⍞000D¯¯¯¯¯¯¯¯¯¯⍞000DA  monadic  version  of  foldl  might take the prototypical item of its argument⍞000Darray as an initial value:⍞000D⍞000D    foldl←{⎕ML←1            ⍝ Fold (reduce) from the left.⍞000D        ↑⍺⍺⍨/(⌽⍵),⊂⊃0⍴⍵     ⍝ ival is prototypical item.⍞000D    }              ¯¯¯¯     ⍝ :: (⍺ ∇ ⍺ → ⍺) ∇∇ [⍺] → ⍺⍞000D⍞000DAlternatively, we could _default_ the initial value  to the prototypical item of⍞000Dthe right argument by inserting an ⍺←··· line like this:⍞000D⍞000D    foldl←{⎕ML←1            ⍝ Fold (reduce) from the left.⍞000D        ⍺←⊃0⍴⍵              ⍝ default initial value.⍞000D        ↑⍺⍺⍨/(⌽⍵),⊂⍺        ⍝ :: {⍺} (⍺ ∇ ⍵ → ⍺) ∇∇ [⍵] → ⍺⍞000D    }⍞000D⍞000DExamples:⍞000D⍞000D    repl←subs⍨                                  ⍝ ⍺ with ⍵ replacement.⍞000D⍞000D    ''I dare not'' repl ''dare'' ''would''            ⍝ single word replacement.⍞000DI would not⍞000D⍞000D    ''many a mickle''repl foldl ''nk''(''y'' ''es'')''iu'' ⍝ multiple letter replacement.⍞000Dmakes a muckle⍞000D⍞000D      0 ,foldl 2 3⍴⍳6                           ⍝ higher rank arrays.⍞000D0 1 2 3⍞000D0 4 5 6⍞000D⍞000D    ⍝ For more examples, see →remnode← and →Graphs←⍞000D⍞000DSee also: acc trav pred scan remnode Graphs⍞000D⍞000DIndex:reduction|fold|type notation⍞000DIndex;Last P.' 
