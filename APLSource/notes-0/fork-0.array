'rslt ← {larg} I ##._fk J fk_ K rarg         ⍝ simulation of "fork" syntax.⍞000Drslt ← {larg} I  ##.fk J fk  K rarg         ⍝ slower but more elegant.⍞000D⍞000DNB: forks are now implemented as primitive constructs in Dyalog.⍞000D⍞000DThe function ''≥'' (greater than or equal) can be considered to be the application⍞000Dof  the two functions ''>'' (greater than) and ''='' (equal), separately between the⍞000Darguments and the combining of the results with ''∨'' (or).⍞000D⍞000D       ┌───∨───┐⍞000D     ┌─>─┐   ┌─=─┐⍞000D     ⍺   ⍵   ⍺   ⍵⍞000D⍞000DSuggested by Phil Last, fork implements this tree structure using a pair of  op-⍞000Derators [_fk] and [fk_].⍞000D⍞000DAn alternative coding⍞000D---------------------⍞000DPhil  goes  on  to  say: The version below I wrote last year when I was thinking⍞000Dabout  the  technique  I  used  in →cond←, where the need for the separation and⍞000Dinterdependence  is  swapped  for  the loss of a very few fairly unlikely scalar⍞000Darguments (and several extra lines of code).⍞000D⍞000D    fk←{⍞000D        A B C←112358314594370 774156178538190 998752796516730⍞000D        ⍺←A                        ⍝ ⍺←A ⋄ fg←f←⍺⍺ ⋄ h←g←⍵⍵⍞000D        ⍺≡A:B ⍺⍺ ⍵(⍵⍵ ⍵)           ⍝ ⍺≡A:B fg ⍵(h ⍵)⍞000D        ⍺≡B:⊃⍺⍺{(⍺⍺ ⍺)⍵⍵ ⍵}⍵⍵/⍵    ⍝ ⍺≡B:⊃{(f ⍺)g ⍵}/⍵⍞000D        ⍺≡C:⊃⍺⍺{(⊃⍺⍺/⍺)⍵⍵ ⍵}⍵⍵/⍵   ⍝ ⍺≡C:⊃{(⊃f/⍺)g ⍵}/⍵⍞000D        C ⍺⍺(⍺ ⍵)(⍺ ⍵⍵ ⍵)          ⍝ C fg(⍺ ⍵)(⍺ h ⍵)⍞000D    }⍞000D⍞000DIt''s slower than the _fk/fk_ pair obviously improving relatively as the overhead⍞000Dgets less significant ...⍞000D⍞000D        (>fk∨fk=)cf(>_fk∨fk_=)∘⌽⍨⍳1e1⍞000D    2.292270531⍞000D⍞000D        (>fk∨fk=)cf(>_fk∨fk_=)∘⌽⍨⍳1e3⍞000D    1.798882682⍞000D⍞000D        (>fk∨fk=)cf(>_fk∨fk_=)∘⌽⍨⍳1e6⍞000D    0.9954407295⍞000D⍞000Dat which point it''s only twice as slow as the primitive ...⍞000D⍞000D        (>fk∨fk=)cf≥∘⌽⍨⍳1e6⍞000D    2.006006006⍞000D⍞000DSo it''s only an exercise in coding but it''s a better model if we ever decided to⍞000Dadd a primitive.  It even extends correctly to odd trains (forks of forks) which⍞000D_fk/fk_ doesn''t ...⍞000D⍞000DThe following is true for boolean arguments (≥ ←→ ∨∘~ ←→ if) each time replacing⍞000Dthe leftmost function with an equivalent fork ...⍞000D⍞000D    ≥ ←→ >fk∨fk= ←→ =fk⍱fk<fk∨fk= ←→ ∧fk∨fk⍱fk⍱fk<fk∨fk=⍞000D⍞000D    ∘.(∧fk∨fk⍱fk⍱fk<fk∨fk=)⍨0 1⍞000D1 0⍞000D1 1⍞000D⍞000DNB: In Dyalog operator-operand sequences associate (bind) left, so that:⍞000D⍞000D    f op g op h  ←→  (f op g)op h⍞000D⍞000Dwhereas, in J, forks associate right:⍞000D⍞000D    f g h ←→ f(g h)⍞000D⍞000DThis difference is reflected in this implementation of fork.⍞000D⍞000DExamples:⍞000D⍞000D      ge ← > _fk ∨ fk_ =        ⍝ defined ≥ function (dyadic).⍞000D⍞000D      (⍳5) ∘.ge ⍳5⍞000D1 0 0 0 0⍞000D1 1 0 0 0⍞000D1 1 1 0 0⍞000D1 1 1 1 0⍞000D1 1 1 1 1⍞000D⍞000D      mean ← +/ _fk ÷ fk_ ⍴     ⍝ arithmetic mean (monadic).⍞000D⍞000D      mean 1 2 3 4⍞000D2.5⍞000D⍞000DSee also: dft cond co_ops⍞000D⍞000DIndex:hook|fork|co-operator⍞000DIndex;Last P.' 
