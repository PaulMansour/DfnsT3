'sum ← {digs←6} ##.chksum array              ⍝ Simple ⍺-digit checksum.⍞000D⍞000DA checksum  can  be  considered as a "signature" for a set of data and so may be⍞000Dused to verify that the data has not been modified or corrupted.⍞000D⍞000D[chksum] returns a (by default 6-digit-) checksum for its argument array ⍵.⍞000D⍞000DNB: Check-summing  and  hashing systems typically map a large set of data values⍞000Donto a significantly smaller set of sums.  It is therefore inevitable that there⍞000Dbe  "clashes",  where different values map to the same sum.⍞000D⍞000DThis means that a good checksum algorithm guarantees that:⍞000D⍞000D- If the checksum has changed, then the array has _certainly_ changed.⍞000D- If the checksum has not changed, then the array has _probably_ not changed.⍞000D⍞000DThe  art of creating useful checksums is to balance the conflicting requirements⍞000Dto:⍞000D⍞000D- Produce a fast-enough summing function for large volumes of data.⍞000D- Maximise sensitivity to typical changes in the data.⍞000D⍞000DFor example, a simple approach might be an ⍺-residue sum of the data bytes. How-⍞000Dever,  this  would  not  detect  added or removed 0-values or reordering of data⍞000Ditems. For this reason, a "weighted sum" is often used.⍞000D⍞000DThere is a large body of literature devoted to the subject. See, for example:⍞000D⍞000D    http://en.wikipedia.org/wiki/Checksum⍞000D⍞000DBug: [chksum] ignores array items that are namespace references (refs).⍞000DBug: [chksum] ignores ⎕NULL.⍞000DBug: [chksum] crashes (DOMAIN ERROR) on encountering a ⎕OR item.⍞000D⍞000DTechnical notes:⍞000D⍞000D[chksum] returns the weighted sum of the:⍞000D    the byte vector of: the shape followed by a ¯1 separator⍞000D        followed by⍞000D    the byte vector of the ravel of the array.⍞000D⍞000Dwhere byte vectors for various item (⎕DR) types are the:⍞000D⍞000D    nested:     concatenation of the byte vectors of subarrays.⍞000D    boolean:    (0 and 1) items themselves.⍞000D    numeric:    (256|83 ⎕DR) byte-values.⍞000D    character:  (256|83 ⎕DR) byte-values of ⎕UCS unicode indices.⍞000D⍞000DSeparating  the last two cases above ensures that [chksum] returns the same res-⍞000Dult for character arrays in Unicode and Classic versions of Dyalog.⍞000D⍞000DIn  order to distinguish null arrays of differing types, such arrays are repres-⍞000Dented by their prototypical items.⍞000D⍞000DNote that in versions of Dyalog APL prior to V10.1, we must explicitly "squeeze"⍞000Dinteger  arrays prior to (⎕DR-) converting them to byte-values.  This is so that⍞000Didentical  integers,  whose  internal  representations  differ, produce the same⍞000Dchecksum.⍞000D⍞000DExamples:⍞000D⍞000D    chksum ⎕cr''chksum''              ⍝ simple char array⍞000D314685⍞000D⍞000D    chksum ⎕nr''chksum''              ⍝ nested    ..  ..⍞000D930686⍞000D⍞000D    chksum 1 2 3 ∘.○ 4 5 6          ⍝ simple numeric array.⍞000D412967⍞000D⍞000D    chksum¨(1 3 2)(2 1 3)           ⍝ clash: values with same chksum.⍞000D538 538⍞000D⍞000D    chksum¨'''' ⍬                     ⍝ distinct nulls.⍞000D1295 1275⍞000D⍞000D    ⍝ Checksumming the notes in this workspace is reasonably quick:⍞000D⍞000D    chksum time notes.(⍎¨↓⎕nl 2)    ⍝ time checksumming of notes namespace.⍞000D00.16⍞000D⍞000D    chksum #                        ⍝ checksum of ref is 0.⍞000D0⍞000D⍞000DSee also: time⍞000D⍞000DIndex:checksum|hashing' 
