'expr ← vars ##.unify expr expr ···          ⍝ Unification of expressions.⍞000D⍞000DReturns  the  unification  of a vector of expressions, with respect to variables⍞000Dlisted in its left argument.⍞000D⍞000DFor example, if (1×2)+y and x+(3×4) represent the same expression, then it foll-⍞000Dows that x = 1×2 and y = 3×4, and both expressions must be equal to (1×2)+(3×4).⍞000D⍞000DThe new expression is said to be the "unification" of the previous ones with re-⍞000Dspect to variables x and y.⍞000D⍞000DTechnical notes:⍞000D⍞000DUnify takes a _vector_ of expressions to be unified and uses primitive reduction⍞000Dto apply Robinson''s algorithm cumulatively, two expressions at a time.⍞000D⍞000DThe  algorithm  examines  the two expressions in parallel, looking for the first⍞000Dpair of terms that "disagree". For example, in expressions:⍞000D⍞000D (1+2) ×   y   ÷ 3 - (z + 5)⍞000D⍞000D   u   × (6+7) ÷ 3 - (z + w)⍞000D⍞000Dthe disagreement pairs are:⍞000D⍞000D    (1+2)  u⍞000D    y      (6+7)⍞000D    5      w⍞000D⍞000DIf just one of the items in the pair is a variable, it is substituted in both of⍞000Dthe original expressions with the corresponding value of the pair, and the whole⍞000Dprocess repeated until the expressions match. If neither of the items is a vari-⍞000Dable, then unification fails and a: "Can''t unify" error is generated.⍞000D⍞000DA small complication arises with repeated variables. The expressions:⍞000D⍞000D    z   ×   z⍞000D⍞000D  (1+y) × (x+2)⍞000D⍞000Dyield two disagreement pairs:⍞000D⍞000D    z (1+y)⍞000D    z (x+2)⍞000D⍞000DIn  this  case, the _values_ of the two disagreement pairs (1+y) (x+2) are them-⍞000Dselves  unified  recursively  to (1+2), before being substituted for z, yielding⍞000D(1+2)×(1+2) as the unified expression.⍞000D⍞000DThis coding  includes  an "occurs check" to guard against non-termination caused⍞000Dby  an  attempt to substitute for a variable with a value containing one or more⍞000Doccurrences  of  that variable. Using the notation: [⍺/⍵]∊ to mean "substitute ⍺⍞000Dfor  occurrences of ⍵ in expression ∊" or more succinctly "⍺ for ⍵ in ∊". An ex-⍞000Dample of such non-termination might be:⍞000D⍞000D    [(x+1)/x] 2+x⍞000D=>  [(x+1)/x] 2+(x+1)⍞000D=>  [(x+1)/x] 2+((x+1)+1)⍞000D=>  [(x+1)/x] 2+(((x+1)+1)+1)⍞000D=>  ...⍞000D⍞000DIf  the process that generates the expressions to be unified, can guarantee that⍞000Dsuch cases do not occur, this check may be omitted.⍞000D⍞000DReferences:⍞000D⍞000DRobinson,  J.A.  "A  machine-oriented  logic based on the resolution principle",⍞000DJournal of the ACM, 12:23-41, 1965.⍞000D⍞000DBrown,  J.A. and Guerreiro, R. "APL2 Implementations of Unification", Conference⍞000DProceedings APL87. APL Quote Quad, V17.4, 1987.⍞000D⍞000DA  slightly different version of unify is used by max.dws for the unification of⍞000Dtype  expressions  during  type inference. For a discussion of polymorphic types⍞000Dand some more references, see max.dws/Implementation.⍞000D⍞000DExamples:⍞000D⍞000D⍝ Here is a parser for simple parenthesised expressions.⍞000D⍞000D    px←{                        ⍝ Single char token parser.⍞000D        1=⍴⍵:⊃⍵                 ⍝ atom: return scalar.⍞000D        depth←×¯1⌽-⌿+\''()''∘.=⍵  ⍝ within parens.⍞000D        lpars←0 1⍷depth         ⍝ left parens.⍞000D        smask←lpars≥depth       ⍝ segmentation mask.⍞000D        drops←1 ¯1×⊂smask/lpars ⍝ parens drop.⍞000D        ∇¨↑↓¨/drops,⊂smask⊂⍵    ⍝ process each segment.⍞000D    }⍞000D⍞000D⍝ and a corresponding de-parser:⍞000D⍞000D    fx←{                ⍝ Format parse tree.⍞000D        0=≡⍵:⍕⍵         ⍝ atom: done.⍞000D        ↑,/{            ⍝ join branches.⍞000D            0=≡⍵:⍵      ⍝ atom: done.⍞000D            ''('',⍵,'')''   ⍝ parenthesise.⍞000D        }∘∇¨⍵           ⍝ each branch.⍞000D    }⍞000D⍞000D⍝ Expressions in x and y:⍞000D⍞000D    lex rex←px¨ ''(1×2)+y'' ''x+(3×4)''⍞000D⍞000D    disp¨ lex rex⍞000D ┌───┬─┬─┐  ┌─┬─┬───┐⍞000D │1×2│+│y│  │x│+│3×4│⍞000D └───┴─┴─┘  └─┴─┴───┘⍞000D⍞000D⍝ Unification of expressions:⍞000D⍞000D    ''xy''unify lex rex⍞000D┌───┬─┬───┐⍞000D│1×2│+│3×4│⍞000D└───┴─┴───┘⍞000D⍞000D⍝ ... formatted.⍞000D⍞000D    fx ''xy''unify lex rex⍞000D(1×2)+(3×4)⍞000D⍞000D⍝ More complex expressions:⍞000D⍞000D    xa←'' a    + (b÷n) - (b × a) + a    ''⍞000D    xb←''(1-c) + (c÷2) -  d      + e    ''⍞000D    xc←'' f    +  g    -  h      + (i-3)''⍞000D⍞000D    vars←lcase ⎕a       ⍝ vars: a b ··· z⍞000D⍞000D    fx vars unify px¨xa xb xc~¨'' ''⍞000D(1-3)+(3÷2)-(3×(1-3))+(1-3)⍞000D⍞000D⍝ Unify can be used to resolve "logical syllogisms", such as:⍞000D⍝⍞000D⍝   Socrates is a man; all men are mortal; ergo, Socrates is mortal.⍞000D⍞000D    s1←''Socrates'' ''is'' ''man''⍞000D⍞000D    s2←''Man'' ''is'' ''mortal''⍞000D⍞000D    ''man'' ''Man''unify s1 s2⍞000D Socrates  is  mortal⍞000D⍞000D⍝ If both items in the disagreement pair are variables, the (lexically)⍞000D⍝ higher is mapped to the lower. In this example, M→C, M→D, C→A, D→B→A:⍞000D⍞000D    ⎕a unify ''A+B'' ''C+D'' ''M+M''      ⍝ matching variables.⍞000DA+A⍞000D⍞000D⍝ Unify works on any conformable arrays, including those of higher rank.⍞000D⍝ In the following matrices, constant ''*'' propogates through all variables⍞000D⍝ A-Z:⍞000D⍞000D    a←2 13⍴2/13↑⎕a⍞000D    b←2 13⍴13↓⎕a⍞000D    (⊃⌽,b)←''*''⍞000D⍞000D    a b⍞000D┌─────────────┬─────────────┐⍞000D│AABBCCDDEEFFG│NOPQRSTUVWXYZ│⍞000D│GHHIIJJKKLLMM│NOPQRSTUVWXY*│⍞000D└─────────────┴─────────────┘⍞000D⍞000D⍝ * matches M matches Y matches F matches X ...⍞000D⍞000D    ⎕a unify a b⍞000D*************⍞000D*************⍞000D⍞000D⍝ Expression unification is used to infer type in some functional languages.⍞000D⍝ Here is the BNF for a tiny right-associative type expression:⍞000D⍝⍞000D⍝   texp := func | atom⍞000D⍝   func := atom→texp | (texp)→texp⍞000D⍝   atom := tcon | tvar⍞000D⍝   tcon := #⍞000D⍝   tvar := ⍺ | ∆ | ∊ | ⍳ | ⍵⍞000D⍝⍞000D⍝ Type variables are ⍺ ∆ ∊ ⍳ ⍵,⍞000D⍝ # is the only type constant and⍞000D⍝ → is the only type operator.⍞000D⍞000D⍝ Examples of expressions:⍞000D⍝⍞000D⍝   #, ⍺, ⍺→⍵, (⍺→∆)→∊→#⍞000D⍞000D⍝ Parser for such expressions:⍞000D⍞000D    pt←{⎕ML←0                           ⍝ Parse type expression.⍞000D        ⊃⍬{                             ⍝ Parse tree and remainder.⍞000D            0=⍴⍵:⍺ ⍵                    ⍝ done: parse tree and remainder.⍞000D            hd tl←(⊃⍵)(1↓⍵)             ⍝ head and tail of expr.⍞000D            ''(''=hd:↑∇/⍬ ∇ tl            ⍝ parenthesised sub-expr:⍞000D            '')''=hd:⍺ tl                 ⍝ complete sub-expression:⍞000D            ''→''=hd:⌽⍺{⍺⍺ hd ⍵}\⌽⍬ ∇ tl  ⍝ function:⍞000D            hd ∇ tl                     ⍝ atom:⍞000D        }⍵~'' ''                          ⍝ ignoring blanks.⍞000D    }⍞000D⍞000D⍝ and a corresponding de-parser:⍞000D⍞000D    ft←{⎕ML←1                   ⍝ Format parse tree.⍞000D        0=≡⍵:⍕⍵                 ⍝ atom: done.⍞000D        0=≡⊃⍵:∊∇¨⍵              ⍝ atomic left branch: no parens.⍞000D        ''('',(∇⊃⍵),'')'',∊∇¨1↓⍵    ⍝ parenthesised left branch.⍞000D    }⍞000D⍞000D⍝ Parse trees for type expressions:⍞000D⍞000D    pt''⍺→∊→⍳→⍵''⍞000D┌─┬─┬─────────┐⍞000D│⍺│→│┌─┬─┬───┐│⍞000D│ │ ││∊│→│⍳→⍵││⍞000D│ │ │└─┴─┴───┘│⍞000D└─┴─┴─────────┘⍞000D⍞000D    pt''(⍺→∊)→⍳→⍵''⍞000D┌───┬─┬───┐⍞000D│⍺→∊│→│⍳→⍵│⍞000D└───┴─┴───┘⍞000D⍞000D⍝ Formatted parse tree. Note how redundant parentheses are ignored:⍞000D⍞000D    ft pt''(⍺→∊)→(⍳→⍵)''⍞000D(⍺→∊)→⍳→⍵⍞000D⍞000D⍝ Vars: ⍺ ∆ ∊ ⍳ ⍵⍞000D⍞000D    vars←''⍺∆∊⍳⍵''⍞000D⍞000D⍝ Some type expressions:⍞000D⍞000D    xa←''(⍺→⍺)→∊    ''⍞000D    xb←''    ∆→∆    ''⍞000D    xc←''    ⍳→(⍵→#)''⍞000D⍞000D⍝ Unified type expressions:⍞000D⍞000D    ft vars unify pt¨xa xb xc⍞000D(#→#)→#→#⍞000D⍞000D⍝ The following expressions can''t be unified:⍞000D⍞000D    clash←pt¨ ''(⍺→⍺)→⍵'' ''⍺→(⍵→⍵)''⍞000D⍞000D    ft vars unify clash⍞000DCan''t unify⍞000D    ft vars unify clash⍞000D    ∧⍞000D⍝ However, if the intention is that the variables⍞000D⍝ in the expressions are independent, they can be⍞000D⍝ distinguished by:⍞000D⍞000D    dv←{⎕ML←1                   ⍝ Distinguish Variables ⍺ in exprs ⍵.⍞000D        vlft vrgt←⍺∘∩∘∊¨⍵       ⍝ vars in left and right exprs⍞000D        (vlft∩vrgt){            ⍝ duplicate vars.⍞000D            (⊂⍵)∊⍺⍺:(⍺⍺⍳⊂⍵)⊃⍵⍵  ⍝ var in old: subs new.⍞000D            0=≡⍵:⍵              ⍝ atom: pass through.⍞000D            ∇¨⍵                 ⍝ tree: traverse.⍞000D        }(⍺~vlft)\⍵             ⍝ translated right expr.⍞000D    }⍞000D⍞000D⍝ The left argument of dv is the "pool" of⍞000D⍝ variables, available for substitution.⍞000D⍞000D    ft¨clash⍞000D (⍺→⍺)→⍵  ⍺→⍵→⍵⍞000D⍞000D⍝ Distinguish variables:⍞000D⍞000D    ft¨vars dv clash⍞000D (⍺→⍺)→⍵  ∆→∊→∊⍞000D⍞000D⍝ Unify succeeds:⍞000D⍞000D    ft vars unify vars dv clash⍞000D(⍺→⍺)→∊→∊⍞000D⍞000DSee max.dws/Implementation.⍞000D⍞000DSee also: tokens parse⍞000D⍞000DIndex:unification|parsing|polymorphism⍞000DIndex;Brown J.A.|Robinson J.A.' 
