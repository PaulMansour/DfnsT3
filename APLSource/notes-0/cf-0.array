'rslt ← {larg} (land ##.cf rand) rarg        ⍝ Ratio of operand timings.⍞000D⍞000D(cf. compare, abbrv. confer(arch.) [Lat: conferre:com-:together + ferre:bring])⍞000D⍞000DPhil  Last supplies this operator, which reports the ratio of the times taken to⍞000Dapply its left and right operand functions to (or between) its argument(s).⍞000D⍞000D    ⍺ f ∇∇ g ⍵  ←→  (⍺ f time ⍵) ÷ ⍺ g time ⍵⍞000D      f ∇∇ g ⍵  ←→  (  f time ⍵) ÷   g time ⍵⍞000D⍞000DTechnical notes:⍞000D⍞000DPhil points out that we could do some interesting code transformations:⍞000D⍞000D    cf←{⍺←⊢             ⍝ Compare operand timings.⍞000D        a←⍺ ⋄ f←⍺⍺ ⋄ g←⍵⍵ ⋄ w←⍵ ⋄ t←{⍬⍴2↓⎕AI-(⍺⍺/⍳1+⍵)⊢⎕AI}⍞000D        ÷/1{⊃∇/⍺{(1000<+/⍵)↓(2×⍺)⍵}({a f w}t ⍺)({a g w}t ⍺)}1⍞000D    }⍞000D⍞000DSpreading the code over a number of lines, we see:⍞000D⍞000D    cf←{⍺←⊢                             ⍝ Compare operand timings.⍞000D        a←⍺                             ⍝ naming of ⍺⍞000D        f←⍺⍺                            ⍝           ⍺⍺⍞000D        g←⍵⍵                            ⍝           ⍵⍵⍞000D        w←⍵                             ⍝            ⍵⍞000D        t←{                             ⍝ ⍺⍺-timing operator⍞000D            ⍬⍴2↓⎕AI-(⍺⍺/⍳1+⍵)⊢⎕AI       ⍝ time ⍺⍺ ⍺⍺ .. ⍺⍺ applications.   [1]⍞000D        }                               ⍝      └────⍵────┘⍞000D        ÷/1{                            ⍝ ratio of (initially 1) applications.⍞000D            ⊃∇/⍺{                       ⍝ repetition while 2-item vector from:⍞000D                (1000<+/⍵)↓(2×⍺)⍵       ⍝ doubling apps while time < 1 sec.⍞000D            }({a f w}t ⍺)({a g w}t ⍺)   ⍝ timing each function f and g.    [2]⍞000D        }1⍞000D    }⍞000D⍞000Dcf keeps doubling the number of function applications in line[1] until the total⍞000Dtime spent is at least one second.⍞000D⍞000DNotice  that the operands of the timing operator t: {a f w} & {a g w} in line[2]⍞000Dare constant functions in that they ignore any arguments. Phil notes that we can⍞000Dderive such constant function without having to name their arguments. So instead⍞000Dof:⍞000D⍞000D    a←⍺   ┐⍞000D    f←⍺⍺  ├─── {a f w}⍞000D    g←⍵⍵  ├─── {a g w}⍞000D    w←⍵   ┘⍞000D⍞000Dwe can say:⍞000D                   ┐⍞000D    ff←⊢∘(⍺∘⍺⍺)∘⍵  ├─── ff⍞000D            ¯¯     │⍞000D    gg←⊢∘(⍺∘⍵⍵)∘⍵  ├─── gg⍞000D            ¯¯     ┘⍞000D⍞000DYou can try this in the session with a constant-function-making operator:⍞000D⍞000D    mkff←{ ff∘←⊢∘(⍺∘⍺⍺)∘⍵ }     ⍝ make constant function:   ff←{⍺ ⍺⍺ ⍵}.⍞000D⍞000D      2 + mkff 3                ⍝ ff←{2+3}⍞000D⍞000D      ff 99⍞000D5⍞000D⍞000DAlthough not necessary in this case, we could extend mkff to generate a function⍞000Dthat ignores both its right and _left_ arguments by binding a further ⊢∘:⍞000D⍞000D    mkff←{ ff∘←⊢∘(⊢∘(⍺∘⍺⍺)∘⍵) }         ⍝ make constant function ff←{⍺ ⍺⍺ ⍵}.⍞000D               ¯¯          ¯⍞000D    20 + mkff 30                        ⍝ ff←{20+30}⍞000D⍞000D    ff 4                                ⍝ right and⍞000D50⍞000D    2 ff 3                              ⍝ left arg ignored.⍞000D50⍞000D⍞000D(muse:⍞000D    If  Dyalog were extended to allow functions (and operators) to return funct-⍞000D    ions as results, the above might look a little neater:⍞000D⍞000D        mk∆ ← {⍺←⊢ ⋄ ⊢∘(⊢∘(⍺∘⍺⍺)∘⍵) }           ⍝ constant function: {⍺ ⍺⍺ ⍵}.⍞000D⍞000D        gg ← 3 × mk∆ 4                          ⍝ gg←{3×4}⍞000D⍞000D        ''do'' gg ''zen''⍞000D    12⍞000D⍞000D    This  is explored further in the experimental  "Function Results Edition" of⍞000D    Dyalog, See: http://dfns.dyalog.com/downloads/fre.pdf⍞000D)⍞000D⍞000DIncorporating this technique into our cf operator yields:⍞000D⍞000D    cf←{⍺←⊢                             ⍝ Compare operand timings.⍞000D        ff←⊢∘(⍺∘⍺⍺)∘⍵                   ⍝ naming of {⍺ ⍺⍺ ⍵}⍞000D        gg←⊢∘(⍺∘⍵⍵)∘⍵                   ⍝           {⍺ ⍵⍵ ⍵}⍞000D        t←{                             ⍝ ⍺⍺-timing operator⍞000D            ⍬⍴2↓⎕AI-(⊢∘⍺⍺/⍳1+⍵)⊢⎕AI     ⍝ time ⍺⍺ ⍺⍺ .. ⍺⍺ applications.   [1]⍞000D        }                               ⍝      └────⍵────┘⍞000D        ÷/1{                            ⍝ ratio of (initially 1) applications.⍞000D            ⊃∇/⍺{                       ⍝ repetition while 2-item vector from:⍞000D                (1000<+/⍵)↓(2×⍺)⍵       ⍝ doubling apps while time < 1 sec.⍞000D            }(ff t ⍺)(gg t ⍺)           ⍝ timing each function ff and gg.  [2]⍞000D        }1  ⍝ ¯¯      ¯¯⍞000D    }⍞000D⍞000DNext, we can avoid naming ff and gg by binding them with the timing operator and⍞000Dpassing the resulting derived functions as operands to line[2]:⍞000D⍞000D    cf←{⍺←⊢                             ⍝ Compare operand timings.⍞000D        t←{                             ⍝ ⍺⍺-timing operator⍞000D            ⍬⍴2↓⎕AI-(⊢∘⍺⍺/⍳1+⍵)⊢⎕AI     ⍝ time ⍺⍺ ⍺⍺ .. ⍺⍺ applications.   [1]⍞000D        }                               ⍝      └────⍵────┘⍞000D        ÷/1 ⊢∘(⍺∘⍺⍺)∘⍵ t{               ⍝ ratio of (initially 1) applications.⍞000D            ⊃∇/⍺{                       ⍝ repetition while 2-item vector from:⍞000D                (1000<+/⍵)↓(2×⍺)⍵       ⍝ doubling apps while time < 1 sec.⍞000D            }(⍺⍺ ⍺)(⍵⍵ ⍺)               ⍝ timing each function ⍺⍺ and ⍵⍵.  [2]⍞000D        }(⊢∘(⍺∘⍵⍵)∘⍵ t)1                ⍝ ⍵⍵ timing function.⍞000D    }⍞000D⍞000DUnfortunately,  in the absence of a higher level "hyperator" that takes operator⍞000Dt  as operand, this is as far as we can go, unless we are prepared to repeat the⍞000Ddefinition  of  t  for left and right operands. Either way, we wind up with a cf⍞000Doperator that has no local assignment and no guards; it is a simple expression:⍞000D⍞000D    cf←{⍺←⊢             ⍝ Compare operand timings.⍞000D        ÷/1⊢∘(⊢∘(⍺∘⍺⍺)∘⍵){⍬⍴2↓⎕AI-(⍺⍺/⍳1+⍵)⊢⎕AI}{⍞000D            ⊃∇/⍺{⍞000D                (1000<+/⍵)↓(2×⍺)⍵⍞000D            }(⍺⍺ ⍺)(⍵⍵ ⍺)⍞000D        }(⊢∘(⊢∘(⍺∘⍵⍵)∘⍵){⍬⍴2↓⎕AI-(⍺⍺/⍳1+⍵)⊢⎕AI})1⍞000D    }⍞000D⍞000DExamples:⍞000D⍞000D    {(+/⍵)÷⍴⍵} cf {+/⍵÷⍴⍵}  ⍳1000       ⍝ compare codings of mean.⍞000D0.164⍞000D⍞000D    ⎕av (,⍨¨) cf (,¨⍨) ⎕av              ⍝ commute-each vs. each-commute.⍞000D1.35⍞000D⍞000DSee also: cmpx⍞000D⍞000DIndex:performance|timing|expression comparison|hyperator⍞000DIndex:closure|Function Results Edition⍞000DIndex;Last P.' 
