'rslt ← larg (selector ##.logic) rarg        ⍝ logical function array.⍞000D⍞000DSupplied by Phil Last, who says:⍞000D⍞000DLogical  dyadic  functions each take two boolean args and return one. The domain⍞000Dof  scalar  argument pairs is therefore (0 0)(0 1)(1 0)(1 1) and the codomain of⍞000Dscalar  results  is 0 1. The results from one particular function for the 4 mem-⍞000Dbers of the domain can be used to characterise the function. e.g.:⍞000D⍞000D       =/¨(0 0)(0 1)(1 0)(1 1)⍞000D1 0 0 1⍞000D⍞000DWe  can conveniently 2∘⊥ this result to give us a single integer that completely⍞000Didentifies  the  function  (in the above case, 9). There must therefore be (2*4)⍞000Di.e. 16 possible logical dyadic functions. The mapping is shown in the table ...⍞000D⍞000D    ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐⍞000D    │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │10 │11 │12 │13 │14 │15 │⍞000D    ├───┼───┼───┼───┼───┼───┼───┼───┼───┼───┼───┼───┼───┼───┼───┼───┤⍞000D    │ 0 │ ∧ │ > │ ⍺ │ < │ ⍵ │ ≠ │ ∨ │ ⍱ │ = │~⍵ │ ≥ │~⍺ │ ≤ │ ⍲ │ 1 │⍞000D    └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘⍞000D⍞000DFunctions  0, 3, 5, 10, 12 and 15 are the 6 that most APLs don''t implement leav-⍞000Ding the 10 logical functions in the standard. Nowhere are any of them implement-⍞000Ded  as  true  scalar functions notwithstanding ← and → in Sharp APL, and ⊣ and ⊢⍞000Din D:⍞000D⍞000D(⍞000D    Perhaps  a  little tongue-in-cheek, Phil suggests that "notwithstanding" and⍞000D    "nevertheless" might be apt names for functions ⊣ and ⊢ respectively:⍞000D⍞000D    "this notwithstanding that" implies "this",⍞000D    "this nevertheless that"    implies "that".⍞000D⍞000D    Interestingly, both the Oxford and Collins dictionaries imply that the words⍞000D    are synonymous, whereas it is clear from the above that.⍞000D⍞000D        notwithstanding ←→ nevertheless ⍨⍞000D        nevertheless ←→ notwithstanding ⍨⍞000D⍞000D    As Phil says, this feels a little like saying that "because" and "therefore"⍞000D    mean the same thing.⍞000D)⍞000D⍞000DHere they are as D:fns⍞000D⍞000D      f0←{0∧⍺=⍵}⍞000D      f3←{⍺=⍵=⍵}⍞000D      f5←{⍵=⍺=⍺}⍞000D      fa←{⍵≠⍺=⍺}⍞000D      fc←{⍺≠⍵=⍵}⍞000D      ff←{1∨⍺=⍵}⍞000D⍞000DD:op (logic) supplies any or all of them according to its operand.⍞000D⍞000D⍺ and ⍵ are conformable logical arrays, any rank, any depth. ⍺⍺ is a function⍞000Dthat returns a simple integer array conformable with ⍺ and ⍵.⍞000D⍞000DThus:⍞000D⍞000D    {1}logic is ∧ and {7}logic is ∨,⍞000D⍞000D    {6 11 13}logic is a 3 item function array of ≠ ≥ ≤,⍞000D⍞000D    {4 4⍴16?16}logic is a 4x4 array of all the logical functions in some order.⍞000D⍞000DTechnical notes:⍞000D⍞000D    logic←{                         ⍝ logical function array⍞000D        ⊃(0 1 2 3=+/⍺ ⍺ ⍵)∨.∧{⍞000D            ⊂[1+⍳⍴⍴⍵]2 2 2 2⊤⍵⍞000D        }⍺ ⍺⍺ ⍵⍞000D    }⍞000D⍞000DThe ⊃ acts on a scalar, so is ⎕ML-proof.⍞000D⍞000DThe 1+⍳... is an axis spec, so is ⎕IO-proof.⍞000D⍞000DThe }⍺ ⍺⍺ ⍵ is in case the shapes of ⍺ and ⍵ are required to select or reshape⍞000Dthe integer array inside ⍺⍺. e.g.⍞000D⍞000D    {(⍴⍺=⍵){⍺⍴(0⊥⍺)⍴⍵}integers}logic    ⍝ a function for each column⍞000D⍞000DExamples:⍞000D⍞000D      0 0 1 1  {0}logic 0 1 0 1     ⍝  0    0⍞000D0 0 0 0⍞000D      0 0 1 1  {1}logic 0 1 0 1     ⍝  1    ∧⍞000D0 0 0 1⍞000D      0 0 1 1  {2}logic 0 1 0 1     ⍝  2    >⍞000D0 0 1 0⍞000D      0 0 1 1  {3}logic 0 1 0 1     ⍝  3    ⍺⍞000D0 0 1 1⍞000D      0 0 1 1  {4}logic 0 1 0 1     ⍝  4    <⍞000D0 1 0 0⍞000D      0 0 1 1  {5}logic 0 1 0 1     ⍝  5    ⍵⍞000D0 1 0 1⍞000D      0 0 1 1  {6}logic 0 1 0 1     ⍝  6    ≠⍞000D0 1 1 0⍞000D      0 0 1 1  {7}logic 0 1 0 1     ⍝  7    ∨⍞000D0 1 1 1⍞000D      0 0 1 1  {8}logic 0 1 0 1     ⍝  8    ⍱⍞000D1 0 0 0⍞000D      0 0 1 1  {9}logic 0 1 0 1     ⍝  9    =⍞000D1 0 0 1⍞000D      0 0 1 1 {10}logic 0 1 0 1     ⍝ 10   ~⍵⍞000D1 0 1 0⍞000D      0 0 1 1 {11}logic 0 1 0 1     ⍝ 11    ≥⍞000D1 0 1 1⍞000D      0 0 1 1 {12}logic 0 1 0 1     ⍝ 12   ~⍺⍞000D1 1 0 0⍞000D      0 0 1 1 {13}logic 0 1 0 1     ⍝ 13    ≤⍞000D1 1 0 1⍞000D      0 0 1 1 {14}logic 0 1 0 1     ⍝ 14    ⍲⍞000D1 1 1 0⍞000D      0 0 1 1 {15}logic 0 1 0 1     ⍝ 15    1⍞000D1 1 1 1⍞000D⍞000D      disp l n r←(3 4⍴0 0 1 1)(⍉4 3⍴6 11 13)(3 4⍴0 1 0 1)⍞000D┌───────┬───────────┬───────┐⍞000D│0 0 1 1│ 6  6  6  6│0 1 0 1│⍞000D│0 0 1 1│11 11 11 11│0 1 0 1│⍞000D│0 0 1 1│13 13 13 13│0 1 0 1│⍞000D└───────┴───────────┴───────┘⍞000D⍞000D      l,''≠≥≤'',r,''→'',l{n}logic r     ⍝ apply functions in parallel.⍞000D0 0 1 1 ≠ 0 1 0 1 → 0 1 1 0⍞000D0 0 1 1 ≥ 0 1 0 1 → 1 0 1 1⍞000D0 0 1 1 ≤ 0 1 0 1 → 1 1 0 1⍞000D⍞000DSee also: truth_tables⍞000D⍞000DIndex:conditional operator|boolean functions|truth tables|⎕ML⍞000DIndex;Last P.' 
