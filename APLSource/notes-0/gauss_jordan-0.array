'inv ← {vals} ##.gauss_jordan mat            ⍝ Gauss-Jordan elimination.⍞000D⍞000DGauss-Jordan elimination is a classic algorithm, implemented the D-style.⍞000D⍞000DNB: This  function  is  included  only  for interest as APL provides both matrix⍞000Dinverse and matrix division as a primitive function: ⌹.⍞000D⍞000DFurther, the results of this D-function differ very slightly from those of APL''s⍞000Dprimitive  function. This may be because APL''s C-code maintains 80-bit floating-⍞000Dpoint  accuracy during (much, if not all of) its calculation, whereas the inter-⍞000Dmediate  arrays of this function use only 64 bits. Of course, the function could⍞000Dbe  adapted  to use, for example, rational →rats← arithmetic for perfect precis-⍞000Dion (see test script: ##.scripts.gauss_jordan).⍞000D⍞000DMatrix  right  argument  [mat] represents the coefficients of a system of linear⍞000Dequations and,  if present, left argument [vals] represents the equations'' value⍞000Dvector (right-hand side).⍞000D⍞000DFor example:⍞000D⍞000D      x +   y + 2z = ¯3⍞000D    ¯1x + ¯2y + 3z = 14⍞000D     3x + ¯7y + 4z = ¯3⍞000D⍞000Dwhich may be written:⍞000D⍞000D    A x = v⍞000D    ¯ ¯   ¯⍞000Dwhere:⍞000D        ┌ 1  1 2┐   v = [¯3 14 ¯3]⍞000D    A = │¯1 ¯1 3│   ¯⍞000D    ¯   │ 3 ¯7 4│⍞000D        └       ┘⍞000D⍞000DThen the solution vector x is:⍞000D                         ¯⍞000D    x = v ⌹ A               ⍝ using dyadic ⌹.⍞000D    ¯   ¯   ¯⍞000Dor⍞000D    x = (⌹ A) × v           ⍝ using monadic ⌹ (where × is matrix product +.×).⍞000D    ¯      ¯  ¯ ¯                                    ¯⍞000DGauss-Jordan uses three simple transformations, none of which changes the solut-⍞000Dion of the equations. For example, starting with:⍞000D⍞000D[0] Initial equations:⍞000D⍞000D      x +   y + 2z = ¯3⍞000D    ¯1x + ¯2y + 3z = 14⍞000D     3x + ¯7y + 4z = ¯3⍞000D⍞000D[1] Exchange rows:⍞000D⍞000D    ¯1x + ¯2y + 3z = 14     ⍝ swap first and second rows.⍞000D      x +   y + 2z = ¯3⍞000D     3x + ¯7y + 4z = ¯3⍞000D⍞000D[2] Multiply each term in a row by the same factor:⍞000D⍞000D    ¯1x + ¯2y + 3z = 14⍞000D     3x +  3y + 6z = ¯9     ⍝ multiply second row by 3.⍞000D     3x + ¯7y + 4z = ¯3⍞000D⍞000D[3] Subtract one row from another:⍞000D⍞000D    ¯1x +  ¯2y +  3z = ¯2⍞000D     3x +   3y +  6z = ¯9⍞000D     0x + ¯10y + ¯2z =  6   ⍝ subtract second row from third.⍞000D⍞000DThe algorithm applies these three steps repeatedly, until the coefficient matrix⍞000Dis transformed into an identity matrix, giving:⍞000D⍞000D    1x + 0y + 0z = ¯6⍞000D    0x + 1y + 0z = ¯1⍞000D    0x + 0y + 1z =  2⍞000D⍞000Dor:⍞000D⍞000D     x    ·    · = ¯6⍞000D     ·    y    · = ¯1⍞000D     ·    ·    z =  2⍞000D⍞000DMonadic case⍞000D------------⍞000DWe  find  the explicit matrix inverse by starting with an identity matrix on the⍞000Dright:⍞000D⍞000D[0]                                         ⍝ initial matrix:⍞000D     1x +  1y + 2z = 1 0 0⍞000D    ¯1x + ¯2y + 3z = 0 1 0⍞000D     3x + ¯7y + 4z = 0 0 1⍞000D[1]                                         ⍝ exchange first and third rows:⍞000D     3x + ¯7y + 4z = 0 0 1⍞000D    ¯1x + ¯2y + 3z = 0 1 0⍞000D     1x +  1y + 2z = 1 0 0⍞000D[2]⍞000D     1x + ¯2.333y + 1.333z = 0 0 0.333      ⍝ multiply first row by ÷3:⍞000D    ¯1x +     ¯2y +     3z = 0 1 0⍞000D     1x +      1y +     2z = 1 0 0⍞000D[3]                                         ⍝ subtract first row from others:⍞000D     1x + ¯2.333y + 1.333z = 0 0  0.333⍞000D     0x + ¯4.333y + 4.333z = 0 1  0.333⍞000D     0x +  3.333y + 0.667z = 1 0 ¯0.333⍞000D...                                         ⍝ and so on, until:⍞000D     1x +  0y + 0z = 0.25 ¯0.346  0.135⍞000D     0x +  1y + 0z = 0.25 ¯0.038 ¯0.096⍞000D     0x +  0y + 1z = 0.25  0.192 ¯0.019⍞000D⍞000DChoosing a pivot value⍞000D----------------------⍞000DIn  a  finite-precision implementation, such as IEEE floating point, subtracting⍞000Drelatively  large  but  commensurate  numbers  introduces  a  significant error.⍞000DGauss-Jordan  reduces this as much as possible by choosing the "pivot" value for⍞000Dtransformation [2] to be the item with the largest absolute magnitude within the⍞000Dremaining rows of the column under consideration.⍞000D⍞000D       before                                                      after⍞000D    1  0  · · · ·                                               1  0  · · · ·⍞000D    0  1  · · · ·     In this example, working on the third     0  1  · · · ·⍞000D    0  0  3 · · ·     column,  the pivot (max abs) value is     0  0 ¯4 · · ·⍞000D    0  0 ¯2 · · ·     ¯4,  resulting in the exchange of the     0  0 ¯2 · · ·⍞000D    0  0 ¯4 · · ·     third and fifth rows.                     0  0  3 · · ·⍞000D    0  0  1 · · ·                                               0  0  1 · · ·⍞000D⍞000DNotice that values in the first two rows of the third column are ignored.⍞000D⍞000DPut simply,  the pivot value for column ⍺ is the item from rows ⍺ downwards with⍞000Dthe largest absolute value: ⌈/|⍺↓⍵[;⍺].⍞000D⍞000DIllustration⍞000D------------⍞000DHere is an illustration of the steps in the Gauss-Jordan elimination of:⍞000D⍞000D    ┌────────┐⍞000D    │4 8 4  0│⍞000D    │1 4 7  2│⍞000D    │1 5 4 ¯3│⍞000D    │1 3 0 ¯2│⍞000D    └────────┘⍞000D⍞000DAppend an identity matrix:⍞000D⍞000D    ┌────────┬───────┐⍞000D    │4 8 4  0│1 0 0 0│ append identity matrix.⍞000D    │1 4 7  2│0 1 0 0│⍞000D    │1 5 4 ¯3│0 0 1 0│⍞000D    │1 3 0 ¯2│0 0 0 1│⍞000D    └────────┴───────┘⍞000D⍞000DEliminate off-diagonal values from first column:⍞000D    ┌┬───────┬───────┐⍞000D    │4 8 4  0│1 0 0 0│ first col; pivot value is 4.        (4)· · ·⍞000D    │1 4 7  2│0 1 0 0│                                      1 · · ·⍞000D    │1 5 4 ¯3│0 0 1 0│                                      1 · · ·⍞000D    │1 3 0 ¯2│0 0 0 1│                                      1 · · ·⍞000D    └┴───────┴───────┘⍞000D    ┌────────┬──────────┐⍞000D    ├1─2─1──0┼0.25─0─0─0┤ divide first row by pivot value.⍞000D    │1 4 7  2│0    1 0 0│⍞000D    │1 5 4 ¯3│0    0 1 0│⍞000D    │1 3 0 ¯2│0    0 0 1│⍞000D    └────────┴──────────┘⍞000D    ┌─────────┬───────────┐⍞000D    │1 2  1  0│ 0.25 0 0 0│ subtract first row from remaining rows.⍞000D    │0 2  6  2│¯0.25 1 0 0│ to leave 0s in all off-diagonal rows⍞000D    │0 3  3 ¯3│¯0.25 0 1 0│ of first column.⍞000D    │0 1 ¯1 ¯2│¯0.25 0 0 1│⍞000D    └─────────┴───────────┘⍞000D⍞000DEliminate off-diagonal values from second column:⍞000D    ┌──┬──────┬───────────┐⍞000D    │1 2  1  0│ 0.25 0 0 0│                                 · · · ·⍞000D    │0 2  6  2│¯0.25 1 0 0│                                 · 2 · ·⍞000D    │0 3  3 ¯3│¯0.25 0 1 0│ second col; pivot value is 3.   ·(3)· ·⍞000D    │0 1 ¯1 ¯2│¯0.25 0 0 1│                                 · 1 · ·⍞000D    └──┴──────┴───────────┘⍞000D    ┌─────────┬───────────┐⍞000D    │1 2  1  0│ 0.25 0 0 0│                                 · · · ·⍞000D    ├0─3──3─¯3┼¯0.25─0─1─0┤ swap second row with            ·(3)· ·⍞000D    ├0─2──6──2┼¯0.25─1─0─0┤ pivot value row.                · 2 · ·⍞000D    │0 1 ¯1 ¯2│¯0.25 0 0 1│                                 · 1 · ·⍞000D    └─────────┴───────────┘⍞000D    ┌─────────┬───────────────────┐⍞000D    │1 2  1  0│ 0.25    0 0      0│⍞000D    ├0─1──1─¯1┼¯0.08333─0─0.3333─0┤ divide second row by pivot value.⍞000D    │0 2  6  2│¯0.25    1 0      0│⍞000D    │0 1 ¯1 ¯2│¯0.25    0 0      1│⍞000D    └─────────┴───────────────────┘⍞000D    ┌─────────┬────────────────────┐⍞000D    │1 0 ¯1  2│ 0.4167  0 ¯0.6667 0│ subtract multiples of second row from⍞000D    │0 1  1 ¯1│¯0.08333 0  0.3333 0│ remaining rows to leave 0s in all⍞000D    │0 0  4  4│¯0.08333 1 ¯0.6667 0│ off-diagonal rows of second column.⍞000D    │0 0 ¯2 ¯1│¯0.1667  0 ¯0.3333 1│⍞000D    └─────────┴────────────────────┘⍞000D⍞000DEliminate off-diagonal values from third column:⍞000D    ┌─────┬───┬────────────────────┐⍞000D    │1 0 ¯1  2│ 0.4167  0 ¯0.6667 0│                                · · · ·⍞000D    │0 1  1 ¯1│¯0.08333 0  0.3333 0│                                · · · ·⍞000D    │0 0  4  4│¯0.08333 1 ¯0.6667 0│ third col; pivot value is 4.   · ·(4)·⍞000D    │0 0 ¯2 ¯1│¯0.1667  0 ¯0.3333 1│                                · ·¯2 ·⍞000D    └─────┴───┴────────────────────┘⍞000D    ┌─────────┬───────────────────────┐⍞000D    │1 0 ¯1  2│ 0.4167  0    ¯0.6667 0│⍞000D    │0 1  1 ¯1│¯0.08333 0     0.3333 0│⍞000D    ├0─0──1──1┼¯0.02083─0.25─¯0.1667─0┤ divide third row by pivot value.⍞000D    │0 0 ¯2 ¯1│¯0.1667  0    ¯0.3333 1│⍞000D    └─────────┴───────────────────────┘⍞000D    ┌────────┬────────────────────────┐⍞000D    │1 0 0  3│ 0.3958   0.25 ¯0.8333 0│ subtract multiples of third row from⍞000D    │0 1 0 ¯2│¯0.0625  ¯0.25  0.5    0│ remaining rows to leave 0s in all⍞000D    │0 0 1  1│¯0.02083  0.25 ¯0.1667 0│ off-diagonal rows of third column.⍞000D    │0 0 0  1│¯0.2083   0.5  ¯0.6667 1│⍞000D    └────────┴────────────────────────┘⍞000D⍞000DEliminate off-diagonal values from fourth column:⍞000D    ┌───────┬┬────────────────────────┐⍞000D    │1 0 0  3│ 0.3958   0.25 ¯0.8333 0│                                 · · · ·⍞000D    │0 1 0 ¯2│¯0.0625  ¯0.25  0.5    0│                                 · · · ·⍞000D    │0 0 1  1│¯0.02083  0.25 ¯0.1667 0│                                 · · · ·⍞000D    │0 0 0  1│¯0.2083   0.5  ¯0.6667 1│ fourth col; pivot value is 1.   · · ·(1)⍞000D    └───────┴┴────────────────────────┘⍞000D    ┌───────┬────────────────────────┐⍞000D    │1 0 0 0│ 1.021  ¯1.25  1.167  ¯3│ subtract multiples of fourth row⍞000D    │0 1 0 0│¯0.4792  0.75 ¯0.8333  2│ from remaining rows to leave 0s in all⍞000D    │0 0 1 0│ 0.1875 ¯0.25  0.5    ¯1│ off-diagonal rows of fourth column.⍞000D    │0 0 0 1│¯0.2083  0.5  ¯0.6667  1│⍞000D    └───────┴────────────────────────┘⍞000D⍞000DDrop leading identity matrix for inverse of original matrix:⍞000D            ┌────────────────────────┐⍞000D            │ 1.021  ¯1.25  1.167  ¯3│⍞000D            │¯0.4792  0.75 ¯0.8333  2│⍞000D            │ 0.1875 ¯0.25  0.5    ¯1│⍞000D            │¯0.2083  0.5  ¯0.6667  1│⍞000D            └────────────────────────┘⍞000D⍞000D(muse:⍞000D⍞000D    As supplied,  the function is offensive to the functional programming purist⍞000D    because it uses destructive assignment:⍞000D⍞000D        mat←⍵                               ⍝ name matrix for updating.⍞000D        mat[⍺ p;]←mat[p ⍺;]                 ⍝ exchange ⍺th and pth rows.⍞000D        mat[⍺;]÷←mat[⍺;⍺]                   ⍝ reduce col diagonal to 1.⍞000D⍞000D    For fun, we could recast it in a (non-destructive) purer form:⍞000D⍞000D    gauss_jordan←{⎕ML ⎕IO←0                   ⍝ Gauss-Jordan elimination.⍞000D⍞000D        elim←{                                ⍝ elimination of row/col ⍺.⍞000D            mask←⍺=⍳⊃⍴⍵                       ⍝ selection mask for ⍺th row.⍞000D            pivt←{⍵⍳⌈/⍵}|⍵[;⍺]×∨\mask         ⍝ position of pivot row.⍞000D            mat1←⍺ pivt swap ⍵                ⍝ exchanged ⍺th and pth rows.⍞000D            mat2←mat1÷[0]⍵[pivt;⍺]*mask       ⍝ ⍺th row divided by pivot.⍞000D            mat2-(mat2[;⍺]×~mask)∘.×mat2[⍺;]  ⍝ remaining rows reduced by pvt.⍞000D        }⍞000D⍞000D        swap←{                                ⍝ matrix ⍵ with rows ⍺ exchanged.⍞000D            i←⍳⊃⍴⍵                            ⍝ index vector for rows.⍞000D            y n←1 0=⊂i∊⍺                      ⍝ mask and not-mask for swap rows.⍞000D            ⍵[(n\n/i)+y\⌽y/i;]                ⍝ merge with reversed rows.⍞000D        }⍞000D⍞000D        0::⎕SIGNAL ⎕EN                        ⍝ pass back error to caller.⍞000D⍞000D        ⍺←=/↑⍳⍴⍵                              ⍝ id matrix for monadic case.⍞000D⍞000D        (⍴⍺)⍴(0 1×⍴⍵)↓↑elim/(⌽⍳⌊/⍴⍵),⊂⍵,⍺     ⍝ elimination/ ··· 2 1 0 (⍵,⍺)⍞000D⍞000D        See also →at←⍞000D    }⍞000D⍞000D    Further,  we could remove square-bracket-indexing and represent our matrices⍞000D    as vectors-of-row-vectors:⍞000D⍞000D    gauss_jordan←{⎕ML ⎕IO←0                 ⍝ Gauss-Jordan elimination.⍞000D⍞000D        elim←{                              ⍝ elimination of row/col ⍺.⍞000D            mask←⍺=⍳⍴⍵                      ⍝ selection mask for ⍺th row/col.⍞000D            pivt←{⍵⍳⌈/⍵}|(⍺⊃¨⍵)×∨\mask      ⍝ position of pivot row.⍞000D            mat1←⍺ pivt swap ⍵              ⍝ exchanged ⍺th and pivot''th rows.⍞000D            mat2←mat1÷(pivt ⍺⊃⍵)*mask       ⍝ ⍺th row divided by pivot.⍞000D            mat2-((⍺⊃¨mat2)×~mask)×⊂⍺⊃mat2  ⍝ remaining rows reduced by pivot.⍞000D        }⍞000D⍞000D        swap←{                              ⍝ swap rows ⍺ in matrix ⍵.⍞000D            i←⍳⍴⍵                           ⍝ index vector for rows.⍞000D            y n←1 0=⊂i∊⍺                    ⍝ mask and not-mask for swap rows.⍞000D            ((n\n/i)+y\⌽y/i)⊃¨⊂⍵            ⍝ merge with reversed rows.⍞000D        }⍞000D⍞000D        0::⎕SIGNAL ⎕EN                      ⍝ pass back error to caller.⍞000D⍞000D        ⍺←=/↑⍳⍴⍵                            ⍝ id matrix for monadic case.⍞000D⍞000D        (⍴⍺)⍴(0 1×⍴⍵)↓↑↑elim/(⌽⍳⌊/⍴⍵),⊂↓⍵,⍺ ⍝ elimination/ ··· 2 1 0 (⍵,⍺)⍞000D    }⍞000D⍞000D    The  clinically  obsessive would now be in a position to refine the function⍞000D    still further by replacing local names with additional inner D-functions and⍞000D    operators.⍞000D⍞000D    Pursuing  this  approach  to  the edge of reason, we wind up with a function⍞000D    that  is a single expression of functions and operators, with no assignments⍞000D    or  guards.  Here  is  the  code for the monadic case (the dyadic equivalent⍞000D    replaces  (=/↑⍳⍴⍵)  with  ⍺ in the first line). The expression is strung out⍞000D    over a number of lines with some white space:⍞000D⍞000D    {⍞000D    ·   (=/↑⍳⍴⍵){⍞000D    ·   ·   (⍴⍺)⍴(0 1×⍴⍵)↓↑↑{⍞000D    ·   ·   ·   ⍺(⍞000D    ·   ·   ·   ·   (⍺=⍳⍴⍵){⍞000D    ·   ·   ·   ·   ·   ⍺(⍞000D    ·   ·   ·   ·   ·   ·   ⍺⍺{⍞000D    ·   ·   ·   ·   ·   ·   ·   ⍵-(⍞000D    ·   ·   ·   ·   ·   ·   ·   ·   (⍺⊃¨⍵)×~⍺⍺⍞000D    ·   ·   ·   ·   ·   ·   ·   )×⊂⍺⊃⍵⍞000D    ·   ·   ·   ·   ·   ·   }⍞000D    ·   ·   ·   ·   ·   )⍺(⍞000D    ·   ·   ·   ·   ·   ·   (⍞000D    ·   ·   ·   ·   ·   ·   ·   {⍵⍳⌈/⍵}|(⍺⊃¨⍵)×∨\⍺⍺⍞000D    ·   ·   ·   ·   ·   ·   ){⍞000D    ·   ·   ·   ·   ·   ·   ·   (⍞000D    ·   ·   ·   ·   ·   ·   ·   ·   ⍺ ⍺⍺{⍞000D    ·   ·   ·   ·   ·   ·   ·   ·   ·   ⍺(⍞000D    ·   ·   ·   ·   ·   ·   ·   ·   ·   ·   (⍳⍴⍵){⍞000D    ·   ·   ·   ·   ·   ·   ·   ·   ·   ·   ·   ↑⍵{⍞000D    ·   ·   ·   ·   ·   ·   ·   ·   ·   ·   ·   ·   (⍞000D    ·   ·   ·   ·   ·   ·   ·   ·   ·   ·   ·   ·   ·   (⍵\⍵/⍵⍵)+⍺\⌽⍺/⍵⍵⍞000D    ·   ·   ·   ·   ·   ·   ·   ·   ·   ·   ·   ·   )⊃¨⊂⍺⍺⍞000D    ·   ·   ·   ·   ·   ·   ·   ·   ·   ·   ·   }⍺⍺/1 0=⊂⍺⍺∊⍺⍞000D    ·   ·   ·   ·   ·   ·   ·   ·   ·   ·   }⍞000D    ·   ·   ·   ·   ·   ·   ·   ·   ·   )⍵⍞000D    ·   ·   ·   ·   ·   ·   ·   ·   }⍵⍞000D    ·   ·   ·   ·   ·   ·   ·   )÷(⍺⍺ ⍺⊃⍵)*⍵⍵⍞000D    ·   ·   ·   ·   ·   ·   }⍺⍺⍞000D    ·   ·   ·   ·   ·   )⍵⍞000D    ·   ·   ·   ·   }⍞000D    ·   ·   ·   )⍵⍞000D    ·   ·   }/(⌽⍳⌊/⍴⍵),⊂↓⍵,⍺⍞000D    ·   }⍵⍞000D    }⍞000D⍞000D    We  can check that the coding is correct by pasting the lines into character⍞000D    variable gj_src, say, and then executing:⍞000D⍞000D        (⎕io ⎕ml) ⎕pp ← 0 4                             ⍝ condition environment.⍞000D⍞000D        (⍎gj_src~⎕tc,''·'') 3 3⍴ 1 2 3, ¯3 1 5, 2 4 ¯1    ⍝ apply function.⍞000D     0.4286 ¯0.2857 ¯0.1429⍞000D    ¯0.1429  0.1429  0.2857⍞000D     0.2857  0      ¯0.1429⍞000D)⍞000D⍞000DExamples:⍞000D⍞000D    ⎕←mat←4 4⍴ 4 8 4 0, 1 4 7 2, 1 5 4 ¯3, 1 3 0 ¯2⍞000D4 8 4  0⍞000D1 4 7  2⍞000D1 5 4 ¯3⍞000D1 3 0 ¯2⍞000D⍞000D    ⎕pp←4                           ⍝ display numbers to 4 sig-figs.⍞000D⍞000D    gauss_jordan mat                ⍝ matrix inverse.⍞000D 1.021  ¯1.25  1.167  ¯3⍞000D¯0.4792  0.75 ¯0.8333  2⍞000D 0.1875 ¯0.25  0.5    ¯1⍞000D¯0.2083  0.5  ¯0.6667  1⍞000D⍞000D    1 2 3 4 gauss_jordan mat        ⍝ matrix divide.⍞000D¯9.979 6.521 ¯2.813 2.792⍞000D⍞000D    (⌹mat)≡gauss_jordan mat         ⍝ check against primitive matrix inverse.⍞000D1⍞000D⍞000D    (1 2 3 4⌹mat)≡1 2 3 4 gauss_jordan mat      ⍝ ditto matrix divide.⍞000D1⍞000D⍞000D⍝ Using an order-⍵ Hilbert matrix, we can see the slight variation between⍞000D⍝ primitive ⌹ and the D-function, as errors accumulate.⍞000D⍞000D    hil←{÷1+∘.+⍨(⍳⍵)-⎕IO}           ⍝ order-⍵ Hilbert matrix.⍞000D⍞000D⍝ The results are identical up to hil 5:⍞000D⍞000D    ↑{(⌹⍵)(gauss_jordan ⍵)}∘hil¨ 0 to 5⍞000D┌───────────────────────────────────┬───────────────────────────────────┐⍞000D│0                                  │0                                  │⍞000D├───────────────────────────────────┼───────────────────────────────────┤⍞000D│1                                  │1                                  │⍞000D├───────────────────────────────────┼───────────────────────────────────┤⍞000D│ 4 ¯6                              │ 4 ¯6                              │⍞000D│¯6 12                              │¯6 12                              │⍞000D├───────────────────────────────────┼───────────────────────────────────┤⍞000D│  9  ¯36   30                      │  9  ¯36   30                      │⍞000D│¯36  192 ¯180                      │¯36  192 ¯180                      │⍞000D│ 30 ¯180  180                      │ 30 ¯180  180                      │⍞000D├───────────────────────────────────┼───────────────────────────────────┤⍞000D│  16  ¯120   240  ¯140             │  16  ¯120   240  ¯140             │⍞000D│¯120  1200 ¯2700  1680             │¯120  1200 ¯2700  1680             │⍞000D│ 240 ¯2700  6480 ¯4200             │ 240 ¯2700  6480 ¯4200             │⍞000D│¯140  1680 ¯4200  2800             │¯140  1680 ¯4200  2800             │⍞000D├───────────────────────────────────┼───────────────────────────────────┤⍞000D│   25   ¯300    1050   ¯1400    630│   25   ¯300    1050   ¯1400    630│⍞000D│ ¯300   4800  ¯18900   26880 ¯12600│ ¯300   4800  ¯18900   26880 ¯12600│⍞000D│ 1050 ¯18900   79380 ¯117600  56700│ 1050 ¯18900   79380 ¯117600  56700│⍞000D│¯1400  26880 ¯117600  179200 ¯88200│¯1400  26880 ¯117600  179200 ¯88200│⍞000D│  630 ¯12600   56700  ¯88200  44100│  630 ¯12600   56700  ¯88200  44100│⍞000D└───────────────────────────────────┴───────────────────────────────────┘⍞000D⍞000D⍝ However, at hil 6, owing to error accumulation,⍞000D⍝ small differences begin to appear:⍞000D⍞000D    ⍪ {(⌹⍵)(gauss_jordan ⍵)}hil 6⍞000D┌────────────────────────────────────────────────────────────────────────────────────────────┐⍞000D│   36            ¯630.0000001     3360          ¯7560.000001     7560.000001    ¯2772.000001│⍞000D│ ¯630.0000001   14700           ¯88200.00001   211680         ¯220500           83160.00002 │⍞000D│ 3360          ¯88200.00001     564480.0001  ¯1411200         1512000         ¯582120.0001  │⍞000D│¯7560.000001   211680         ¯1411200        3628800.001    ¯3969000.001     1552320       │⍞000D│ 7560.000001  ¯220500          1512000       ¯3969000.001     4410000.001    ¯1746360       │⍞000D│¯2772.000001    83160.00002    ¯582120.0001   1552320        ¯1746360          698544.0001  │⍞000D├────────────────────────────────────────────────────────────────────────────────────────────┤⍞000D│   36           ¯630           3360          ¯7560     7560.000001    ¯2772                 │⍞000D│ ¯630          14700         ¯88200.00001   211680  ¯220500           83160.00001           │⍞000D│ 3360         ¯88200.00001   564480       ¯1411200  1512000         ¯582120                 │⍞000D│¯7560         211680       ¯1411200        3628800 ¯3969000         1552320                 │⍞000D│ 7560.000001 ¯220500        1512000       ¯3969000  4410000        ¯1746360                 │⍞000D│¯2772          83160.00001  ¯582120        1552320 ¯1746360          698544.0001            │⍞000D└────────────────────────────────────────────────────────────────────────────────────────────┘⍞000D⍞000DSee also: rats det Cholesky at⍞000D⍞000DIndex:Gauss-Jordan|Hilbert matrix|IEEE FP precision|pure function⍞000DIndex;Gauss C.F.|Jordan W.' 
