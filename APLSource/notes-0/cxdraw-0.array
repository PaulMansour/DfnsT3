'{mbrot←0}(cxfn ##.cxdraw) zoom              ⍝ Complex function drawing.⍞000D⍞000DA tool for visual exploration of complex function [cxfn]. For example:⍞000D⍞000D    *∘0.5 cxdraw 2      ⍝ explore complex square root.⍞000D⍞000DNB:  The  operand function is called with a single complex point as argument and⍞000Dmust return a <single> complex point as result; a multiple-valued function, such⍞000Das ''⍵+2 3'', won''t work.⍞000D⍞000DRight argument [zoom] determines the part of the complex plane that  is  visible⍞000Din the GUI window.  For example, ...cxdraw 8 shows a square of "radius" 8,  with⍞000Dcorners at ¯8j8 and 8j¯8. Real and imaginary axes and the unit circle are marked⍞000Don the plane.⍞000D⍞000DDrawing:⍞000D⍞000D    Mark:  Double-click to draw domain (blue) and range (red) markers.⍞000D    Draw:  Click and hold Left button to draw.⍞000D    Clear: Click Right button to clear.⍞000D    Quit:  Press <Esc> or close window to quit.⍞000D⍞000DAs  you  hold down the left mouse button and draw, the function''s domain path is⍞000Dtracked in blue and its corresponding range path is calculated and drawn in red.⍞000DIt is informative  to draw small circles crossing any branch cuts of the operand⍞000Dfunction.⍞000D⍞000DNotice that, while drawing, the GUI form''s caption displays the complex coordin-⍞000Dates of current domain and range.⍞000D⍞000DContinuity⍞000D----------⍞000DDomain  points that are close to,  but which straddle a branch cut, map to (red)⍞000Drange points that are typically far apart.  It is less distracting if the funct-⍞000Dion  refrains  from connecting range points on either side of such a discontinu-⍞000Dity.  An  example  might be the square-root function ⍵*÷2: as the domain crosses⍞000Dthe negative real axis, the range flips to its conjugate (mirror-image) point on⍞000Dthe other side of the real axis.⍞000D⍞000DWe  avoid this effect by looking at the _differential_ of the blue and red lines⍞000Dand  by  refusing to draw segments of the red line that correspond to a slope of⍞000Dmore than an arbitrary limit (say 100). We sample the slope at a number (100) of⍞000Dpoints along the blue and red lines.⍞000D⍞000DIdeally, we should compare the ratio of the _lengths_ of these "delta" sections:⍞000D⍞000D        length←{+⌿under(*∘2)2-/zg ⍵}    ⍝ length of line segment at ⍵.⍞000Dwhere:⍞000D        under←{⍵⍵⍣¯1 ⍺⍺ ⍵⍵ ⍵}           ⍝ aka "dual" see →pow←.⍞000D⍞000Dbut for this exercise, the distance around two sides of the bounding rectangle⍞000D⍞000D        +/|2-/[1]↑rng dom⍞000D⍞000Dis considerably quicker to calculate and is accurate enough.⍞000D⍞000D        ┌──────────∘z+∆z⍞000D        │        ./│|⍞000D        │      ./  │|⍞000D        │    ./ ←──│|─── real length of line segment [z, z+∆z].⍞000D        │  ./      │|⍞000D        │./        │|─┐⍞000D       z∘──────────┘/ │⍞000D         ¯¯¯¯¯¯¯¯¯¯¯  │⍞000D                  └───┴─ "good-enough" length of line segment [z, z+∆z].⍞000D⍞000DMandelbrot mode⍞000D---------------⍞000DIf optional left argument [mbrot], default 0, is set, only mouse  movements  are⍞000Ddetected and button clicks are ignored.  In this mode, for each MouseMove event,⍞000Dwe:⍞000D⍞000D    Set the value of ⍺ to the new position of the mouse cursor.⍞000D    Set temp variable z to 0.⍞000D    Apply expression (z←⍺ cxfn z) a large (10) number of times. Then,⍞000D    If z is still within the square ¯2J2..2J¯2⍞000D        draw a dot at ⍺; otherwise, don''t.⍞000D⍞000DUsing [cxfn] +∘(×⍨) reveals an approximation to the Mandelbrot  set:  by  moving⍞000Dthe mouse, shade the region around the unit circle as if  shading  with a pencil⍞000Don a piece of grease-spotted  paper.  In particular, by shading more thoroughly,⍞000Ddiscover the _boundary_ of the revealed figure.⍞000D⍞000D    http://en.wikipedia.org/wiki/Mandelbrot_set⍞000D⍞000DTechnical note: the above iteration is coded using the power operator ⍣:⍞000D⍞000D        to←,map⍣10⍨zg↑,↓y x                 ⍝ after 10 iterations.⍞000D⍞000Dwhere:⍞000D    y and x are the GUI window coordinates,⍞000D    zg translates these coordinates to complex number (z) and⍞000D    map⍣10 applies cxfn ten times.⍞000D⍞000DNotice that monadic commute ⍨ starts the iteration with z←⍺, rather than at z←0,⍞000Dbut, in the case of the mandelbrot expression, this just saves one iteration.⍞000D⍞000D(Perhaps  this technique might be extended to investigate the more general Julia⍞000D and Fatou sets http://en.wikipedia.org/wiki/Julia_set).⍞000D⍞000DTechnical note:⍞000D⍞000DNotice, with the function that maps a GUI coordinate to a complex number, rather⍞000Dthan using an easier-to-read dfn:⍞000D⍞000D    zg←(⍺÷100÷2 ¯2)∘{↑⍺×↓⊖⍉⍵-50}            ⍝ scale: complex from gui coords.⍞000D⍞000Dit is coded instead as a more obscure derived function:⍞000D⍞000D    zg←↑∘((⍺÷100÷2 ¯2)∘×)∘↓∘(-∘50)∘⊖∘⍉      ⍝ scale: complex from gui coords.⍞000D⍞000DThis is so that we can _generate_ zg''s inverse directly (as zg⍣¯1),  rather than⍞000Dhaving to  code a separate explicit inverse function.  In fact, it is convenient⍞000Dto supply an "under" operator, which applies its left operand _under_ the effect⍞000Dof its right operand.⍞000D⍞000D    under←{⍵⍵⍣¯1 ⍺⍺ ⍵⍵ ⍵}                   ⍝ aka "dual".⍞000D⍞000DThanks to Giangluigi Quario for help with the GUI.⍞000D⍞000DExamples:⍞000D⍞000D    + cxdraw 2          ⍝ complex conjugate (horizontal mirror-image).⍞000D⍞000D    *∘0.5 cxdraw 2      ⍝ complex square root (investigate branch cut).⍞000D⍞000D    8∘○ cxdraw 2        ⍝ Pythagorian function (investigate both branch cuts).⍞000D⍞000D    * cxdraw 8          ⍝ complex exponential (find 4 "fixpoints", where z≡*z).⍞000D⍞000D    *∘○ cxdraw 2        ⍝ see that *○0j1 → ¯1 (Euler).⍞000D⍞000D    {+/×⍨1 2○⍵}cxdraw 2 ⍝ sin-squared + cos-squared (watch form Caption).⍞000D⍞000D    0j1∘* cxdraw 2      ⍝ see that 0j1*0j1 is a real(!) number.⍞000D⍞000D    ÷ cxdraw 2          ⍝ complex reciprocal (maps until circle inside out).⍞000D⍞000D    +∘(×⍨)cxdraw 2      ⍝ mandelbrot mode: try shading in the region 2>|⍵.⍞000D⍞000DIndex:complex numbers|drawing|unit circle|fixpoint|Mandelbrot set|dual|under⍞000DIndex;Quario G.|Euler L.|Mandelbrot B.' 
