'                                                ⍝ Variations on primitive scan:⍞000D nvec ← {axis}      ##.mscan   nvec             ⍝ Minus scan.⍞000D nvec ← {axis}      ##.dscan   nvec             ⍝ Divide scan.⍞000D vect ←         (fn ##.ascan)  vect             ⍝ Associative vector scan.⍞000Darray ← {ascan} (fn ##.ascana) array            ⍝ Associative higher rank scan.⍞000D⍞000DProvided  by  Phil Last  and  Nicolas Delcros, these operators out-perform their⍞000Dprimitive counterparts by scanning cumulatively from left to right.⍞000D⍞000DThe primitive scan operator is defined as a vector of reductions:⍞000D    ¯¯¯¯¯¯¯¯¯⍞000D    ⍺⍺\⍵  →  ⍺⍺/¨(1 to ⍴⍵)↑¨⊂⍵⍞000D⍞000DFor example:⍞000D⍞000D    +\3 1 4 1 6⍞000D→   +/¨(1 to 5)↑¨⊂3 1 4 1 6⍞000D→   +/¨(3)(3 1)(3 1 4)(3 1 4 1)(3 1 4 1 6)⍞000D→   (+/3)(+/3 1)(+/3 1 4)(+/3 1 4 1)(+/3 1 4 1 6)⍞000D→   3 4 8 9 15⍞000D⍞000DDefn: An associative dyadic function f is one where: (A f B) f C ←→ A f (B f C).⍞000D         ¯¯¯¯¯¯¯¯¯¯¯⍞000DFor  associative operand functions, such as + and ×, the interpreter can "cheat"⍞000Dby  accumulating  the  result in a single left-to-right pass of the vector argu-⍞000Dment, but for non-associative functions, it is obliged to do it the slow way us-⍞000Ding reductions of increasingly longer sequences as above, resulting in an O(n×n)⍞000Dalgorithm.⍞000D⍞000DMscan  and dscan provide linear O(n) functions to simulate -\ and ÷\ respective-⍞000Dly.⍞000D⍞000D      -\⍳1000                       ⍝ slow primitive minus-scan.⍞000D1 ¯1 2 ¯2 3 ¯3 4 ¯4 5 ¯5 ...⍞000D⍞000D      mscan ⍳1000                   ⍝ quick minus-scan.⍞000D1 ¯1 2 ¯2 3 ¯3 4 ¯4 5 ¯5 ...⍞000D⍞000D⍞000D      ÷\⍳1000                       ⍝ slow primitive divide-scan.⍞000D1 0.5 1.5 0.375 1.875 0.3125 ...⍞000D⍞000D      dscan ⍳1000                   ⍝ quick divide-scan.⍞000D1 0.5 1.5 0.375 1.875 0.3125 ...⍞000D⍞000D⍞000DIn general, the interpreter can "cheat" only if it can determine that scan''s op-⍞000Derand function is associative. For example, even though dfn {⍺+⍵} is clearly as-⍞000Dsociative,  the interpreter cannot know this and so uses the slow O(n×n) method.⍞000D⍞000DIn cases such as these, where it is known that the operand function is associat-⍞000Dive, ascan can be used to force a left-to-right cumulative O(n) scan.⍞000D⍞000D      {⍺+⍵}\⍳10000                  ⍝ slow primitive scan.⍞000D1 3 6 10 15 21 28 36 45 55 ...⍞000D⍞000D      {⍺+⍵}ascan⍳1000               ⍝ quick associative scan.⍞000D1 3 6 10 15 21 28 36 45 55 ...⍞000D⍞000DNote  that  if  the operand turns out to be non-associative, ascan will return a⍞000Dresult that differs from primitive scan.⍞000D⍞000D      {⍺-⍵}\⍳10                     ⍝ slow primitive scan.⍞000D1 ¯1 2 ¯2 3 ¯3 4 ¯4 5 ¯5⍞000D⍞000D      {⍺-⍵}ascan⍳10                 ⍝ quick left to right accumulation.⍞000D1 ¯1 ¯4 ¯8 ¯13 ¯19 ¯26 ¯34 ¯43 ¯53⍞000D⍞000D    nums← ↑(''one'' ''two'' ''three'')(''un'' ''deux'' ''trois'')(''yan'' ''tan'' ''tethera'')⍞000D⍞000D    {⍺,''-'',⍵} ascan nums            ⍝ left-to-right scan along rows⍞000D┌───┬───────┬───────────────┐⍞000D│one│one-two│one-two-three  │⍞000D├───┼───────┼───────────────┤⍞000D│un │un-deux│un-deux-trois  │⍞000D├───┼───────┼───────────────┤⍞000D│yan│yan-tan│yan-tan-tethera│⍞000D└───┴───────┴───────────────┘⍞000D⍞000DSee also: acc⍞000D⍞000DIndex:scan operators⍞000DIndex;Last P.|Delcros N.' 
