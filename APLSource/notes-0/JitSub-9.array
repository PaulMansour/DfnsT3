'Fast BT division-by-2 using "Just-in-Time Subtraction" (LeRoy Eide)⍞000D-------------------------------------------------------------------⍞000DJohn Halleck  provides this description of LeRoy Eide''s very nifty algorithm for⍞000Dbalanced ternary division-by-2.  Notice that the algorithm is unusual in that it⍞000Dgenerates digits of the result from least- to most-significant (right-to-left).⍞000D⍞000D    This is based on work originally presented at the Utah Logic Group.⍞000D    See: http://web.utah.edu/utahlogic⍞000D⍞000DThe method is best illustrated using the more familar base-10 and division by 9.⍞000DLeRoy points out that q = (10×q)-9×q, so we could get q by subtracting our known⍞000D9×q from 10×q. Ah...  I hear you think...   we don''t happen to know 10×q either.⍞000DTrue, but we know something about it, namely that it ends in a zero ...⍞000D⍞000DFor  example,  suppose  we want to divide 1332 by 9 to find quotient q,  so that⍞000D1332 = 9×q. OK, let''s set this up:⍞000D⍞000D    10q =  .  .  .  0⍞000D    -9q =  1  3  3  2⍞000D    =================⍞000D      q =  .  .  .  .⍞000D⍞000DWe actually have enough information to compute the last column:⍞000D⍞000D                ¯1      ← borrow⍞000D    10q =  .  .  .  0⍞000D    -9q =  1  3  3  2⍞000D    =================⍞000D      q =  .  .  .  8⍞000D⍞000DBut  if  the last digit of q is 8, then the next to last digit of 10×q must also⍞000Dbe 8.⍞000D                ¯1⍞000D    10q =  .  .  8  0⍞000D    -9q =  1  3  3  2⍞000D    =================⍞000D      q =  .  .  .  8⍞000D⍞000DAnd we have enough information to compute the next digit of q (and therefore the⍞000Dnext digit of 10×q)⍞000D⍞000D    10q =  .  4  8  0⍞000D    -9q =  1  3  3  2⍞000D    =================⍞000D      q =  .  .  4  8⍞000D⍞000DAnd now we have enough to compute the next digit of q and 10×q:⍞000D⍞000D    10q =  1  4  8  0⍞000D    -9q =  1  3  3  2⍞000D    =================⍞000D      q =  .  1  4  8⍞000D⍞000DAnd we''re done!⍞000D⍞000D    10q =  1  4  8  0⍞000D    -9q =  1  3  3  2⍞000D    =================⍞000D      q =  0  1  4  8⍞000D⍞000DObservations⍞000D------------⍞000DThe method clearly extends to:⍞000D⍞000D1. Division by 99, 999, ... ¯1+10*⍵.⍞000D⍞000D2. Division by base+1 (rather than base-1)⍞000D⍞000D3. Number bases other than 10 (including balanced ternary).⍞000D⍞000DIn  the case of balanced ternary numbers, this gives us fast division by 2, 4, 8⍞000Dand 10 (among others).⍞000D⍞000D⍞000DBalanced Ternary Division by 2⍞000D------------------------------⍞000DHere is John''s worked example for balanced ternary numbers:⍞000D⍞000DSuppose we want BT: 1 1 0 (decimal 12) divided by 2.⍞000D⍞000DTo subtract a balanced ternary number, we just add its negation:⍞000D⍞000D    We have 2q =   1  1  0⍞000D       so  -2q =  ¯1 ¯1  0⍞000D⍞000DThen the steps are similar to the decimal example above:⍞000D⍞000D    3q =  .  .  .  .  0⍞000D + -2q =  0  0 ¯1 ¯1  0⍞000D    ===================⍞000D     q =  .  .  .  .  .⍞000D⍞000DWe  can fill in the rightmost digit of q, since this is an addition problem, and⍞000Dwe have both low order digits:⍞000D⍞000D    3q =  .  .  .  .  0⍞000D + -2q =  0  0 ¯1 ¯1  0⍞000D    ===================⍞000D     q =  .  .  .  .  0⍞000D⍞000DBut  now we know the low order digit of q, we therefore know the next to the low⍞000Dorder digit of 3q, since it is identical. (since 3q is q shifted left by one).⍞000D⍞000D    3q =  .  .  .  0  0⍞000D + -2q =  0  0 ¯1 ¯1  0⍞000D    ===================⍞000D     q =  .  .  .  .  0⍞000D⍞000DNow  the  second column is a straightforward addition problem (0 plus ¯1) and we⍞000Dcan  compute  the  second  digit (¯1) and fill that digit in for q, and the same⍞000Dknowledge in 3q:⍞000D⍞000D    3q =  .  . ¯1  0  0⍞000D + -2q =  0  0 ¯1 ¯1  0⍞000D    ===================⍞000D     q =  .  .  . ¯1  0⍞000D⍞000DAnd,  lo,  we  can now do the arithmetic to compute the next digit (with a carry⍞000Dthis time).⍞000D⍞000D            ¯1          ← carry⍞000D    3q =  .  1 ¯1  0  0⍞000D + -2q =  0  0 ¯1 ¯1  0⍞000D    ===================⍞000D     q =  .  .  1 ¯1  0⍞000D⍞000DAnd the next ...⍞000D⍞000D            ¯1⍞000D    3q =  .  1 ¯1  0  0⍞000D + -2q =  0  0 ¯1 ¯1  0⍞000D    ===================⍞000D     q =  .  0  1 ¯1  0⍞000D⍞000DAnd so on.⍞000D⍞000D    3q =  0  1 ¯1  0  0⍞000D + -2q =  0  0 ¯1 ¯1  0⍞000D    ===================⍞000D     q =  0  0  1 ¯1  0⍞000D⍞000DAnd we have our answer.⍞000D⍞000D⍞000DBut what if there''s a remainder?⍞000D--------------------------------⍞000DOn the face of it, the method seems to run into a problem if the dividend is not⍞000Dan exact multiple of the divisor. But we can fix it.⍞000D⍞000DThe  effect  is  that  the difference between (base-1) and the remainder is sub-⍞000Dtracted  from _each_ digit position,  so we can recover this as it falls off the⍞000Dleft side of the result and add it back, vector-wise, to each column.  Then, all⍞000Dthat remains to do is to normalise any columns that have overflowed (≥base).⍞000D⍞000DLeRoy points out that an alternative approach for balanced ternary division by 2⍞000Dis  to start by subtracting its parity (2|) from the dividend, rendering it even⍞000Dand thus divisible by 2 without remainder.⍞000D⍞000DThe <parity> of a BT number is:⍞000D    if the number has only a single digit (¯1 0 1), then its absolute value;⍞000D    otherwise, the <parity> of the (BT) sum of its digits.⍞000D⍞000DSee →bt← for more on this.⍞000D⍞000DCoding in D⍞000D-----------⍞000DHere  is a D-coding for decimal (base-10) fast division by 9 with remainder. The⍞000Dmethod  suggests a right-to-left reduction, which deduces a digit at a time into⍞000Dan accumulating argument: ↑scan/... If no remainder pops out of the left side of⍞000Dthe  reduction,  we''re  done: rem=0: ... Otherwise, we add the remainder to each⍞000Dcolumn (rem+rslt) and normalise (carry overflows forward) the result in a second⍞000Dreduction: ↑norm/...⍞000D⍞000DRemember  that  LeRoy''s  just-in-time subtraction method (conveniently) operates⍞000Dright-to-left, in contrast with traditional left-to-right division.⍞000D⍞000D    decimal_div_9←{                 ⍝ Fast decimal division-by-9 - LeRoy Eide.⍞000D⍞000D        scan←{(enc-⍺-+/2↑⍵),1↓⍵}    ⍝ pair-wise deduction of digits.⍞000D        nlz←{(-1⌈+/∨\0≠⍵)↑⍵}        ⍝ without superfluous leading zeros.⍞000D        enc←0 10∘⊤                  ⍝ 2-digit decimal encode.⍞000D⍞000D        rslt←1↓↑scan/0,⍵,0          ⍝ remainder, quotient.⍞000D        rem←9|9-1↑rslt              ⍝ remainder.⍞000D        rem=0:(nlz rslt)rem         ⍝ exact divide: quotient and 0-remainder.⍞000D⍞000D        norm←{(⍺ 0+enc ⍬⍴⍵),1↓⍵}    ⍝ pair-wise overflow resolution.⍞000D        rslt←1↓↑norm/0,rem+rslt     ⍝ vector-sum of rem with each digit.⍞000D        (nlz rslt)rem               ⍝ integer quotient and remainder.⍞000D    }⍞000D⍞000D    div9 1 2 3 4 5                  ⍝ 12345÷9 → 1371r6⍞000D┌───────┬─┐⍞000D│1 3 7 1│6│⍞000D└───────┴─┘⍞000D⍞000D(⍞000D    While  in keeping with its surroundings, the normalisation code is less than⍞000D    optimal.  Rather  than digit-by-digit reduction, it would be faster to use a⍞000D    parallel shift-carry function:⍞000D⍞000D        norm←{              ⍝ decimal digit overflow normalisation.⍞000D            10∧.>⍵:⍵        ⍝ all digits in range 0..9: done.⍞000D            ∇ +⌿1 0⌽0 10⊤⍵  ⍝ otherwise: shift-carry-add and try again.⍞000D        }⍞000D⍞000D    Note  that  from  Dyalog  V11, this could be coded using a fixpoint function⍞000D    derived from the power operator ⍣:⍞000D⍞000D        norm ← {+⌿1 0⌽0 10⊤⍵}⍣≡         ⍝ decimal digit vector normalisation.⍞000D    or:⍞000D        norm ← +⌿∘(1 0∘⌽)∘(0 10∘)⍣≡     ⍝ decimal digit vector normalisation.⍞000D)                                       ⍝ see →derive←⍞000D⍞000DBalanced Ternary⍞000D----------------⍞000DTo  change our decimal division-by-9 function to balanced ternary division-by-2,⍞000Dwe  need  change  only  the encode function (enc) and divisor (9). This suggests⍞000Dabstracting an operator, which takes these as left and right operands ⍺⍺ and ⍵⍵:⍞000D⍞000D    fast_div←{                      ⍝ Fast division by ⍵⍵ - LeRoy Eide.⍞000D⍞000D        scan←{(enc-⍺-+/2↑⍵),1↓⍵}    ⍝ pair-wise deduction of digits.⍞000D        nlz←{(-1⌈+/∨\0≠⍵)↑⍵}        ⍝ without superfluous leading zeros.⍞000D        enc←⍺⍺                      ⍝ 2-digit encode.⍞000D⍞000D        rslt←1↓↑scan/0,⍵,0          ⍝ remainder, quotient.⍞000D        rem←⍵⍵|⍵⍵-1↑rslt            ⍝ remainder.⍞000D        rem=0:(nlz rslt)rem         ⍝ exact divide: quotient and 0-remainder.⍞000D⍞000D        norm←{(⍺ 0+enc ⍬⍴⍵),1↓⍵}    ⍝ pair-wise overflow resolution.⍞000D        rslt←1↓↑norm/0,rem+rslt     ⍝ vector-sum of rem with each digit.⍞000D        (nlz rslt)rem               ⍝ integer quotient and remainder.⍞000D    }⍞000D⍞000DWe  are now in a position to derive functions for decimal_division_by_9 and bal-⍞000Danced_ternary_division_by 2:⍞000D⍞000D    enc_dec ← 0 10∘⊤                ⍝ 2-digit decimal encode.⍞000D    dec_div_9 ← enc_dec fast_div 9  ⍝ decimal divide-by-9.⍞000D                                    ⍝⍞000D    dec_div_9 1 2 3 4 5             ⍝ decimal 12345÷9 → 1371r6⍞000D┌───────┬─┐⍞000D│1 3 7 1│6│⍞000D└───────┴─┘⍞000D⍞000D    enc_bt ← {¯1+0 3⊤3⊥1+0 3⊤⍵}     ⍝ 2-digit balanced ternary encode.⍞000D    bt_div_2  ← enc_bt fast_div 2   ⍝ bt divide-by-2.⍞000D                                    ⍝                    __  _     _⍞000D    bt_div_2 1 0 ¯1 ¯1              ⍝ balanced ternary 1011÷11 → 111r1⍞000D┌──────┬─┐⍞000D│1 1 ¯1│1│⍞000D└──────┴─┘⍞000D⍞000DSee also: ratrep ratsum bt derive⍞000D⍞000DBack to Balanced Ternary Arithmetic: →bt←⍞000D⍞000DIndex:division by ¯1 1+base*⍵|division, fast|balanced ternary⍞000DIndex:Just-In-Time-Subtraction|subtraction, just-in-time⍞000DIndex:decimal normalisation|fixpoint⍞000DIndex;Eide L.N.|Halleck J.B.' 
