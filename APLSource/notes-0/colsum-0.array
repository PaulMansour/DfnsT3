'sumvec ← {base←10} ##.colsum cols           ⍝ Sum of (default decimal) columns.⍞000D⍞000DMorten Kromberg''s function adds columns of digits, resolving, in parallel, carr-⍞000Dies from column-sum overflows.⍞000D⍞000DLeft argument [base], default 10, determines in which number base the sum is to⍞000Dbe evaluated.⍞000D⍞000DFor example:⍞000D⍞000D    colsum ↑(0 0 1)(9 9 9)      ⍝ decimal sum: 1 + 999 → 1000⍞000D1 0 0 0⍞000D⍞000D    2 colsum ↑(0 0 1)(1 1 1)    ⍝ binary sum: 1 + 7 → 8⍞000D1 0 0 0⍞000D⍞000DTechnical notes:⍞000D⍞000D    colsum←{⍺←10                            ⍝ Sum of (default decimal) columns.⍞000D        ⍺{{(0=⍬⍴⍵)↓⍵}+⌿1 0⌽0,0 ⍺⊤⍵}⍣≡+⌿⍵    ⍝ repeat while overflow.⍞000D    }⍞000D⍞000D[colsum] uses power-limit (⍺⍺⍣≡) to ripple carry values along the sum until none⍞000Dremain:⍞000D⍞000D        ⍺{{(0=⍬⍴⍵)↓⍵}+⌿1 0⌽0,0 ⍺⊤⍵}⍣≡+⌿⍵⍞000D        │ ├─────────┘├┘├──┘├┘├──┘  ├┘└┴─ initial sum with overflow.⍞000D        │ │          │ │   │ │     └──── while carries remain.⍞000D        │ │          │ │   │ └────────── carry and ⍺-residue rows.⍞000D        │ │          │ │   └──────────── extra 0-col to hold overflow.⍞000D        │ │          │ └──────────────── carries shifted to next highest column.⍞000D        │ │          └────────────────── carries added into new sum vector.⍞000D        │ └───────────────────────────── surplus 0-col removed.⍞000D        └─────────────────────────────── number base (default decimal).⍞000D⍞000DWe can watch the carry-ripple working by injecting ⎕← into the code:⍞000D⍞000D        ⍺{{(0=⍬⍴⍵)↓⍵}⎕←+⌿1 0⌽0,0 ⍺⊤⍵}⍣≡+⌿⍵    ⍝ repeat while carries.⍞000D                     └┴────────────────────── display intermediate sum.⍞000Dthen:⍞000D        colsum ↑(9 1/0 1)(10/9)     ⍝ 1 + 9999999999 → 10000000000⍞000D    0 9 9 9 9 9 9 9 9 10 0⍞000D    0 9 9 9 9 9 9 9 10 0 0⍞000D    0 9 9 9 9 9 9 10 0 0 0⍞000D    0 9 9 9 9 9 10 0 0 0 0⍞000D    0 9 9 9 9 10 0 0 0 0 0⍞000D    0 9 9 9 10 0 0 0 0 0 0⍞000D    0 9 9 10 0 0 0 0 0 0 0⍞000D    0 9 10 0 0 0 0 0 0 0 0⍞000D    0 10 0 0 0 0 0 0 0 0 0⍞000D    1 0 0 0 0 0 0 0 0 0 0⍞000D    0 1 0 0 0 0 0 0 0 0 0 0⍞000D    1 0 0 0 0 0 0 0 0 0 0⍞000D⍞000DNotice  that  carries  ripple along the resulting sum vector "in parallel".  The⍞000Dfollowing sum overflows initially in the 5th and 10th columns;  then the 4th and⍞000D9th and so on.⍞000D⍞000D        colsum ↑(4 1 4 1/0 1 0 1)(10/9)     ⍝ 100001 + 9999999999 → 10000100000⍞000D    0 9 9 9 10 0 9 9 9 10 0⍞000D    0 9 9 10 0 0 9 9 10 0 0⍞000D    0 9 10 0 0 0 9 10 0 0 0⍞000D    0 10 0 0 0 0 10 0 0 0 0⍞000D    1 0 0 0 0 1 0 0 0 0 0⍞000D    0 1 0 0 0 0 1 0 0 0 0 0⍞000D    1 0 0 0 0 1 0 0 0 0 0⍞000D⍞000DExamples:⍞000D⍞000D    colsum ↑(9 9 9 9)(0 0 0 1)      ⍝ 9999 + 1 → 10000⍞000D1 0 0 0 0⍞000D⍞000D    4 5⍴⍳9                          ⍝ 5 columns of numbers.⍞000D1 2 3 4 5⍞000D6 7 8 9 1⍞000D2 3 4 5 6⍞000D7 8 9 1 2⍞000D⍞000D    colsum 4 5⍴⍳9                   ⍝ 5-column sum. Compare with:⍞000D1 8 2 6 0 4⍞000D⍞000D    +/12345 67891 23456 78912       ⍝ (for comparison with above).⍞000D182604⍞000D⍞000D    2 colsum ↑(1 1 1 1)(0 0 1 0)    ⍝ binary: 15 + 2 → 17⍞000D1 0 0 0 1⍞000D⍞000D    16 colsum ⍪, 1000               ⍝ decimal 1000 in hexadecimal.⍞000D3 14 8⍞000D⍞000DSee also: nats⍞000D⍞000DIndex:addition|sum|column sum|infinite precision⍞000DIndex;Kromberg M.' 
