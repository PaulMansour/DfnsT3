'C ← {trace←0} ##.scc G      ⍝ Strongly connected components of directed graph ⍵.⍞000D⍞000DArgument vector G is a graph (see →Graphs←).  Result C is a vector of  component⍞000Dnumbers, indicating which vertices share the same strongly connected components.⍞000D⍞000D[scc] uses Tarjan''s algorithm. See:⍞000Dhttp://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm⍞000D⍞000DIn short:  the algorithm performs a depth-first search of the graph, maintaining⍞000Da vector of the path between the starting (root) and current vertex. If a vertex⍞000Dis encountered that is already in the path,  this constitutes a cycle, the vert-⍞000Dices of which are thus strongly connected. The items of this cycle are marked as⍞000Dbelonging to the same component, and the process resumed until all vertices have⍞000Dbeen visited.⍞000D⍞000DThe  algorithm  is "linear", of order O(≢⍵,∊⍵):  the number of vertices plus the⍞000Dnumber of edges.⍞000D⍞000DHere are three representations of the same graph:  pictorial; schematic; and the⍞000Dnested vector, suitable as an argument, when ⎕IO=1, for [scc]:⍞000D⍞000D                                   1 → 2⍞000D    1------>2------>3<----->4      2 → 3 5 6     ┌→┬─────┬───┬───┬───┬─┬─┬───┐⍞000D    ∧      /|       |       ∧      3 → 4 7       │2│3 5 6│4 7│3 8│1 6│7│6│4 7│⍞000D    |    /  |       |       |      4 → 3 8       └→┴~───→┴~─→┴~─→┴~─→┴→┴→┴~─→┘⍞000D    |  /    |       |       |      5 → 1 6⍞000D    |└      ∨       ∨       ∨      6 → 7⍞000D    5------>6<----->7<------8      7 → 6⍞000D                                   8 → 4 7⍞000D⍞000DThe strongly connected components are vertices (1 2 5)(3 4 8)(6 7) as represent-⍞000Ded by the result: 1 1 2 2 1 3 3 2⍞000D⍞000D    1 2 3 4 5 6 7 8  ← vertex⍞000D    1 1 2 2 1 3 3 2  ← strongly connected component number⍞000D⍞000D[scc] is origin-independent, so that it can accept graphs in either origin.⍞000D⍞000DTechnical notes:⍞000D⍞000DTarjan''s algorithm is often presented in a procedural style, using an inner  and⍞000Douter loop to mutate the state of some global values or of properties associated⍞000Dwith each vertex of the subject graph.⍞000D⍞000DIn contrast, as an exercise in pure functional programming, function [scc] main-⍞000Dtains no state.  Comparing the code with that in the Wikipedia article, propert-⍞000Dies associated with vertices: "v.index" and "v.lowlink", together with the stack⍞000D"S" and a counter for the next index value "index", are hosted as  a  vector-of-⍞000Dvectors "5-tuple" T, which is passed between subfunctions. The remaining item of⍞000Dthis tuple: "C" is the accumulator for the result: a simple vector of the vertex⍞000Dindices of strongly connected components.⍞000D⍞000D    Tuple "fields"                                          Wikipedia equivalent⍞000D    --------------                                          --------------------⍞000D    C :: a vector of component group indices (the result)   (comment-only)⍞000D    L :: a vector of low-link values per vertex ·   ·   ·   v.lowlink.⍞000D    X :: vector of index number per vertex  ·   ·   ·   ·   v.index⍞000D    x :: scalar: next index number  ·   ·   ·   ·   ·   ·   index⍞000D    S :: stack of indices of unconnected vertices   ·   ·   S⍞000D⍞000DThe items of the 5-tuple vector are accessed with named indices: C L X x S, est-⍞000Dablished at initialisation time:⍞000D⍞000D    T ← ...             ⍝ initial value for tuple T ...⍞000D    C L X x S ← ⍳⍴T     ⍝ access names for T''s items.⍞000D⍞000DCoding in this way is significantly more complex than its procedural  equivalent⍞000D(purity comes at a price).  Extensive  use is made of local operator →at← which,⍞000Dgiven an argument T0, returns a successor tuple T1.  It is hoped that this oper-⍞000Dator  might  one  day become a language primitive (@), which should considerably⍞000Dimprove the performance and appearance of such code.⍞000D⍞000D    Wikipedia               [scc]⍞000D    ---------               -----⍞000D    S                       S⊃T0⍞000D    index := index + 1      T1←1+at x⊢T0⍞000D    v.lowlink := index      T2←v L∆ T1⍞000D                            where: L∆←x put L⍞000D                            where: put←{(⍺⍺⊃⍵)⊣at(⊂⍵⍵ ⍺)⊢⍵}⍞000D(muse:⍞000D⍞000D    The up-side of these contortions is that  function  [scc]  is  effectively a⍞000D    single expression, which makes it amenable to agressive  code-transformation⍞000D    techniques such as might be used by an internal code optimiser.⍞000D⍞000D    (muse:⍞000D        It would be interesting to speculate about language mechanisms to assist⍞000D        with this technique of replacing the modification of global  state  with⍞000D        passing everything around as argument and result tuples.  The goal would⍞000D        be to make it pleasant to denote a successor  tuple  in  which  specfied⍞000D        items and their numerically indexed  elements differ  from  the argument⍞000D        tuple.  It is JMS''s guess that this is the motivation behind "monads" in⍞000D        Haskell (but he''s been wrong before).⍞000D⍞000D        Passing namespace "refs" with dottable field names doesn''t help  because⍞000D        the name assignement in this case is procedural and so can not easily be⍞000D        embedded in a larger expression.  We would have to resort  to  something⍞000D        like:⍞000D⍞000D            T1 ← T0.{⎕this⊣X[⍵]←x}v⍞000D⍞000D        which doesn''t seem any more friendly than:⍞000D⍞000D            T1 ← (x⊃T0)⊣@(⊂X v)⊢T0⍞000D    )⍞000D⍞000D    Notice that, where a procedural treatment would tend to use a statement sep-⍞000D    arator, this more functional approach uses ⊢ to compose transformations:⍞000D⍞000D        ... ⋄ I+←1 ⋄ J⌊←k ⋄ S,⍨←v ⋄ ...     ⍝ procedural⍞000D        ... ⊢ 1+@I ⊢ k⌊@J ⊢ v,¨@S ⊢ ...     ⍝ functional⍞000D)⍞000D⍞000DRequires: →dsp← for optional tracing.⍞000D⍞000DAn alternative coding⍞000D---------------------⍞000DNick Nikolov provides this alternative one-liner, which uses the transitive⍞000Dclosure of the adjacency matrix (see →Graphs←).⍞000D⍞000D    scc←{(∪⍳⊢)↓∧∘⍉⍨∨.∧⍨⍣≡i∘.∊⍵,¨i←⍳≢⍵}⍞000D    ⍝    ·     ·   ·     ·   ·  i←⍳≢⍵   vertex indices⍞000D    ⍝    ·     ·   ·     ·   ⍵,¨i   ·   consider each vertex a SCC by itself⍞000D    ⍝    ·     ·   ·     i∘.∊   ·   ·   neighbour lists to adjacency matrix⍞000D    ⍝    ·     ·   ∨.∧⍨⍣≡   ·   ·   ·   transitive closure: g[x;y] ←→ path x → y⍞000D    ⍝    ·     ∧∘⍉⍨ ·   ·   ·   ·   ·   ... and from y to x⍞000D    ⍝    (∪⍳⊢)↓ ·   ·   ·   ·   ·   ·   renumbering of component numbers⍞000D⍞000DThe version is very good for small graphs but its space and time requirements⍞000Dgrow rapidly as the size increases.⍞000D⍞000DCondensation⍞000D------------⍞000DContracting  each  strongly  connected  component  into a single vertex yields a⍞000Ddirected acyclic graph (DAG), the "condensation of G".  The  following  function⍞000Dreturns a 2-vector pair:  the condensation graph,  together with a corresponding⍞000Dvector of condensed vertices from the original graph.⍞000D⍞000D    con←{               ⍝ Condensation of graph ⍵.⍞000D        c←scc ⍵         ⍝ strongly connected components⍞000D        v←{⊂⍵}⌸ c       ⍝ component-grouped vertex indices⍞000D        e←c{⊂⍵}⌸ ⍵      ⍝   ..      ..      edges⍞000D        x←∪¨(∊¨e)~¨v    ⍝ out-of-component edges⍞000D        m←↓∨/¨x∘.∊v     ⍝ masks of remote vertices⍞000D        g←m/¨⊂⍳⍴v       ⍝ condensed DAG⍞000D        g v             ⍝ ... and contracted vertices⍞000D    }⍞000D⍞000DExamples:⍞000D⍞000D⍝   1------>2------>3<------>4          ⍝ Wikipedia⍞000D⍝   ∧      /|       |        ∧⍞000D⍝   |    /  |       |        |⍞000D⍝   |  /    |       |        |⍞000D⍝   |└      ∨       ∨        ∨⍞000D⍝   5------>6<----->7<-------8⍞000D⍞000D    ⊢ g ← 2(3 5 6)(4 7)(3 8)(1 6)7 6(4 7)   ⍝ directed (origin-1) graph.⍞000D┌─┬─────┬───┬───┬───┬─┬─┬───┐⍞000D│2│3 5 6│4 7│3 8│1 6│7│6│4 7│⍞000D└─┴─────┴───┴───┴───┴─┴─┴───┘⍞000D    scc g                               ⍝ strongly connected components.⍞000D1 1 2 2 1 3 3 2⍞000D                                        ⍝ Using function [con] from above:⍞000D    con g                               ⍝ condensation and contracted vertices.⍞000D┌────────┬─────────────────┐⍞000D│┌───┬─┬┐│┌─────┬─────┬───┐│⍞000D││2 3│3││││1 2 5│3 4 8│6 7││⍞000D│└───┴─┴┘│└─────┴─────┴───┘│⍞000D└────────┴─────────────────┘⍞000D⍞000D    isdag ← scc ≡ ⍳∘≢                   ⍝ is-a-DAG (contains no cycles)⍞000D    isdag g                             ⍝ g contains at least one cycle⍞000D0⍞000D    isdag (⍳10),⊂⍬                      ⍝ graph is acyclic⍞000D1⍞000D⍞000D⍝   1<------2<------3<------>4          ⍝ Wikipedia⍞000D⍝   |      ┐∧       ∧        ∧⍞000D⍝   |    /  |       |        |⍞000D⍝   |  /    |       |        |⍞000D⍝   ∨/      |       |        |⍞000D⍝   5<------6<----->7<-------8<--.⍞000D⍝                            ''---''⍞000D⍞000D    ⊢ w ← 5 1(2 4)3 2(2 5 7)(3 6)(4 7 8)⍞000D┌─┬─┬───┬─┬─┬─────┬───┬─────┐⍞000D│5│1│2 4│3│2│2 5 7│3 6│4 7 8│⍞000D└─┴─┴───┴─┴─┴─────┴───┴─────┘⍞000D    scc w⍞000D1 1 2 2 1 3 3 4⍞000D⍞000D    con w                               ⍝ condensation and contracted vertices.⍞000D┌────────────┬─────────────────┐⍞000D│┌┬─┬───┬───┐│┌─────┬───┬───┬─┐│⍞000D│││1│1 2│2 3│││1 2 5│3 4│6 7│8││⍞000D│└┴─┴───┴───┘│└─────┴───┴───┴─┘│⍞000D└────────────┴─────────────────┘⍞000D⍞000D    ⍝ in the following trace, notice that the stack grows to the left:⍞000D⍞000D    1 scc w                             ⍝ left arg is trace option⍞000D1│0 0 0 0 0 0 0 0│0 0 0 0 0 0 0 0│0 0 0 0 0 0 0 0│1│⍞000D5│0 0 0 0 0 0 0 0│1 0 0 0 0 0 0 0│1 0 0 0 0 0 0 0│2│1⍞000D2│0 0 0 0 0 0 0 0│1 0 0 0 2 0 0 0│1 0 0 0 2 0 0 0│3│5 1⍞000D3│1 1 0 0 1 0 0 0│1 1 0 0 1 0 0 0│1 3 0 0 2 0 0 0│4│⍞000D4│1 1 0 0 1 0 0 0│1 1 4 0 1 0 0 0│1 3 4 0 2 0 0 0│5│3⍞000D6│1 1 2 2 1 0 0 0│1 1 4 4 1 0 0 0│1 3 4 5 2 0 0 0│6│⍞000D7│1 1 2 2 1 0 0 0│1 1 4 4 1 6 0 0│1 3 4 5 2 6 0 0│7│6⍞000D8│1 1 2 2 1 3 3 0│1 1 4 4 1 6 6 0│1 3 4 5 2 6 7 0│8│⍞000D1 1 2 2 1 3 3 4⍞000D⍞000DSee also: Graphs at dsp⍞000D⍞000DIndex:Strongly connected components|graph|depth-first search|DAG⍞000DIndex:transitive closure|monad|tuple⍞000DIndex;Tarjan R.|Nikolov N.' 
