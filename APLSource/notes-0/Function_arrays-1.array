'───────────────⍞000DFunction Arrays⍞000D───────────────⍞000DDyalog APL doesn''t have arrays of functions but they can be simulated in various⍞000Dways. Apart from →fnarray←, each of the operators here utilises a derived funct-⍞000Dion "tree". The seemingly "linear" sequence ··· F op G op H ··· arg, can be rep-⍞000Dresented graphically in the following fashion:⍞000D⍞000D           ┌─··· arg⍞000D         ┌─op─┐⍞000D       ┌─op─┐ H⍞000D     ┌─op─┐ G⍞000D    ···   F⍞000D⍞000DThe  function array operators typically traverse the left "spine" of the tree by⍞000Dapplying ⍺⍺ to an argument until the required operand is reached.⍞000D⍞000D→fnarray← uses an array of namespace references to contain each function.⍞000D⍞000D------------------⍞000DFunction selectors⍞000D------------------⍞000DOperators →case← and →of← apply the selected monadic function to the right argu-⍞000Dment  of  the  derived function. →case← uses a boolean "mask" and →of←, a "pick"⍞000Dindex.  There  is a subtle but significant difference in the usage of →case← and⍞000D→of←:⍞000D⍞000D    0 1 0 - case ! case + 3     ⍝ [larg] fn case fn case fn rarg⍞000D6⍞000D    2 of - of ! of + 3          ⍝ [land] of fn of fn of fn rarg⍞000D6⍞000D⍞000D[larg]  is  the  left  _argument_ of the derived function: (fn case fn case fn),⍞000Dwhereas [land] is the left _operand_ of the leftmost →of← operator.⍞000D⍞000DIn  Dyalog,  we  can  _name_ a derived function such as (fn case fn case fn) and⍞000Dwith  this example, sometime later use the name in conjunction with a left argu-⍞000Dment  to  "pick" a function to apply to a right argument. However, we can''t name⍞000Dan  incomplete  operator expression (of fn of fn of fn) which has a missing left⍞000Doperand.⍞000D⍞000DOperationally,  →case←  can "see" its left argument from the top (righmost) node⍞000Dof  the  derived  function tree and pass an optionally modified copy of it left-⍞000Dwards  to each lower level. An →of←-tree on the other hand, has no left argument⍞000Dand must traverse left until it happens upon an operand that isn''t a function.⍞000D⍞000DPhil  Last suggests a further operator [sel], which indexes _leftwards_ from the⍞000Drightmost operand function:⍞000D⍞000D      sel←{               ⍝ select function from RHS of list.⍞000D          ⍺≤⎕IO:⍵⍵ ⍵      ⍝ apply ⍵⍵ at selected level.⍞000D          (⍺-1)⍺⍺ ⍵       ⍝ traverse left.⍞000D      }⍞000D⍞000DThis combines →of←''s simplicity in that a pick index is used, with the advantage⍞000Dof →case←, that the derived function may be named. But here''s the rub: the left-⍞000Dmost  operand  function must accept but ignore, a left argument. This is because⍞000Dthe  operator  doesn''t know it _is_ the leftmost function and so passes the next⍞000Dlowest  index  as  left  argument. This is not really a problem as an ambivalent⍞000Dfunction may easily be made strictly monadic by composing or enclosing it with a⍞000Dmonadic identity function: ⊢∘fn or {fn ⍵}.⍞000D⍞000D      fnlist←{⌈⍵} sel ⌊ sel - sel ÷     ⍝ ''vector'' of functions,⍞000D⍞000D      ⎕nc''fnlist''                       ⍝ ... is a derived function.⍞000D3⍞000D      1 fnlist 2.5                      ⍝ 1st from right function.⍞000D0.4⍞000D      4 fnlist 2.5                      ⍝ 4th from right function.⍞000D3⍞000D⍞000D---------------------⍞000DFunction distributors⍞000D---------------------⍞000DOperators  →lof←  (list-of-functions) and →vof← (vector-of-functions) distribute⍞000Dtheir  functions  over or between their array arguments. The distinction between⍞000D→lof←  and  →vof←  is  that in the former, each function is applied to the whole⍞000Dargument array, whereas in the latter, the items of the argument are distributed⍞000Dto each function.⍞000D⍞000Dmonadic:⍞000D⍞000D    F lof G x y ←→ (F x y) (G x y)⍞000D    F vof G x y ←→ (F x  ) (G   y)⍞000D⍞000Ddyadic:⍞000D⍞000D    a b F lof G x y   ←→ (a b F x y) (a b G x y)⍞000D    a b F vof G x y   ←→ (a   F x  ) (  b G   y)⍞000D⍞000DExamples:⍞000D⍞000D      1 5 3 + lof ⌈ lof ⌊ lof | 6 2 4⍞000D7 7 7  6 5 4  1 2 3  0 2 1⍞000D⍞000D      1 5 3 + vof ⌈ vof ⌊ vof | 6 2 4⍞000D6 2 1⍞000D⍞000D      - lof ÷ lof ! 4 5 6⍞000D¯4 ¯5 ¯6  0.25 0.2 0.1666666667  24 120 720⍞000D⍞000D      - vof ÷ vof ! 4 5 6⍞000D¯4 0.2 720⍞000D⍞000DSee also: case of lof vof for fnarray⍞000D⍞000DIndex:function array⍞000DIndex;Last P.' 
