'{tape} ← {tape} ##.bf toks                  ⍝ Brainfuck.⍞000D⍞000DThe startling term "Brainfuck", henceforth "BF" in the interests of brevity (and⍞000Ddelicacy), denotes  both a theoretical machine and its order-code or programming⍞000Dlanguage.  The  machine  is  an exercise in minimalism in that it has only eight⍞000Dinstructions, none of which takes an explicit operand.⍞000D⍞000DDespite its simplicity,  BF is "Turing-complete", which means that, given enough⍞000Dtime and memory,  it may be programmed  to solve any problem that a regular com-⍞000Dputer can tackle. See: http://www.iwriteiam.nl/Ha_bf_Turing.html⍞000D⍞000DFor a full description of the language, together with some programming examples,⍞000Dsee: http://en.wikipedia.org/wiki/Brainfuck⍞000D⍞000DMachine architecture⍞000D--------------------⍞000DThe machine has just two "moving parts":⍞000D⍞000D-   An instruction token stream, the character vector argument to the function.⍞000D⍞000D        ┌───┬───┬───┬───┬───┬───┬───┬───┬──⍞000D        │ > │ [ │ - │ < │ + │ > │ ] │ < │    ∘∘∘⍞000D        └───┴───┴───┴───┴───┴───┴───┴───┴─⍞000D⍞000D-   An infinite "tape" of cells, each of which holds a single numeric value.⍞000D⍞000D        ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬──⍞000D        │ 1 │ 3 │ 4 │ 48│ 49│ 0 │ 1 │ 2 │ 5 │ 0  ∘∘∘⍞000D        └───┴───┴───┴───┴───┴───┴───┴───┴───┴──⍞000D⍞000DThe tape and token stream are manipulated using the eight machine instructions:⍞000D⍞000D    >    Move tape pointer one cell position to right.⍞000D    <    Move tape pointer one cell position to left.⍞000D⍞000D    +    Increment value in current tape cell.⍞000D    -    Decrement value in current tape cell.⍞000D⍞000D    .    Output character corresponding to value in current tape cell.⍞000D    ,    Set value in current tape cell to ⎕UCS value of an input char.⍞000D⍞000D    [    If current cell value = 0, jump to right of matching ] in token stream.⍞000D    ]    If current cell value ≠ 0, jump to right of matching [ in token stream.⍞000D⍞000DThe final two instructions, [ and ], provide a "while loop".⍞000D⍞000DAny characters other than the above eight "<>+-.,[]" are ignored and may be used⍞000Das program commentary (see example below).⍞000D⍞000DProgramming⍞000D-----------⍞000DThe  following  vector  (with  embedded newlines) is an example of a BF program,⍞000Dwhich outputs the string ''Hello World'':⍞000D⍞000D          display hello⍞000D    ┌→───────────────────────────────────────────────┐⍞000D    │addr:val shows current cell address and value   │⍞000D    │                                                │⍞000D    │+++++ +++++ [           0:10 × loop:            │⍞000D    │    > +++++ ++          1:10×7 for H W          │⍞000D    │    > ++                2:10×2 for e l l o r l d│⍞000D    │    << -                0: decr loop counter    │⍞000D    │]                       0:0                     │⍞000D    │>++ .                   1:72 → H                │⍞000D    │>+.                     2:21 → e                │⍞000D    │+++++ ++ ..             2:28 → l l              │⍞000D    │+++ .                   2:31 → o                │⍞000D    │<<++++ .                0:4  →  sp              │⍞000D    │>+++++ +++++ +++++ .    1:87 → W                │⍞000D    │> .                     2:31 → o                │⍞000D    │+++ .                   2:34 → r                │⍞000D    │--- --- .               2:28 → l                │⍞000D    │--- --- --.             2:20 → d                │⍞000D    │<<-.                    0:3  →  nl              │⍞000D    └────────────────────────────────────────────────┘⍞000D⍞000DTake care,  when commenting such programs, to avoid using any of the instruction⍞000Dcharacters: "<>+-.,[]".⍞000D⍞000DUsing the tape⍞000D--------------⍞000DThe  final state of the tape is returned as a shy result of the function and may⍞000Dbe  re-loaded  as  optional left argument to a subsequent BF session. This means⍞000Dthat  we can use the state of the tape for simple calculations without having to⍞000Dconvert  between  characters  ''1'' ''2'' ''3'' ... and numbers 1 2 3 .. for input and⍞000Doutput.⍞000D⍞000D        ⎕←123 45 bf ''[->+<]''    ⍝ 123 + 45 → 168⍞000D    0 168⍞000D⍞000DTracing⍞000D-------⍞000DWe  can  watch  the progress of the machine by removing the leading ''⍝'' from the⍞000Dfirst line of inner fuction "machine":⍞000D⍞000D    machine←{                       ⍝ machine definition: ⍺:tape ⍵:toks.⍞000D        t←get ⍵                     ⍝ next token.⍞000D    ⍝   ⎕←t,↑'' ()'',.,⍕∘∊¨⍺          ⍝ uncomment to trace.⍞000D    │   ...       └─┴───────────────  "mesh" (Nicolas Delcros).⍞000D    └───────────────────────────────  remove ''⍝'' to watch trace.⍞000D⍞000DWith  tracing  enabled, the next token and memory tape (⍺) are displayed at each⍞000Dstep with the current tape cell in parentheses:⍞000D⍞000D    +bf''>++[<+++>-]<''               ⍝ 2 × 3⍞000D> 0(0)0⍞000D+ 0 0(0)0⍞000D+ 0 0(1)0⍞000D[ 0 0(2)0⍞000D< 0 0(2)0⍞000D+ 0(0)2 0⍞000D+ 0(1)2 0⍞000D+ 0(2)2 0⍞000D> 0(3)2 0⍞000D- 0 3(2)0⍞000D] 0 3(1)0⍞000D< 0 3(1)0⍞000D+ 0(3)1 0⍞000D+ 0(4)1 0⍞000D+ 0(5)1 0⍞000D> 0(6)1 0⍞000D- 0 6(1)0⍞000D] 0 6(0)0⍞000D< 0 6(0)0⍞000D∘ 0(6)0 0⍞000D6 0⍞000D⍞000DTuring''s Tape⍞000D-------------⍞000DBF''s memory is a tape of cells,  which extends to infinity in the ">" direction.⍞000DAt any time,  exactly one cell is  under the machine''s read-head.  Order codes <⍞000Dand > shift the tape to make current the next cell to the left or right.⍞000D⍞000D                                ┌──────────────┐⍞000D                        ┌───────│              │───────┐⍞000D                  ┌─────│ next  │  "current"   │ next  │─────┐⍞000D              ┌───│ nxt │ cell  │    cell      │ cell  │ nxt │───┐⍞000D -○○ ···∘∘∘⎕⎕⎕│ < │ lft │ left  │  referenced  │ right │ rgt │ > │⎕⎕⎕∘∘∘··· +○○⍞000D              └───│  <  │   <   │  by <>[]+-., │  >    │  >  │───┘⍞000D                  └─────│       │ instructions │       │─────┘⍞000D                        └───────│              │───────┘⍞000D                                └──────────────┘⍞000D⍞000DThis infinite tape mechanism is borrowed from Alan Turing''s theoretical machine.⍞000DSee: http://en.wikipedia.org/wiki/Turing_machine⍞000D⍞000DTechnical notes:⍞000D⍞000DBoth  tape  and token stream are pleasingly implemented in Dyalog as a recursive⍞000Ddata structure,  which is a pair of "snoc" and "cons" →list←s,  separated by the⍞000Dcurrent cell. The tape is accessed using structure assignment:⍞000D⍞000D    get←{_ m _←⍵ ⋄ m}                   ⍝ current item.⍞000D    put←{l _ r←⍵ ⋄ l ⍺ r}               ⍝ ⍺ replaces current item.⍞000D⍞000D    lft←{(ll l)m r←⍵ ⋄ ll l(m r)}       ⍝ tape pointer left.⍞000D    rgt←{l m(r rr)←⍵ ⋄ (l m)r rr}       ⍝ tape pointer right.⍞000D⍞000DNote how Dyalog''s "scalar extension" mechanism automatically extends the tape in⍞000Deither direction, as required:⍞000D⍞000D    tape←0 99 0                         ⍝ initial 3-cell tape.⍞000D⍞000D    tape ← lft lft tape ⋄ disp tape     ⍝ move two cells left, extending tape.⍞000D┌─┬─┬────────┐⍞000D│0│0│┌─┬────┐│⍞000D│ │ ││0│99 0││⍞000D│ │ │└─┴────┘│⍞000D└─┴─┴────────┘⍞000D⍞000D    tape ← rgt rgt tape ⋄ disp tape     ⍝ move two cells right again.⍞000D┌───────┬──┬─┐⍞000D│┌───┬─┐│99│0│⍞000D││0 0│0││  │ │⍞000D│└───┴─┘│  │ │⍞000D└───────┴──┴─┘⍞000D⍞000D    tape ← rgt rgt tape ⋄ disp tape     ⍝ move two cells right, extending tape.⍞000D┌────────────────┬─┬─┐⍞000D│┌────────────┬─┐│0│0│⍞000D││┌───────┬──┐│0││ │ │⍞000D│││┌───┬─┐│99││ ││ │ │⍞000D││││0 0│0││  ││ ││ │ │⍞000D│││└───┴─┘│  ││ ││ │ │⍞000D││└───────┴──┘│ ││ │ │⍞000D│└────────────┴─┘│ │ │⍞000D└────────────────┴─┴─┘⍞000D⍞000D    tape←lft lft tape ⋄ disp tape       ⍝ move two cells left again to home.⍞000D┌───────┬──┬───────┐⍞000D│┌───┬─┐│99│┌─┬───┐│⍞000D││0 0│0││  ││0│0 0││⍞000D│└───┴─┘│  │└─┴───┘│⍞000D└───────┴──┴───────┘⍞000D⍞000DFurther,  to increment (decrement) the current cell, we need only add (subtract)⍞000Dthe triple 0 1 0.⍞000D⍞000D    inc←+∘0 1 0                         ⍝ + increment current tape cell.⍞000D    dec←-∘0 1 0                         ⍝ - decrement current tape cell.⍞000D⍞000DHowever, this operation takes significantly more time as the memory tape becomes⍞000Dextended.  This  is  because the interpreter must add 0 to both (nested) ends of⍞000Dthe memory tape. It could be argued that the interpreter should special-case 0+⍵⍞000Das a no-op  but it would probably still need to traverse a nested array so that,⍞000Dfor example, 0+((((5)4)3)2)1(2(3(4(5''?''))))  would continue to generate a DOMAIN⍞000DERROR.⍞000D⍞000DA less elegant but O(1) increment would be:⍞000D⍞000D    inc←{l m r←⍵ ⋄ l(m+1)r}             ⍝ increment of current tape cell.⍞000D⍞000DThe only challenging part of the code is in inner operator [skip], which search-⍞000Des the token stream, left or right,  to find a matching bracket for [ or ].  The⍞000Dcode is complicated by having to navigate nested pairs of brackets,  which means⍞000Dthat  inner matching [...] pairs must be skipped over during the search.  [skip]⍞000Dachieves this with a signature double recursion, characteristic of bracket proc-⍞000Dessing in list implementations.  See the line with the exdented comment:⍞000D⍞000D    skip←{                                  ⍝ search ⍺⍺-wise for [] match in ⍵.⍞000D        fm to←{⍵,''[]''~⍵}get ⍵               ⍝ current and target brackets.⍞000D        ⍺⍺{                                 ⍝ ⍺⍺ is lft or rgt.⍞000D            tok←get ⍵                       ⍝ current token.⍞000D            tok≡to:⍵                        ⍝ found match: done.⍞000D            tok≡fm:∇ ⍺⍺ ∇ ⍺⍺ ⍵          ⍝ inner loop: skip over it.⍞000D            tok≡''∘'':⍵                       ⍝ run off end: quit.⍞000D            ∇ ⍺⍺ ⍵                          ⍝ skip lft or rgt to next token.⍞000D        }⍺⍺ ⍵                               ⍝ skipping over starting bracket.⍞000D    }⍞000D⍞000D(muse:⍞000D⍞000D    In this code,  [skip],  bound to its operand function [rgt] or [lft], is al-⍞000D    ways applied by the conditional application operator if←{(⍺⍺⍣⍵)⍺}.⍞000D⍞000D        ... ⍵ rgt skip if 0=get⍞000D        ... ⍵ lft skip if 0≠get⍞000D⍞000D    If Dyalog were to implement →hyperators←,  then (skip if)  could be bound at⍞000D    definition time:⍞000D⍞000D        skip_if←{                       ⍝ search ⍺⍺-wise for [] match in ⍵.⍞000D            fm to←{⍵,''[]''~⍵}get ⍵       ⍝ current and target brackets.⍞000D            ⍺⍺{                         ⍝ ⍺⍺ is lft or rgt.⍞000D                tok←get ⍵               ⍝ current token.⍞000D                tok≡to:⍵                ⍝ found match: done.⍞000D                tok≡fm:∇ ⍺⍺ ∇ ⍺⍺ ⍵      ⍝ inner loop: skip over it.⍞000D                tok≡''∘'':⍵               ⍝ run off end: quit.⍞000D                ∇ ⍺⍺ ⍵                  ⍝ skip lft or rgt to next token.⍞000D            }⍺⍺ ⍵                       ⍝ skipping over starting bracket.⍞000D        }{(⍺⍺ ⍺⍺⍺⍣⍵)⍺}                  ⍝ conditional →hyperator←.⍞000D)⍞000D⍞000DRefs:⍞000D[1] http://en.wikipedia.org/wiki/Brainfuck        Brainfuck full description.⍞000D[2] http://en.wikipedia.org/wiki/Turing_machine   Turing machine.⍞000D[3] http://esolangs.org/wiki/Brainfuck            More on brainfuck.⍞000D[4] http://www.iwriteiam.nl/Ha_bf_Turing.html     Bf is turing-complete.⍞000D[5] http://esolangs.org                           More esoteric languages.⍞000D[6] min.dws max.dws                               Home-brewed minimal languages.⍞000D⍞000DNote,  when searching the Internet that, owing to its second  syllable''s being a⍞000Dtaboo word in English,  "brainfuck"  is  often  written as brainf***, brainf*ck,⍞000Dbrainfsck, BF or even b****fuck!⍞000D⍞000DThe language was designed to be extremely simple to implement.  For  example, it⍞000Dmay be expressed in only:⍞000D⍞000D- 21 lines of the minuscule functional language: max.dws/lib.bf⍞000D- 18 reduction rules in term-rewrite system: eval.dws/bfck⍞000D⍞000DThanks to Nicolas Delcros and Jason Rivers for sowing the seed.⍞000D⍞000DExamples:⍞000D⍞000D    bf''++++++++++[>+++++++>++<<-]>++.>+.+++++++..+++.<<++++.>+++++++++++++++.>.+++.------.--------.<<-.''⍞000DHello World⍞000D⍞000D⍝ The following program inputs two single-digit numbers and ouputs their sum:⍞000D⍞000D    display add         ⍝ sum of two single digit numbers.⍞000D┌→────────────────────────────────────────────────┐⍞000D│ output sum of two ASCII digits                  │⍞000D│ "⍺" plus "⍵" → "⍺" ┼ "⍵" ─ "0" where "0" = 48   │⍞000D│                                                 │⍞000D│ ,                   0: 1st digit ''0'' plus ⍺     │⍞000D│ > +++++ + [         1:6 × loop:                 │⍞000D│     < ----- ---     0: sub 6×8: ''0'' plus ⍺ → ⍺  │⍞000D│     >-              1: decr loop counter        │⍞000D│ ]                   1:0                         │⍞000D│ ,                   1: 2nd digit ''0'' plus ⍵     │⍞000D│ <[                  0:⍺ × loop                  │⍞000D│     >+              1: incr ⍵                   │⍞000D│     <-              0: decr ⍺                   │⍞000D│ ]                   0:0                         │⍞000D│ >.                  0: output ⍺ plus ''0'' plus ⍵ │⍞000D└─────────────────────────────────────────────────┘⍞000D⍞000D    bf add                  ⍝ input 3, 4; output 7.⍞000D3⍞000D4⍞000D7⍞000D    +5 8 bf ''[>+<-]''        ⍝ simple in-memory adder  5 + 8 → 13.⍞000D0 13⍞000D⍞000D    1e6 bf time ''[-]''       ⍝ 1 million loops takes just over 2 minutes.⍞000D02:07.28⍞000D⍞000D⍝ Code snippets may be concatenated into larger programs:⍞000D⍞000D    din ← '',>++++++++[<------>-]<''      ⍝ single-digit input.⍞000D    dot ← ''>++++++++[<++++++>-]<.''      ⍝ single-digit output.⍞000D    clr ← ''[-]''                         ⍝ cell clear: m → 0⍞000D    ff  ← ''[>]''                         ⍝ fast-forward over non-zero cells.⍞000D    adr ← ''[->+<]''                      ⍝ add right: m n → 0 (m+n)⍞000D    adl ← ''>[-<+>]<''                    ⍝ add left:  m n → (m+n) 0⍞000D    dup ← ''[->+>+<<]''                   ⍝ replicate: m → 0 m m⍞000D⍞000D    sum ← din,''>'',din,''<'',adr,''>'',dot   ⍝ output sum of two input digits.⍞000D⍞000D    bf sum                              ⍝ using "sum" from above.⍞000D4⍞000D5⍞000D9⍞000D    bf din,dup,''>'',adr,''>'',dot          ⍝ double of input digit.⍞000D4⍞000D8⍞000D⍞000D⍝ This program, transliterated from Böhm''s P" language, a precursor to BF,⍞000D⍝ returns the predecessor of a number represented in 2→adic← number system:⍞000D⍝ ⍬ 1 2 11 12 21 22 111 112 121 ...⍞000D⍞000D    +1 1 2 bf''>[>]<[-[<[<]]-<]>+''   ⍝ (-∘1) 8 → 7⍞000D0 0 1 1 1 0⍞000D⍞000D⍝ For a more substantial example, see: →bfack←⍞000D⍞000DSee also: mac bfack balm⍞000DSee also: baby list time adic lisp joy⍞000DSee also: min.dws max.dws eval.dws⍞000DSee also: max.dws/lib.bf eval.dws/bfck⍞000D⍞000DIndex:Brainfuck|turing complete|lists|hyperator|2-adic numbers|Turing tape|tape⍞000DIndex;Turing A.M.|Delcros N.|Rivers J.|Böhm C.' 
