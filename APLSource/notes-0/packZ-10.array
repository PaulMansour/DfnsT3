'cmp ← {cmp←12} ##.packZ exp         ⍝ Abraham Lempel, Jacob Ziv, Terry Welch.⍞000D⍞000DThe  LZW  algorithm  relies on recurrence of sequences (strings) of items in its⍞000Dinput  vector.  The  items  are  typically characters, but may be drawn from any⍞000D"alphabet"  of distinct values, including for example the boolean alphabet: 0 1,⍞000Dor the unique items of a nested vector (see the example using →tokens←, below).⍞000D⍞000DThe  algorithm  maintains a "dictionary", which maps strings in the input vector⍞000Dto  their  associated  output  codes. The dictionary initially contains mappings⍞000Dfor  all  possible  strings  of length one. Input is taken one item at a time to⍞000Dfind  the longest initial string already present in the dictionary. The code for⍞000Dthat  string is output and the string, extended with the following item (i) from⍞000Dthe input vector, is added to the dictionary with the next unused code (obtained⍞000Dby incrementing a counter). The process repeats, with the input string beginning⍞000Dwith (i).⍞000D⍞000DThe number of bits in an output code, and hence the maximum number of entries in⍞000Dthe dictionary, is usually fixed and once this limit is reached, no more entries⍞000Dare  added.  A code width of 12 bits has been recommended. The absolute value of⍞000Dleft  argument [cmp] specifies this limit. If [cmp] is negative, the dictionary,⍞000Drather than the compression structure is returned. See example below.⍞000D⍞000DTechnical notes:⍞000D⍞000DOutput  from  the  function  is a 3-vector: (shape codes alphabet). [codes] is a⍞000Dvector  of  non-negative indices into the dictionary, encoded as a w-row boolean⍞000Dmatrix,  where  w  is the number of bits (default maximum 12) allocated for each⍞000Dvalue. The integer vector for codes is easily reconstituted with 2⊥⍵. [alphabet]⍞000Dis the set of unique items in the input vector.⍞000D⍞000DEach  new "string" inserted into the dictionary is identical to an existing one,⍞000Dbut with one extra "character" appended. In light of this, the dictionary may be⍞000Drepresented  as a tree. For an alphabet of ⍺ unique items, each node in the tree⍞000Dhas  ⍺ sub-nodes: an "⍺-ary tree". For example, a boolean vector (with alphabet:⍞000D0, 1) will produce a binary tree and a string that uses all values from ⎕AV will⍞000Dgive  rise  to a 256-ary tree. Extracting the code associated with a string from⍞000Dthe  dictionary  amounts to using a character at a time to navigate through each⍞000Dof  the  tree''s  nodes.  Encountering a null node signals that the string is not⍞000Dcurrently  in  the  dictionary,  which can be extended by adding a new node with⍞000Da  codeword representing the new string. This type of tree is known in the trade⍞000Das a "suffix trie" (Aho et al 1983).⍞000D⍞000DHistorical note:⍞000D⍞000DThe 20-year patent on this beautiful algorithm finally expired world-wide on 7th⍞000DJuly,  2004.  Prior  to this date, incorporating any coding of LZW in commercial⍞000Dsoftware incurred a royalty.⍞000D⍞000D(muse:⍞000D    This  raises  the question of whether algorithms are invented or discovered.⍞000D    The following thought-experiment suggests they are _discovered_:⍞000D⍞000D    If it turns out that life on Mars has advanced sufficiently to produce math-⍞000D    ematicians,  their  set  of  prime  numbers must coincide with ours (even if⍞000D    their anatomy has lead them to a counting base other than decimal).⍞000D⍞000D    Neither  civilisation invented the sequence of prime numbers; it was already⍞000D    "out there", when we became aware of, or discovered it.⍞000D⍞000D    Same goes for algorithms. If the Martians are aware of prime numbers, in all⍞000D    probability,  they will also be aware of the sieving algorithm that extracts⍞000D    them  (perhaps  they call it "The Sieve of Zork"). Similarly, it is unlikely⍞000D    that  they  are  unaware  of  the subtract-&-swap method for finding highest⍞000D    common factors, which was discovered on our planet by Euclid. And so on;⍞000D⍞000D    Thus,  algorithms exist independently of the cultures that discover them (an⍞000D    idea proposed by the Greek philosopher and mathematician Plato ¯427-¯347).⍞000D⍞000D    Viewed  in  this  light,  useful algorithms could be seen as diamonds in the⍞000D    otherwise  dark  coal-face  that is the set of all expression transformation⍞000D    sequences.⍞000D⍞000D    (⍞000D        However,  it''s hard (for JMS) to see why the same argument doesn''t apply⍞000D        to  artefacts  generally  accepted to be inventions: the baby sling, the⍞000D        wheel/axle,  the  stirrup, the beer-can ring-pull, and so forth. Perhaps⍞000D        it''s  a question of the degree of complexity of the construction or per-⍞000D        haps it depends upon whether the components are discrete or continuous.⍞000D    )⍞000D⍞000D    Of course, both inventions and discoveries may be patented.⍞000D)⍞000D⍞000DExamples:⍞000D⍞000D    packZ''mississippi''                      ⍝ compress char vector.⍞000D 11  0 0 0 0 1 1 0 0 0  misp⍞000D     0 0 1 1 0 1 1 1 0⍞000D     0 1 0 0 1 1 1 1 1⍞000D⍞000D    {⍵≡0 packZ packZ ⍵}''mississippi''        ⍝ expand recovers original.⍞000D1⍞000D⍞000D    2⊥2⊃packZ''mississippi''                  ⍝ ... bool matrix decoded.⍞000D0 1 2 2 5 7 3 3 1⍞000D⍞000D    ¯8 packZ''mississippi''                   ⍝ final compression dictionary.⍞000D┌─┬─┬─┬─┬──┬──┬──┬──┬───┬───┬──┬──┐⍞000D│m│i│s│p│mi│is│ss│si│iss│sip│pp│pi│⍞000D└─┴─┴─┴─┴──┴──┴──┴──┴───┴───┴──┴──┘⍞000D⍞000D    segs←{(¯12 packZ ⍵)[⎕io+2⊥2⊃packZ ⍵]}   ⍝ dictionary entry per code word.⍞000D⍞000D    segs''mississippi''                       ⍝ segments for string.⍞000D┌─┬─┬─┬─┬──┬──┬─┬─┬─┐⍞000D│m│i│s│s│is│si│p│p│i│⍞000D└─┴─┴─┴─┴──┴──┴─┴─┴─┘⍞000D⍞000D    {⍵≡↑,/segs ⍵}''mississippi''              ⍝ enlist of segs recovers original.⍞000D1⍞000D    segs 40⍴''a''                             ⍝ segs for highly repetitive string.⍞000D┌─┬──┬───┬────┬─────┬──────┬───────┬────────┬────┐⍞000D│a│aa│aaa│aaaa│aaaaa│aaaaaa│aaaaaaa│aaaaaaaa│aaaa│⍞000D└─┴──┴───┴────┴─────┴──────┴───────┴────────┴────┘⍞000D⍞000D    segs 40⍴''abcd''                          ⍝ segs for less repetitive string.⍞000D┌─┬─┬─┬─┬──┬──┬───┬──┬──┬───┬───┬───┬────┬─────┬────┬───┐⍞000D│a│b│c│d│ab│cd│abc│da│bc│dab│cda│bcd│abcd│abcda│bcda│bcd│⍞000D└─┴─┴─┴─┴──┴──┴───┴──┴──┴───┴───┴───┴────┴─────┴────┴───┘⍞000D⍞000D    packZ''hello world''                      ⍝ compressed char vector.⍞000D┌──┬─────────────────────┬────────┐⍞000D│11│0 0 0 0 0 1 1 0 1 0 1│helo wrd│⍞000D│  │0 0 1 1 1 0 0 1 1 1 1│        │⍞000D│  │0 1 0 0 1 0 1 1 0 0 1│        │⍞000D└──┴─────────────────────┴────────┘⍞000D⍞000D    packZ 11 ⎕dr''hello world''               ⍝ compressed bool vector.⍞000D┌──┬───────────────────────────────────────────────────────────────┬───┐⍞000D│88│0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 0 1 0│0 1│⍞000D│  │0 0 0 0 0 0 0 0 0 0 0 1 0 1 1 0 1 0 1 1 0 1 1 0 0 1 0 0 1 1 1 0│   │⍞000D│  │0 0 0 0 0 1 0 1 1 1 0 0 1 1 1 1 1 0 0 0 1 0 0 0 1 0 1 0 0 1 1 0│   │⍞000D│  │0 0 0 1 0 1 1 0 0 0 1 0 1 0 0 1 1 1 0 0 1 0 1 1 1 0 0 0 0 1 0 0│   │⍞000D│  │0 1 1 0 0 0 0 0 1 0 1 0 1 0 0 0 1 1 1 1 1 0 1 0 1 0 0 1 0 0 0 0│   │⍞000D└──┴───────────────────────────────────────────────────────────────┴───┘⍞000D⍞000D    packZ 83 ⎕DR''hello world''               ⍝ compressed integer vector.⍞000D┌──┬─────────────────────┬──────────────────────────────┐⍞000D│11│0 0 0 0 0 1 1 0 1 0 1│104 101 108 111 32 119 114 100│⍞000D│  │0 0 1 1 1 0 0 1 1 1 1│                              │⍞000D│  │0 1 0 0 1 0 1 1 0 0 1│                              │⍞000D└──┴─────────────────────┴──────────────────────────────┘⍞000D⍞000D    size←{⍬⍴⎕size''⍵''}                       ⍝ function for size in bytes.⍞000D⍞000D    size notes.packZ                        ⍝ size of notes.⍞000D7200⍞000D    size packZ notes.packZ                  ⍝ size of compressed notes.⍞000D3948⍞000D    size 8 packZ notes.packZ                ⍝ ... with 8-bit code words.⍞000D5388⍞000D⍞000D    size 100 100⍴⍳7                         ⍝ size of numeric matrix.⍞000D10020⍞000D    size packZ 100 100⍴⍳7                   ⍝ compressed size.⍞000D512⍞000D⍞000D    mat                                     ⍝ nested matrix.⍞000D┌────────┬─────┬────────┐⍞000D│Scissors│Stone│Paper   │⍞000D├────────┼─────┼────────┤⍞000D│Stone   │Paper│Scissors│⍞000D└────────┴─────┴────────┘⍞000D⍞000D    size mat                                ⍝ matrix size.⍞000D188⍞000D    size packZ ⍉mat                         ⍝ compressed size.⍞000D172⍞000D    packZ mat                               ⍝ compressed matrix.⍞000D┌───┬─────────┬──────────────────────┐⍞000D│2 3│0 0 0 1 0│┌────────┬─────┬─────┐│⍞000D│   │0 0 1 0 0││Scissors│Stone│Paper││⍞000D│   │0 1 0 0 0│└────────┴─────┴─────┘│⍞000D└───┴─────────┴──────────────────────┘⍞000D⍞000D    tokens ⊃⎕nr''packZ''                      ⍝ tokens in first line of packZ.⍞000D┌─────┬─┬─┬───┬─┬───┬─┬─┬─┬─┬──────────────────────────┬───────────────────────────────┐⍞000D│packZ│←│{│⎕IO│ │⎕ML│←│0│ │1│                          │⍝ Lempel-Ziv-Welch compression.│⍞000D└─────┴─┴─┴───┴─┴───┴─┴─┴─┴─┴──────────────────────────┴───────────────────────────────┘⍞000D⍞000D    toks←↑,/tokens¨⎕nr''packZ''               ⍝ nested vector of packZ''s tokens.⍞000D⍞000D    size toks                               ⍝ size of packZ''s tokens.⍞000D11508⍞000D    size packZ toks                         ⍝ size of compressed tokens.⍞000D4672⍞000D    {⍵≡0 packZ packZ ⍵}toks                 ⍝ nested pack: full circle.⍞000D1⍞000D    {⍵≡0 packZ packZ ⍵}''hello world''        ⍝ char pack: full circle.⍞000D1⍞000D    {⍵≡0 packZ packZ ⍵}11 ⎕dr''hello world''  ⍝ bool pack: full circle.⍞000D1⍞000D⍞000DSee also: Data_compression tokens⍞000D⍞000DIndex:packing|compression|suffix trie|Lempel-Ziv-Welch⍞000DIndex:mathematicians⍞000DIndex;Lempel A.|Ziv J.|Welch T.|Euclid' 
