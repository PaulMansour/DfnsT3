'nmats ← {sreq←1} ##.kt (rows cols)          ⍝ Knight''s Tour Chess Problem.⍞000D⍞000DThe  challenge  is  to  move a knight around the chessboard visiting each square⍞000Dexactly once.  The 2-vector right argument is the board size (rows and cols) and⍞000Dthe optional left argument is the number of solutions required (default 1).⍞000D⍞000DTechnical notes:⍞000D⍞000DThis is an example of a problem that is amenable to  tree-searching.  The knight⍞000Dstarts  from  each  board  square  in  turn,  where he will have between 2 and 8⍞000Dpossibilities  for  his  next  "step"  to  a previously unvisited, let''s call it⍞000D"k-adjacent",  square.  At  each  subsequent step he will have a choice of up to⍞000D8  moves  until he has either visited all squares and so found a solution to the⍞000Dproblem,  or  all of his ways forward are blocked by already visited squares and⍞000Dhe  has "painted himself into a corner".  The choice of initial starting square,⍞000Dtogether  with  the decisions facing him at each step on the way, can be visual-⍞000Dised as the forks of a dense branching tree.⍞000D⍞000DThe algorithm proceeds by trying at each step, EACH possible branch of the tree,⍞000Daccumulating  solutions  when  all  squares have been visited and "backtracking"⍞000Dwhen  there  is  no  way  forward.  This  could  be coded by applying the search⍞000Drecursively  at  each  step  to  each  possible  way forward using the primitive⍞000D"each" (¨) operator.⍞000D⍞000DHowever, a small complication, which arises with this particular problem, is the⍞000Dsize  of  the  tree. The number of knight''s moves from each square on a standard⍞000Dsized board is:⍞000D⍞000D    2 3 4 4 4 4 3 2⍞000D    3 4 6 6 6 6 4 3⍞000D    4 6 8 8 8 8 6 4⍞000D    4 6 8 8 8 8 6 4⍞000D    4 6 8 8 8 8 6 4⍞000D    4 6 8 8 8 8 6 4⍞000D    3 4 6 6 6 6 4 3⍞000D    2 3 4 4 4 4 3 2⍞000D⍞000Dwhich  means  that  to explore the complete tree would involve a number of steps⍞000Din  the  order of the product of these numbers: 9E43. See the examples below for⍞000Dthe number of solutions for some small-sized boards.⍞000D⍞000DOne possible way forward is to _display_ each solution as it is discovered using⍞000D⎕←···, and have the punter interrupt the process when s/he gets bored. An alter-⍞000Dnative  approach,  adopted  here,  is to specify how many solutions are required⍞000D(⍺←1)  and  exit from the process as soon as this many have been found. However,⍞000Dthis  presents  a  further  problem in that, at this point APL''s state indicator⍞000Dwill contain ×/⍵ pendent each (¨) operations which must be interrupted. A rather⍞000Dclumsy  way  of achieving this would be to ⎕signal the vector of results back to⍞000Da receiving error-guard at the top level, thus bypassing the pending eaches.⍞000D⍞000DThe solution adopted here is to use primitive reduction (/) instead of each (¨).⍞000DReduction allows us to pass the vector of solutions-so-far as right argument and⍞000Deach  next  step  position  in  turn as left argument to the reduction''s operand⍞000Dfunction:⍞000D⍞000D        {operand-function} / step0, step1, ··· stepn, solutions-so-far⍞000D⍞000DThe  difference is that with _reduction_, successive applications of the operand⍞000Dfunction  can  be  aware  of the number of solutions accumulated by items to its⍞000Dright  in the reduction''s argument, whereas with _each_, the items are processed⍞000Din isolation. In some sense, _each_ is parallel, while _reduce_ is sequential.⍞000D⍞000DThe  reduction''s operand function is coded to terminate as soon as it finds that⍞000Dits  right  argument  contains  the  required number of solutions. The reduction⍞000Dcontinues to apply its operand with each remaining item as left argument but the⍞000Dfunction now returns immediately without searching its tree-branch. By observat-⍞000Dion, this involves just 168 tests after the first solution for an 8×8 board.⍞000D⍞000DA heuristic (sneaky trick) employed in the code is to find easy solutions first.⍞000DAt  each  step, the following step that itself has the fewest available choices,⍞000Dis examined first. This has the effect of making the knight "cling to the walls"⍞000Dand eke out dark corners, leaving richer pickings in the centre of the board for⍞000Dwhen  things  get  tight  later. Note that he will still find all solutions this⍞000Dway,  but  they will become harder to find as the search progresses, rather than⍞000Dbeing  more  evenly  distributed  throughout.  The technique, suggested by H. C.⍞000DWarnsdorff in 1823, is known as "Warnsdorff''s rule".⍞000D⍞000DCoding details are as follows:⍞000D⍞000D    kt←{⎕ML←1                       ⍝ Knight''s Tour Chess Problem.⍞000D        ⍺←1 ⋄ sreq←⍺ ⋄ nsqs←×/⍵     ⍝ no. of solutions required, default: 1.⍞000D        kdef←,0 1∘.⌽1 ¯1∘.,2 ¯2     ⍝ vector of relative knight''s moves.⍞000D        net←(⊂,⍳⍵)∩¨↓(⍳⍵)∘.+kdef    ⍝ absolute moves from each square.⍞000D        ⍳∘(⍳⍵)¨↑⍬{                  ⍝ initially empty placement vector.⍞000D            sreq=⍴⍵:⍵               ⍝ found required no. of solutions: stop.⍞000D            path←⍺⍺,⊂⍺              ⍝ extended placement vector.⍞000D            nsqs=⍴path:⍵,⊂path      ⍝ solution: accumulate.⍞000D            nxt←(⊂⍺)⊃⍵⍵             ⍝ moves from current square.⍞000D            0=⍴nxt:⍵                ⍝ stitched: back out.⍞000D            net←⍵⍵~¨⊂⊂⍺             ⍝ compressed net.⍞000D            ord←nxt[⍒↑⍴¨net[nxt]]   ⍝ tightest-rightmost order.⍞000D            ↑path ∇∇ net/ord,⊂⍵     ⍝ pursue remaining possibilities.⍞000D        }net/(⌽,⍳⍵),⊂0⍴⊂⍬           ⍝ from each starting position.⍞000D    }⍞000D⍞000DTaking a line at a time:⍞000D⍞000DAs  the  number  (⍺←1)  of  distinct  solutions required and the total number of⍞000Dsquares  are  invariant  for the whole of the search, it is convenient to assign⍞000Dthem  names  [sreq]  and  [nsqs] for reference from within the operand function.⍞000D⍞000D[kdef]  is  a  nested  8-vector  of  relative Knight''s moves. The trivially easy⍞000DRook''s,  King''s,  Queen''s  and  the clearly impossible Bishop''s and Pawn''s, Tour⍞000Dproblems could be coded merely by changing [kdef] to reflect these pieces'' rules⍞000Dof play.⍞000D⍞000D        kdef⍞000D    ┌───┬────┬────┬─────┬───┬────┬────┬─────┐⍞000D    │1 2│1 ¯2│¯1 2│¯1 ¯2│2 1│¯2 1│2 ¯1│¯2 ¯1│⍞000D    └───┴────┴────┴─────┴───┴────┴────┴─────┘⍞000D⍞000D[net]  is  an  ⍵-matrix representing the network of possible next positions from⍞000Deach  square on the board. Each cell contains a vector of the coordinates of its⍞000Dk-adjacent squares. [net] is passed as an operand at each step in the search. As⍞000Dthe  knight chooses his next step, the net is compressed to reflect squares that⍞000Dare  still  available.  The  top left corner of the initial [net] for a standard⍞000Dsized chessboard looks like this:⍞000D⍞000D        3 3↑net⍞000D    ┌─────────────────┬─────────────────────────┬─────────────────────────────────┐⍞000D    │┌───┬───┐        │┌───┬───┬───┐            │┌───┬───┬───┬───┐                │⍞000D    ││2 3│3 2│        ││2 4│3 1│3 3│            ││2 1│2 5│3 2│3 4│                │⍞000D    │└───┴───┘        │└───┴───┴───┘            │└───┴───┴───┴───┘                │⍞000D    ├─────────────────┼─────────────────────────┼─────────────────────────────────┤⍞000D    │┌───┬───┬───┐    │┌───┬───┬───┬───┐        │┌───┬───┬───┬───┬───┬───┐        │⍞000D    ││1 3│3 3│4 2│    ││1 4│3 4│4 1│4 3│        ││1 1│1 5│3 1│3 5│4 2│4 4│        │⍞000D    │└───┴───┴───┘    │└───┴───┴───┴───┘        │└───┴───┴───┴───┴───┴───┘        │⍞000D    ├─────────────────┼─────────────────────────┼─────────────────────────────────┤⍞000D    │┌───┬───┬───┬───┐│┌───┬───┬───┬───┬───┬───┐│┌───┬───┬───┬───┬───┬───┬───┬───┐│⍞000D    ││1 2│2 3│4 3│5 2│││1 1│1 3│2 4│4 4│5 1│5 3│││1 2│1 4│2 1│2 5│4 1│4 5│5 2│5 4││⍞000D    │└───┴───┴───┴───┘│└───┴───┴───┴───┴───┴───┘│└───┴───┴───┴───┴───┴───┴───┴───┘│⍞000D    └─────────────────┴─────────────────────────┴─────────────────────────────────┘⍞000D⍞000DThe  unnamed  body of code at the core of the search is a dyadic operator, whose⍞000Dderived function is operand to the reduction.⍞000D⍞000D        ↑⍬{                     ⍝ initially empty placement vector.⍞000D            ···⍞000D        }net/(⌽,⍳⍵),⊂0⍴⊂⍬       ⍝ from each starting position.⍞000D⍞000DIt is convenient to use an operator, as the values of both the current placement⍞000Dvector  and  [net] are invariant for the duration of the reduction and so may be⍞000Dbound per-reduction as operands and referenced as ⍺⍺ and ⍵⍵ respectively. In the⍞000Dlower  line above, the argument to the reduction is a vector (⌽,⍳⍵) of all poss-⍞000Dible starting positions followed by an initially empty result vector: 0⍴⊂⍬.⍞000D⍞000DWithin the body of the derived function:⍞000D⍞000D    sreq=⍴⍵:⍵                   ⍝ found enough solutions: stop.⍞000D⍞000Dreturns  the  result  vector if enough solutions have been found. The next line⍞000Dappends the next step to the current placement vector:⍞000D⍞000D    path←⍺⍺,⊂⍺                  ⍝ extended placement vector.⍞000D⍞000DIf  the  path  length  is  now  equal to the number of squares on the board, the⍞000Dknight has visited all squares and thus found a solution. The extended solutions⍞000Dvector is returned as result:⍞000D⍞000D    (⍴path)=×/⍴net:⍵,⊂path      ⍝ solution: accumulate.⍞000D⍞000DThe vector of next possible steps is extracted from the current net:⍞000D⍞000D    nxt←(⊂⍺)⊃⍵⍵                 ⍝ moves from current square.⍞000D⍞000DIf there are no moves open to the knight, the current solutions vector is passed⍞000Dalong to the next item in the reduction to see if it has more luck:⍞000D⍞000D    0=⍴nxt:⍵                    ⍝ stitched: back out.⍞000D⍞000DOtherwise,  if progress is still possible, a new [net] is calculated by removing⍞000Dpaths to the current square from each k-adjacent square.⍞000D⍞000D    net←⍵⍵~¨⊂⊂⍺                 ⍝ compressed net.⍞000D⍞000DThe  heuristic described above is applied by sorting remaining k-adjacent square⍞000Dcoordinates  so  that  the  one  with  the fewest exits is on the right and thus⍞000Dvisited first by the reduction.⍞000D⍞000D    ord←nxt[⍒↑⍴¨net[nxt]]       ⍝ tightest-rightmost order.⍞000D⍞000DThe  final  line calls the operator recursively with newly-bound operands [path]⍞000Dand  [net]  as  operand  to  the reduction of the sorted next-step vector [ord].⍞000DNotice  that because the operands are supplied explicitly, the recursive call is⍞000Don the operator _∇∇_, rather than its derived function _∇_.⍞000D⍞000D    ↑path ∇∇ net/ord,⊂⍵         ⍝ pursue remaining possibilities.⍞000D⍞000DWhen the required number of results have been found, the ⍺-vector of (×/⍵)-paths⍞000Dis  converted  into  an  ⍺-vector  of  index-origin-sensitive  ⍵-matrices by the⍞000Dfunction: ⍳∘(⍳⍵)¨.⍞000D⍞000DExamples:⍞000D⍞000D    kt 8 8                      ⍝ 1 tour around a standard 8×8 board.⍞000D┌───────────────────────┐⍞000D│ 1 26 15 24 29 50 13 32│⍞000D│16 23 28 51 14 31 64 49│⍞000D│27  2 25 30 63 60 33 12│⍞000D│22 17 52 59 44 57 48 61│⍞000D│ 3 42 21 56 53 62 11 34│⍞000D│18 39 54 43 58 45  8 47│⍞000D│41  4 37 20 55  6 35 10│⍞000D│38 19 40  5 36  9 46  7│⍞000D└───────────────────────┘⍞000D⍞000D    3 kt 5 5                    ⍝ 3 tours around a smaller board.⍞000D┌──────────────┬──────────────┬──────────────┐⍞000D│ 1 12 25 18  7│ 1 12 23 18  7│ 1 12 23 18  7│⍞000D│22 17  8 13 24│22 17  8 13 24│24 17  8 13 22│⍞000D│11  2 23  6 19│11  2 25  6 19│11  2 21  6 19│⍞000D│16 21  4  9 14│16 21  4  9 14│16 25  4  9 14│⍞000D│ 3 10 15 20  5│ 3 10 15 20  5│ 3 10 15 20  5│⍞000D└──────────────┴──────────────┴──────────────┘⍞000D⍞000D    kt 3 4                      ⍝ Tour around a non-square board.⍞000D┌──────────┐⍞000D│ 1 4  7 10│⍞000D│12 9  2  5│⍞000D│ 3 6 11  8│⍞000D└──────────┘⍞000D⍞000D    4 4⍴ ¯1 kt 3 4              ⍝ All 16 solutions for a 3x4 board.⍞000D┌──────────┬──────────┬──────────┬──────────┐⍞000D│ 1 4  7 10│1  4 7 10 │10  7 4  1│10 7  4 1 │⍞000D│12 9  2  5│8 11 2  5 │ 5  2 9 12│ 5 2 11 8 │⍞000D│ 3 6 11  8│3  6 9 12 │ 8 11 6  3│12 9  6 3 │⍞000D├──────────┼──────────┼──────────┼──────────┤⍞000D│12 9  6 3 │ 8 11 6  3│10  7 2  5│10 7  2 5 │⍞000D│ 1 4 11 8 │ 1  4 9 12│ 1  4 9 12│ 1 4 11 8 │⍞000D│10 7  2 5 │10  7 2  5│ 8 11 6  3│12 9  6 3 │⍞000D├──────────┼──────────┼──────────┼──────────┤⍞000D│3  6 9 12 │ 3 6 11  8│ 5 2  7 10│5  2 7 10 │⍞000D│8 11 4  1 │12 9  4  1│12 9  4  1│8 11 4  1 │⍞000D│5  2 7 10 │ 5 2  7 10│ 3 6 11  8│3  6 9 12 │⍞000D├──────────┼──────────┼──────────┼──────────┤⍞000D│3  6 9 12 │ 3 6 11  8│12 9  6 3 │ 8 11 6  3│⍞000D│8 11 2  5 │12 9  2  5│ 5 2 11 8 │ 5  2 9 12│⍞000D│1  4 7 10 │ 1 4  7 10│10 7  4 1 │10  7 4  1│⍞000D└──────────┴──────────┴──────────┴──────────┘⍞000D⍞000D    ≡∘∪⍨ 1000 kt 8 8            ⍝ First 1000 solutions are all distinct.⍞000D1⍞000D    ≢¨ ¯1 kt¨ (⍳7 7)-⎕io        ⍝ Number of solutions for some small boards.⍞000D0 0 0  0    0     0       0⍞000D0 1 0  0    0     0       0⍞000D0 0 0  0    0     0       0⍞000D0 0 0  0   16     0       0⍞000D0 0 0 16    0   164    1488⍞000D0 0 0  0  164  1728   37568⍞000D0 0 0  0 1488 37568 6637920⍞000D⍞000D⍝ Here is an alternative coding for a square board from Arthur Whitney:⍞000D⍞000D    kt_aw←{⎕io ⎕ml←0⍞000D        n←⍵⍞000D        m←,0 1∘.⌽1 ¯1∘.,2 ¯2⍞000D        m←{n⊥¨(⍵≡¨n|⍵)/⍵}¨↓(,⍳n n)∘.+m⍞000D        k←{0<⍴⍵:⍵⋄(⍴m)=⍴x←⍺⍺,⍺:x⋄⊃x∇∇/z[⍒↑⍴¨m[z←(⍺⊃m)~x]~¨⊂x],⊂⍵}⍞000D        n n⍴⍋0(⍬k)⍬⍞000D    }⍞000D⍞000D    kt_aw 8                 ⍝ 8x8 board⍞000D 0 57 14 31 48 27 12 29⍞000D15 32 53 62 13 30 49 26⍞000D58  1 56 45 54 47 28 11⍞000D33 16 61 52 63 44 25 50⍞000D 2 59 42 55 46 51 10 39⍞000D17 34 19 60 43 40  7 24⍞000D20  3 36 41 22  5 38  9⍞000D35 18 21  4 37  8 23  6⍞000D⍞000D⍝ ... and this from Roger Hui:⍞000D⍞000D    ktourw←{⎕io ⎕ml←0  ⍝ Warnsdorff''s algorithm for the (⍵,⍵) knight''s tour⍞000D        f←{⍵,c[{⍵⍳⌊/⍵}+/~⍺[c←⍺[⊃⌽⍵;]~⍵;]∊⍵]}⍞000D        M←↑(↓∧/(↑t)∊⍳⍵)/¨↓⍵⊥¨t←(,⍳⍵,⍵)∘.+,0 1∘.⌽2 ¯2∘.,1 ¯1⍞000D        (⍵,⍵)⍴⍋M f⍣(¯1+⍵×⍵),0⍞000D    }⍞000D⍞000D    ktourw 8⍞000D 0 49 14 31 60 27 12 29⍞000D15 32 63 54 13 30 59 26⍞000D50  1 48 43 56 61 28 11⍞000D33 16 55 62 53 46 25 58⍞000D 2 51 44 47 42 57 10 39⍞000D17 34 19 52 45 40  7 24⍞000D20  3 36 41 22  5 38  9⍞000D35 18 21  4 37  8 23  6⍞000D⍞000D⍝ See: http://www.jsoftware.com/jwiki/Essays/Knight''s%20Tour⍞000D⍞000D⍞000D---------------------------------⍞000DThe General Knight''s Tour Problem⍞000D---------------------------------⍞000DIt  is  characteristic of APL''s generality, with respect to array rank, that the⍞000Dfunction  can  be  extended  to  higher-rank chessboards, merely by defining the⍞000Drelative  moves for a "hyper-knight". For example, a "normal" (1 2)-knight moves⍞000D1 square in any of 4 directions, followed by 2 squares in either of 2 directions⍞000Dperpendicular to the first move. By analogy, a (1 2 3)-knight on a rank-3 board,⍞000Dmoves 1 square in any of 6 directions, followed by 2 squares in any of 4 direct-⍞000Dions  perpendicular  to  the  first  move,  followed by 3 squares in either of 2⍞000Ddirections perpendicular to the first two moves.⍞000D⍞000DIn the generalised version [gkt],  the right argument extends to a 2-row matrix,⍞000Dwhose first row is the board size and second (default: 1 .. 1 2) is the definit-⍞000Dion of the hyper-knight''s moves. Notice the use of function →pmat← to generate a⍞000Dpermutation matrix.⍞000D⍞000D    gkt←{⎕ML←1                          ⍝ General Knight''s Tour Chess Problem.⍞000D        ⍺←1 ⋄ sreq←⍺                    ⍝ no. of solutions required, default: 1.⍞000D        bsize kdefn←{                   ⍝ board size and moves definition.⍞000D            1+(-⍴⍺)↑⍵-1                 ⍝ extend to left with 1''s.⍞000D        }\2↑(↓⍵),⊂1 2                   ⍝ default (1 2)-knight.⍞000D        nsqs←×/⍴grid←,¨⍳bsize           ⍝ number of squares and grid coords.⍞000D        net←(⊂,grid)∩¨↓grid∘.+∪,↓↑{     ⍝ absolute moves from each square.⍞000D            ⍵[pmat⍴⍵]                   ⍝ all permutations of moves,⍞000D        }∘,¨↑∘.,/1 ¯1∘×¨kdefn           ⍝ in each possible direction.⍞000D        ⍳∘grid¨↑⍬{                      ⍝ initially empty placement vector.⍞000D            sreq=⍴⍵:⍵                   ⍝ found required no. of solutions: stop.⍞000D            path←⍺⍺,⊂⍺                  ⍝ extended placement vector.⍞000D            nsqs=⍴path:⍵,⊂path          ⍝ solution: accumulate.⍞000D            nxt←(⊂⍺)⊃⍵⍵                 ⍝ moves from current square.⍞000D            0=⍴nxt:⍵                    ⍝ stitched: back out.⍞000D            net←⍵⍵~¨⊂⊂⍺                 ⍝ compressed net.⍞000D            ord←nxt[⍒↑⍴¨net[nxt]]       ⍝ tightest-rightmost order.⍞000D            ↑path ∇∇ net/ord,⊂⍵         ⍝ pursue remaining possibilities.⍞000D        }net/(⌽,grid),⊂0⍴⊂⍬             ⍝ from each starting position.⍞000D    }⍞000D⍞000D(muse:⍞000D⍞000D    Solutions for high-rank boards appear to be much sparser than for  matrices.⍞000D    Perhaps this is due  to the increase in the proportion of "hedged-in" cells,⍞000D    those close to edges, as the rank increases.  The  sparsity  of solutions is⍞000D    greatly reduced if we play on an N-torus,  where opposite (N-1)-faces of the⍞000D    N-board are glued  together.  This could be achieved  by changing line[6] in⍞000D    the above function from:⍞000D⍞000D        net←(⊂,grid)∩¨↓grid∘.+∪,↓↑{     ⍝ absolute moves from each square.⍞000D    to:⍞000D        net←{                           ⍝ absolute moves from each square.⍞000D            ⎕io+(⊂⊂bsize)|⍵-⎕io         ⍝ opposite (N-1)-faces deemed adjacent.⍞000D        }↓grid∘.+∪,↓↑{⍞000D⍞000D    whence:⍞000D⍞000D         ⍕ disp¨ gkt¨(3 3)(4 4)         ⍝ regular (1 2)-knight on small 2-tori.⍞000D     ┌─────┐  ┌───────────┐⍞000D     │1 6 8│  │ 1 10  3 12│⍞000D     │4 9 2│  │14  7 16  5│⍞000D     │7 3 5│  │11  4  9  2│⍞000D     └─────┘  │ 8 13  6 15│⍞000D              └───────────┘⍞000D⍞000D        gkt 3 3 3                       ⍝ (1 1 2)-knight on a 3-torus⍞000D    ┌────────┐⍞000D    │ 1  6  8│⍞000D    │15 17 10│⍞000D    │26 19 24│⍞000D    │        │⍞000D    │18 11 13│⍞000D    │20 22 27│⍞000D    │ 4  9  2│⍞000D    │        │⍞000D    │23 25 21│⍞000D    │ 7  3  5│⍞000D    │12 14 16│⍞000D    └────────┘⍞000D)⍞000D⍞000DExamples:⍞000D⍞000D    gkt 8 8                     ⍝ Tour of a regular board by a (1 2)-knight.⍞000D┌───────────────────────┐⍞000D│ 1 26 15 24 29 50 13 32│⍞000D│16 23 28 51 14 31 64 49│⍞000D│27  2 25 30 63 60 33 12│⍞000D│22 17 52 59 44 57 48 61│⍞000D│ 3 42 21 56 53 62 11 34│⍞000D│18 39 54 43 58 45  8 47│⍞000D│41  4 37 20 55  6 35 10│⍞000D│38 19 40  5 36  9 46  7│⍞000D└───────────────────────┘⍞000D⍞000D    gkt ↑(4 5 5)(1 2 2)         ⍝ Tour of a 4×5×5 board by a (1 2 2)-knight.⍞000D┌───────────────┐⍞000D│ 1  60 33 66  7│⍞000D│54  39 92 27 56│⍞000D│29 100 47 94 37│⍞000D│64  35 96 31 62│⍞000D│ 3  58 25 52  5│⍞000D│               │⍞000D│48  79 16 89 42│⍞000D│85  22 73 10 83│⍞000D│12  71 20 75 24│⍞000D│91  18 69 14 77│⍞000D│46  81 50 87 44│⍞000D│               │⍞000D│99  28 55 38 93│⍞000D│34  65  8 61 32│⍞000D│59   2 67  6 51│⍞000D│40  53  4 57 26│⍞000D│97  30 63 36 95│⍞000D│               │⍞000D│72  11 84 23 74│⍞000D│17  90 41 78 15│⍞000D│80  49 98 43 88│⍞000D│21  86 45 82  9│⍞000D│70  13 76 19 68│⍞000D└───────────────┘⍞000D⍞000D    gkt 3 3 4 5                 ⍝ Tour of a 3×3×4×5 board by a (1 1 1 2)-knight.⍞000D┌───────────────────┐⍞000D│  1 144  43  96  51│⍞000D│ 86 155  90 129  22│⍞000D│123  14 121  76 107│⍞000D│170  71 180  33 164│⍞000D│                   │⍞000D│136  79 150  25 132│⍞000D│153  38 147  48  99│⍞000D│ 62 173  64 159  28│⍞000D│ 11 116  57 102  73│⍞000D│                   │⍞000D│  3 142  35  94  45│⍞000D│ 82 139  88 127  20│⍞000D│119   8 113  60 105│⍞000D│168  69 178  31 162│⍞000D│                   │⍞000D│                   │⍞000D│138  81 140  19 126│⍞000D│151   6 135  46  93│⍞000D│ 54 167  74 161  30│⍞000D│  9 114  61 104  59│⍞000D│                   │⍞000D│ 15 118  83 108  77│⍞000D│ 36 179  52 177  34│⍞000D│175   4 165  42  91│⍞000D│112  89 124  17 110│⍞000D│                   │⍞000D│148  85 154  23 130│⍞000D│145  40 133  50  97│⍞000D│ 56 171  72 157  26│⍞000D│ 13 122  67 100  65│⍞000D│                   │⍞000D│                   │⍞000D│ 39 146  41  98  49│⍞000D│ 84 149  78 131  24│⍞000D│117  12 111  66 101│⍞000D│172  63 176  27 158│⍞000D│                   │⍞000D│134  87 156  21 128│⍞000D│141   2 143  44  95│⍞000D│ 68 169  70 163  32│⍞000D│  7 120  55 106  75│⍞000D│                   │⍞000D│  5 152  37  92  47│⍞000D│ 80 137  16 125  18│⍞000D│115  10 109  58 103│⍞000D│166  53 174  29 160│⍞000D└───────────────────┘⍞000D⍞000D    ¯1 gkt ⍪3 1                 ⍝ All tours of a 3 board by a 1-knight.⍞000D┌─────┬─────┐⍞000D│1 2 3│3 2 1│⍞000D└─────┴─────┘⍞000D⍞000DSee also: queens pmat⍞000D⍞000DIndex:chess puzzle|knight''s tour|graph|tree searching|diversions|torus⍞000DIndex:Warndorff''s rule⍞000DIndex;Warndorff H.C.|Whitney A.|Hui R.K.W.' 
