'commit ← (⎕ns'''') ##.UndoRedo                ⍝ Derive undo/redo function.⍞000D⍞000D                 commit var ...     ⍝ commit application state.⍞000D             ''≠'' commit var ...     ⍝ commit if different (avoid duplicates)⍞000D             ''!'' commit _           ⍝ initialize undo/redo stacks.⍞000D   var ... ← ''<'' commit var ...     ⍝ undo (rewind) application state.⍞000D   var ... ← ''>'' commit var ...     ⍝ redo (wind) application state.⍞000D undo/redo ← ''⊃'' commit null        ⍝ most recent undo/redo items or null (Kai)⍞000D             ''↑'' commit size        ⍝ truncate undo stack.⍞000D   sizes   ← ''?'' commit _           ⍝ query undo/redo stack lengths.⍞000D⍞000DUndoRedo  is an operator, used to derive a function for saving and restoring the⍞000Dstate of an application. We can use it to implement "Undo" and "Redo" commands.⍞000D⍞000DOne way to provide undo/redo  is for each command  that changes the state of the⍞000Dapplication, to stack an equal and opposite inverse command. Each _Insert_ would⍞000Dstore a _Delete_ and each _Delete_ would store the corresponding _Insert_.  This⍞000Dis the technique used by the Dyalog editor.⍞000D⍞000DA simpler way is to stack the complete state of the application at each "commit"⍞000Dpoint. Because of the way Dyalog shares arrays, this method does not use as much⍞000Dworkspace as one might expect. All unchanged parts of the state, are _shared_ at⍞000D_every_ level in the undo stack. A commit called after only a small modification⍞000Dof the state uses little workspace - see the example below.⍞000D⍞000DThe state of a typical application might be represented by the values of a (pot-⍞000Dentially  large)  number of variables: V1, V2, ..., which need to be restored in⍞000Dorder to roll back to a prior state. In this case, the derived "commit" function⍞000Dwould be called as follows:⍞000D⍞000D                  ''!'' commit 0              ⍝ initialize undo/redo stacks.⍞000D                      commit V1 V2 ...      ⍝ commit application state.⍞000D                      ...                   ⍝ application changes its state.⍞000D                      commit V1 V2 ...      ⍝ commit application state.⍞000D    (V1 V2 ...) ← ''<'' commit V1 V2 ...      ⍝ undo      ..      ..⍞000D    (V1 V2 ...) ← ''>'' commit V1 V2 ...      ⍝ redo      ..      ..⍞000D⍞000D(⍞000D    When the number of values defining the application state is large, it may be⍞000D    tidier to define a pair of "getstate" and "setstate" functions.⍞000D⍞000D        getstate←{                  setstate←{⍞000D            props←... ⎕wg...            props V1 V2 ...←⍵⍞000D            V1←a b c                    _←... ⎕ws do ...   ⍝ see →do←⍞000D            V2←i j k                    a b c∘←V1⍞000D            ...                         i j k∘←V2⍞000D            Vn←x y z                    ...⍞000D            props V1 V2 ...             x y z∘←Vn⍞000D        }                           }⍞000D⍞000D    Then:⍞000D⍞000D        commit getstate 0                   ⍝ regular commit⍞000D⍞000D        setstate ''<''commit getstate 0       ⍝ undo⍞000D⍞000D    Note that  the gathering and dispersal of values using local names  does not⍞000D    increase the amount of workspace used by the undo/redo stacks.⍞000D⍞000D    As getstate and setstate (by definition) deal with state,  implementing them⍞000D    in  a  functional  paradigm, such as D, is necessarily awkward.  They may be⍞000D    better coded as tradfns. In this case, getstate would be niladic.⍞000D)⍞000D⍞000DNote  that committing a value _discards_ the redo stack. In other words, redo is⍞000Davailable  only  immediately after one or more undos.  This is a feature of most⍞000DUndo/Redo implementations.⍞000D⍞000DThe "query guard" ''?'' could be used in a GUI application to set the Active prop-⍞000Derty of the Undo and Redo buttons or menu items:⍞000D⍞000D    mbar.(redo undo).Active ← ×''?''commit 0      ⍝ [In]Activate redo / undo.⍞000D⍞000DNote that both the query and initialise commands: ''?'' and ''!'' ignore their right⍞000Darguments.⍞000D⍞000DThanks to Kai Jaeger for improvements to this operator.⍞000D⍞000DTechnical notes:⍞000D⍞000DUndoRedo binds a namespace to contain the undo/redo stacks  that persist between⍞000Dcalls  on  the  derived function (commit). See the notes for the →memo← operator⍞000Dfor a description. See also, Ray Cannon''s article "Ghost Variables" Vector 18.3:⍞000Dhttp://www.vector.org.uk/archive/v183/hack183.htm⍞000D⍞000DThere  may  be a way to avoid the code duplication in the undo and redo cases by⍞000Dparameterizing the sense of the reversal.⍞000D⍞000DAn  alternative,  perhaps  slightly less elegant implementation, might use fixed⍞000Dlength _vectors_ to represent the undo and redo stacks.  The advantage  of  this⍞000Dapproach  would   be  the  ease  of controlling a "maximum history depth", which⍞000Dcould be specified as a right argument at initialization time:⍞000D⍞000D    UndoRedoV←{⎕ML←0                    ⍝ Derive undo/redo fn (vector history).⍞000D        ⍺←⊢                             ⍝ default: commit values.⍞000D⍞000D        psh←{(⊂⍺),⍵}                    ⍝ push ⍺ to vector ⍵.⍞000D        pop←{(⊃⍵)(1↓⍵)}                 ⍝ pop top vector item.⍞000D⍞000D        1≡⍺ 1:⍺⍺{                       ⍝ monadic commit: push new hist record.⍞000D            size←⍺.(max⌊1+⍴undo)        ⍝ max size of undo vector.⍞000D            ⍺.undo←size↑⍵ psh ⍺.undo    ⍝ push new undo record.⍞000D            ⍺.redo←⍬                    ⍝ discard redo history.⍞000D        }⍵⍞000D⍞000D        ''!''≡⍺:⍺⍺.(redo undo max←⍬ ⍬ ⍵)  ⍝ initialize history vectors.⍞000D⍞000D        ''?''≡⍺:,↑⍴¨⍺⍺.(redo undo)        ⍝ query history vectors.⍞000D⍞000D        ''<''≡⍺:⍺⍺{                       ⍝ undo:⍞000D            0=⍴⍺.undo:⍵                 ⍝ no more undo: state unchanged.⍞000D            ⍺.redo←⍵ psh ⍺.redo         ⍝ push current state on redo vector.⍞000D            ⊃last ⍺.undo←pop ⍺.undo     ⍝ pop last state.⍞000D        }⍵⍞000D⍞000D        ''>''≡⍺:⍺⍺{                       ⍝ redo:⍞000D            0=⍴⍺.redo:⍵                 ⍝ no more redo: state unchanged.⍞000D            ⍺.undo←⍵ psh ⍺.undo         ⍝ push current state on undo vector.⍞000D            ⊃next ⍺.redo←pop ⍺.redo     ⍝ pop last state.⍞000D        }⍵⍞000D⍞000D        ''↑''≡⍺:⍺⍺{                       ⍝ resize undo vector.⍞000D            ⍺.max←⍵                     ⍝ set new undo vector size limit.⍞000D            ⍺.(undo←(⍵⌊⍴undo)↑undo)     ⍝ truncate undo vector.⍞000D            ⍺.redo←⍬                    ⍝ remove redo records.⍞000D        }⍵⍞000D    }⍞000D⍞000DThen:⍞000D⍞000D       commitV ← (⎕ns'''') UndoRedoV      ⍝ derive commitV function.⍞000D⍞000D    ''!''commitV 10                       ⍝ initialise, setting history size.⍞000D⍞000D       commitV ...                      ⍝ commit transactions ...⍞000D⍞000D    ''↑''commitV 4                        ⍝ change history vector size.⍞000D⍞000DExample:⍞000D⍞000D      commit←(⎕ns'''')UndoRedo            ⍝ derive a commit function.⍞000D⍞000D      ''!''commit 0                       ⍝ initialise history stack.⍞000D⍞000D      ''?''commit 0                       ⍝ both stacks empty.⍞000D0 0⍞000D      A B C D←''now'' ''is'' ''the'' ''time''   ⍝ initial application state.⍞000D⍞000D      commit A B C D                    ⍝ commit application state.⍞000D⍞000D      A B ← ''then'' ''was''                ⍝ change state,⍞000D      commit A B C D                    ⍝ commit changes.⍞000D⍞000D      A C ← ''that'' ''a''                  ⍝ change state,⍞000D      commit A B C D                    ⍝ commit changes.⍞000D⍞000D      B D ← ''took'' ''while''              ⍝ change state,⍞000D⍞000D      ⎕←A B C D                         ⍝ show current state.⍞000D that  took a while⍞000D⍞000D      ''?''commit 0                       ⍝ undo stack has 3 items.⍞000D0 3⍞000D      ⎕←A B C D←''<''commit A B C D       ⍝ undo last change,⍞000D that  was a time⍞000D⍞000D      ''?''commit 0                       ⍝ redo stack has 1 item.⍞000D1 2⍞000D      ⎕←A B C D←''<''commit A B C D       ⍝ undo previous change,⍞000D then  was  the  time⍞000D      ⎕←A B C D←''<''commit A B C D       ⍝ and change before that.⍞000D now  is  the  time⍞000D⍞000D      ⎕←A B C D←''>''commit A B C D       ⍝ Redo last undo.⍞000D then  was  the  time⍞000D      ⎕←A B C D''>''←commit A B C D       ⍝ Redo previous undo.⍞000D that  was a time⍞000D      ⎕←A B C D←''>''commit A B C D       ⍝ Redo undo before that.⍞000D that  took a while⍞000D⍞000D      ''?''commit 0                       ⍝ redo stack emtpy.⍞000D0 3⍞000D      ⎕←A B C D←''<''commit A B C D       ⍝ Undo last Redo.⍞000D that  was a time⍞000D      ⎕←A B C D←''<''commit A B C D       ⍝ Undo previous redo.⍞000D then  was  the  time⍞000D      ⎕←A B C D←''<''commit A B C D       ⍝ Undo redo before that.⍞000D now  is  the  time⍞000D⍞000D⍝ The following example shows that the space overhead of history is small.⍞000D⍞000D      a b c d e f g h i j←{1e6?1e6}¨⍳10             ⍝ ten large variables.⍞000D⍞000D      ''!''commit ''(right arg ignored)''               ⍝ reinitialise history.⍞000D⍞000D      commit a b c d e f g h i j                    ⍝ commit large variables.⍞000D⍞000D      wa←⎕wa ⋄ commit a b c d e f g h i j ⋄ wa-⎕wa  ⍝ committing unchanged vars,⍞000D96⍞000D      wa←⎕wa ⋄ commit a b c d e f g h i j ⋄ wa-⎕wa  ⍝ consumes little workspace.⍞000D80⍞000D      wa←⎕wa ⋄ commit a b c d e f g h i j ⋄ wa-⎕wa  ⍝ consumes little workspace.⍞000D80⍞000D      ⍝ ...⍞000D⍞000DSee also: memo list⍞000D⍞000DIndex:undo|redo⍞000DIndex;Cannon R.|Jaeger K.' 
