'{cmds←''''} ##.hexdump file                   ⍝ Hex dump of native file.⍞000D⍞000DNative  [file]  is opened and the first few words displayed in hexadecimal. Type⍞000D<enter> to show successive words of the binary file, and ")" to quit.⍞000D⍞000DEach output line starts with the file position, followed by the file content (if⍞000Dany) at this position, displayed as hexadecimal 32-bit words:⍞000D⍞000D      hexdump''myfile''⍞000D00000000:·020801aa 00000000 00000001 00000001·⍞000D00000010:·00000001 00000000 00000034 00000001·⍞000D00000020:·00000054 00000054 00000000 00000000·⍞000D00000030:·fffffffc 00000014 36a33e18 00000000·⍞000D00000040:·00000006 0000222f 00000001 00000003·⍞000D00000050:·ff00ff00 ffffffab 00000000 00000002·⍞000D00000060:·00000000 00000002 00000000·⍞000D00000070:·⍞000D00000080:·⍞000D00000090:·⍞000D000000a0:·)     ⍝ quit⍞000D⍞000DThe file position may be changed using expressions, which are evaluated left-to-⍞000Dright.  The  current  value is an implicit left argument to otherwise niladic or⍞000Dmonadic functions. For example:⍞000D⍞000D    +3      ⍝ increment.⍞000D    %4      ⍝ 4-residue.⍞000D    ⊥       ⍝ set base.⍞000D⍞000DNumeric input is interpreted as hexadecimal.⍞000D⍞000DInput  sequences, including partial expressions and commands, may be named using⍞000Da simple macro definition scheme.⍞000D⍞000DHexdump''s optional left argument, character vector [cmds] is a sequence of com-⍞000Dmands to be processed prior to interactive input.⍞000D⍞000DHexdump has a somewhat arcane user interface, reminiscent of software tools dat-⍞000Ding from the 1970s. The function could be viewed as a simple hexadecimal calcul-⍞000Dator, which just happens to display the content (if any) of its file at the pos-⍞000Dition of the current value.⍞000D⍞000DNote that the current value is a 32-bit unsigned quantity, which means that only⍞000Dthe first 4GB of the subject file is accessible.⍞000D⍞000DExpressions:⍞000D⍞000D      hex   set value (file position).⍞000D⍞000D    + hex   increment.⍞000D    - hex   decrement.⍞000D    × hex   multiply.⍞000D    ÷ hex   integer divide.⍞000D    % hex   integer remainder (residue commute).⍞000D⍞000D    ⊥       set address base.⍞000D    !       absolute position (subtract base).⍞000D    *       get 32-bit word from file⍞000D    ← hex   put 32-bit word to file.⍞000D⍞000D    : case  case selection (see below).⍞000D⍞000DCommands:⍞000D⍞000D    (       call, saving current state.⍞000D    )       return / quit.⍞000D⍞000D    ⍝ ···   comment.⍞000D    ''···''   message.⍞000D    ?       help.⍞000D    ⊤       trace on/off.⍞000D    < var   include sub-script.⍞000D⍞000D    name = ···· niladic macro.⍞000D    name ⍵ = ·· monadic macro.⍞000D⍞000DSystem variables:⍞000D⍞000D    ⎕dw = · display width (words).⍞000D    ⎕be = · big-endian 0/1.⍞000D⍞000DSome examples⍞000D-------------⍞000D    42                  ⍝ set file position to hex 42 (decimal 66) bytes.⍞000D    10*×4-(c*)⊥         ⍝ set base to 4 × value at 0x10, minus value at 0x0c.⍞000D    ÷100×100            ⍝ value with least significant byte cleared.⍞000D    (%2:''even'':''odd'')   ⍝ display parity.⍞000D    clsb = ÷100×100     ⍝ define macro.⍞000D⍞000DRelative Addresses⍞000D------------------⍞000DMany binary files have an internal structure, where values in the file represent⍞000Dpositions relative to a "base". A Dyalog workspace, for example, contains memory⍞000Dpointers  that  were  in  effect  when the workspace was saved. In the .dws file⍞000Dthese can be viewed as offsets from a notional base.⍞000D⍞000DCommand "⊥" is used to set the base, which is then added to:⍞000D⍞000D    - directly  entered  hexadecimal values _excluding_ those immediately to the⍞000D      right of a monadic function:⍞000D⍞000D      00000000:·2⍞000D                └────────── base added to this value.⍞000D⍞000D      00000002:·+ 3 + 4⍞000D                  └───┴── base _not_ added to this value⍞000D⍞000D    - values retrieved from the file content using monadic *:⍞000D⍞000D      00000099:·*⍞000D                └────────── base added to value of file word at 0x99.⍞000D⍞000DApart  from  indirection  (*), the content of the file has no bearing on address⍞000Dcalculation. Only the current base and position play a part. To illustrate this,⍞000Dthe following examples use the  special file "nul", which is of zero length:⍞000D⍞000D          hexdump''nul''⍞000D    00000000:·⍞000D⍞000D⊥ Sets  the  base  to  the current file position. This base is then added to all⍞000D  subsequent input values to calculate the absolute file position.⍞000D⍞000D    ········:·1000      ⍝ set file position to 0x1000.⍞000D    00001000:·⊥         ⍝ set base to 0x1000.⍞000D    00001000:·ab        ⍝ go to _relative_ file position 0xab,⍞000D    000010ab:·          ⍝ which is _absolute_ file position 0x10ab.⍞000D⍞000D! Foils relative addressing by subtracting the current base:⍞000D⍞000D    ········:·cd        ⍝ relative 0xcd⍞000D    000010cd:·!         ⍝ absolute 0xcd⍞000D    000000cd:·ef!       ⍝ absolute 0xef⍞000D    000000ef:·⍞000D⍞000DTo remove relative addressing, reset the base to 0:⍞000D⍞000D    ········:·0!⊥       ⍝ reset base.⍞000D⍞000DCall / Return⍞000D-------------⍞000DWhen  investigating  a tree structure, for example, it is often convenient to be⍞000Dable  to return to a parent node after examining subnodes. Command "(" saves the⍞000Dcurrent state (file position, base, macro table, trace state) and it is restored⍞000Dby a matching ")".⍞000D⍞000DNote that saving the base allows a temporary base to be installed for the durat-⍞000Dion of a local operation.⍞000D⍞000DThe current calling level is indicated by the number of white dots (·) following⍞000Dthe input prompt. Entering ")" at level one terminates hexdump.⍞000D⍞000DA nuance: there is a subtle difference between parentheses used in the above way⍞000Dand those used to bind the right argument of a monadic function: 1+(2×3). In the⍞000Dlatter  case,  the  current  value  (6)  is _returned_ as the result of the sub-⍞000Dexpression,  whereas  in  the  former  (call/return) case, the pre-call value is⍞000D_restored_. Notice this distinction in the following:⍞000D⍞000D          hexdump''nul''⍞000D    00000000:·2+3           ⍝ set file position to 5.⍞000D    00000005:·0''''           ⍝ note file position is _5_.⍞000D⍞000D    00000000:·(2+3)         ⍝ call; set file position to 5; return.⍞000D    00000000:·0''''           ⍝ note file position is _0_.⍞000D⍞000D    00000000:·1+(2+3)       ⍝ set file position to 1+5.⍞000D    00000006:·0''''           ⍝ note file position is _6_.⍞000D⍞000D    00000000:·(2+3)+1       ⍝ call; set file position to 5; return; advance 1.⍞000D    00000001:·0''''           ⍝ note file position is _1_.⍞000D⍞000DThis rarely causes a problem in practice, as parentheses are never needed to the⍞000Dleft of a function, just as in APL they are never needed to the right.⍞000D⍞000DMessage Output⍞000D--------------⍞000DConsecutive messages are concatenated and may contain embedded newlines:⍞000D⍞000D          display example       ⍝ sample script vector.⍞000D    ┌→───────┐⍞000D    │''join '' │⍞000D    │''these ''│⍞000D    │''up''    │⍞000D    │        │⍞000D    │''       │⍞000D    │output  │⍞000D    │separate│⍞000D    │lines   │⍞000D    │        │⍞000D    │''       │⍞000D    └────────┘⍞000D⍞000D          example hexdump''nul''⍞000D    join these up⍞000D    output⍞000D    separate⍞000D    lines⍞000D⍞000D    00000000:·)⍞000D⍞000DCase Selection⍞000D--------------⍞000DA case is selected using the construct (value :case0 :case1 ··· :default).⍞000D⍞000DTo  allow  the  selected  case to modify the environment _outside_ the construct⍞000D(for example, to set the file position) it is copied to the input stream _after_⍞000Dprocessing the construct''s closing parenthesis.⍞000D⍞000DOn encountering a colon:⍞000D⍞000D    if the current value is zero or⍞000D    if this is the final (default) case:⍞000D        the first case is moved to immediately after the closing ")" and⍞000D        any other cases are discarded:⍞000D⍞000D        ┌─┬─────────────────────────────────┐ ┌──────────────────┐⍞000D        │0│:first case:next case:··· ) more │→│) first case more │⍞000D        └─┴─────────────────────────────────┘ └──────────────────┘⍞000D        ┌─┬─────────────────────────────────┐ ┌──────────────────┐⍞000D        │n│              :final case ) more │→│) final case more │⍞000D        └─┴─────────────────────────────────┘ └──────────────────┘⍞000D⍞000D    otherwise:⍞000D        the first case is discarded and⍞000D        the current value is decremented by 1:⍞000D⍞000D        ┌─┬─────────────────────────────────┐ ┌───┬──────────────────────┐⍞000D        │n│:first case:next case: ···) more │→│n-1│:next case: ···) more │⍞000D        └─┴─────────────────────────────────┘ └───┴──────────────────────┘⍞000D⍞000DFor example:⍞000D⍞000D    00000000:·(''The value at 0x0c is '' c*%2 :''even'':''odd'')''.''⍞000D    The value at 0x0c is even.⍞000D    00000000:·123           ⍝ set value to 123.⍞000D    00000123:·$             ⍝ display current value, see $ macro below.⍞000D    123⍞000D    00000123:·(99:$)        ⍝ selects default case $, which is⍞000D    123⍞000D    00000123:·(99)$         ⍝ evaluated like this,⍞000D    123⍞000D    00000123:·(99$)         ⍝ not like this.⍞000D    99⍞000D    00000123:·⍞000D⍞000DTip:  a case may not contain an unbalanced ")", as this would terminate the con-⍞000Dstruct.  However, the ")" may be _named_ outside the case selection and the name⍞000Dused within:⍞000D⍞000D    ] = )               ⍝ ] means )⍞000D    pop = (depth::])    ⍝ pop if depth≠0.⍞000D⍞000DMacros⍞000D------⍞000DFile  exploration is made a little easier by being able to define simple macros.⍞000DMacro  names  may include any character and those composed exclusively from A-Z,⍞000Da-z, 0-9, _ and ⎕ may be of any length (otherwise, they are of length 1 and lex-⍞000Dically equivalent to primitive commands). This means, for example, that a macro⍞000Dwith a name such as ⍟, need not be blank-separated from a literal number: ⍟99.⍞000D⍞000D    string      interpretation⍞000D    ------      --------------⍞000D    aabb        name "aabb"⍞000D    aa bb       two names: "aa" and "bb"⍞000D    ⍟           name "⍟"⍞000D    ⍺⍺          two names: "⍺" and "⍺"⍞000D    __          one name "__"⍞000D    ∆_⍙         three names "∆", "_" and "⍙"⍞000D    {oct}       three names "{", "oct" and "}"⍞000D    ⎕this       single name.⍞000D⍞000DWhen a macro name is encountered in the input stream, it is immediately replaced⍞000Dwith  the  corresponding value and processing resumed. In particular, this means⍞000Dthat  the  macro value is re-scanned, so that any sub-macros are also evaluated.⍞000DUnbounded recursion will "hang" hexdump:⍞000D⍞000D          hexdump''nul''      ⍝ don''t try this at home:⍞000D    00000000:·hang = hang   ⍝ unboundedly recursive macro,⍞000D    00000000:·hang          ⍝ ...  hangs until interrupted.⍞000D⍞000DMacros  may  redefine  (cover)  even primitive constructs. For example "!" (non-⍞000Drelative value) could be coded as:⍞000D⍞000D    !=-(0)  ⍝ subtract base value.⍞000D⍞000D⌿ and ⍀⍞000D-------⍞000DKeystrokes <enter> and <backspace> are converted to tokens ⌿ and ⍀ respectively.⍞000DBy default these system commands advance and reverse the file position by 4×⎕dw,⍞000Dwhere  ⎕dw  is the current display width (number of word-columns). We can change⍞000Dthe  effect  of  entering  these  keystrokes  by  redefining them. Notice in the⍞000Dfollowing example, how backing up over the prompt, generates ⍀ commands.⍞000D⍞000D          ''100''hexdump''nul''⍞000D    00000100:·⌿=''<er>''+1    │ advance one byte per <enter>.⍞000D    00000100:·⍀=''<bs>''-1    │ back up one byte per <backspace>.⍞000D    00000100:·              │ <er>⍞000D    <er>                    │⍞000D    00000101:·              │ <er>⍞000D    <er>                    │⍞000D    00000102:               │ <bs>⍞000D    <bs>                    │⍞000D    000001                  │ <bs><bs><bs><bs>⍞000D    <bs><bs><bs><bs>        │⍞000D    000000fd:·)             │⍞000D⍞000D⍀ might be coded to return from a call:⍞000D⍞000D        hexdump''''⍞000D    00000000:·⍀=)           │ <bs> = return from call⍞000D    00000000:·((((((        │ call to depth 7⍞000D    00000000:·······        │ <er> at depth 7⍞000D    00000010:···            │ <bs><bs><bs><bs> over 4 dots to return 4 levels⍞000D    00000000:···            │ enter at depth 3⍞000D    00000010:·              │ <bs><bs> return 2 further levels⍞000D    00000000:               │ <bs> return right out of hexdump.⍞000D⍞000DNB:  ⍀ generation depends _only_ on detecting that the input is shorter than the⍞000Dprompt.  If  so, a corresponding number of ''⍀'' chars are injected into the input⍞000Dstream.  In  particular,  no  account  is  taken of the _content_ of the shorter⍞000Dinput. This means that chars following backspaces, up to the initial size of the⍞000Dprompt, are ignored:⍞000D⍞000D          hexdump''''⍞000D    00000000:·((((          │ increase depth to 5.⍞000D    00000000:·····          │ <er> advances file posn 0→10.⍞000D    00000010:···1234        │ <bs><bs>1234: only 34 recognised  :-(⍞000D    00000034:·····          │ <er> advances 34→44.⍞000D    00000044:···            │ <bs><bs> reverses 44→24.⍞000D    00000024:·····1234      │ 1234 sets file posn.⍞000D    00001234:·····)))))     │ quit.⍞000D⍞000D    to avoid confusion, always enter <bs> chars on a separate line. See note on⍞000D    "Prior line editing", below.⍞000D⍞000DProviding  code for ⌿ can be used to great effect in annotating a structure that⍞000Dextends over a number of lines of output.⍞000D⍞000DNB: be wary of the effects of redefining primitive commands:⍞000D⍞000D          hexdump''nul''      ⍝ don''t try this at home:⍞000D    00000000:·)=            ⍝ ) expands to the null string, so⍞000D    00000000:·)             ⍝ there is no way out!⍞000D    00000000:·)⍞000D    ...⍞000D⍞000DEven  hexadecimal  numbers  may  be used as macro names! When processing a token⍞000Dfrom the input stream, hexdump looks first in the macro table _before_ wondering⍞000Dwhether it''s a number. A hex value, occluded by a macro name, may be accessed by⍞000Dprefixing an extra 0:⍞000D⍞000D          hexdump''nul''⍞000D    00000000:·face          ⍝ go to 0xface.⍞000D    0000face: 0             ⍝ go to 0.⍞000D    00000000:·face=''happy''  ⍝ macro definition.⍞000D    00000000:·face          ⍝ macro reference.⍞000D    happy⍞000D    00000000:·0face         ⍝ go to 0xface⍞000D    0000face:·⍞000D⍞000D          hexdump''nul''⍞000D    00000000:·3=''three''⍞000D    00000000:·1⍞000D    00000001:·2⍞000D    00000002:·03⍞000D    00000003:·4⍞000D    00000004:·)⍞000D⍞000DThe  body  of  a  macro extends as far as the next newline together, if input is⍞000Dfrom  a  script,  with  any  following  lines that are indented further than the⍞000Ddefining  "=". This "offside rule" allows definitions to extend over a number of⍞000Dlines and enables macros to define macros:⍞000D⍞000D    aa = ...                ⍝ definition of aa, which when called⍞000D         bb = ...           ⍝   aa defines bb, which when called⍞000D              cc = ...      ⍝       bb defines cc⍞000D         dd = ...           ⍝   aa defines dd.⍞000D       ee = ...             ⍝ ee is _not_ part of aa (not right of aa''s =).⍞000D⍞000DNote that the above macro-defined macros are global; the only way to localise a⍞000Ddefinition is with () call/return.⍞000D⍞000DSome examples of macro definitions might be:⍞000D⍞000D    right = (+4*            ⍝ call right pointer in binary tree.⍞000D    retn = )                ⍝ return from call⍞000D    line = ''---------------------------------''⍞000D    help = ''m: more rows    ⍝ multi-line help output.⍞000D    ·    ·  n: next sibling⍞000D    ·    ·  q: quit''⍞000D⍞000D    symb =  ''········  ········ ········ ········ lft····· rgt····· val····· spc·····''⍞000D    ·    ·  lft = (+0c*⍞000D    ·    ·  rgt = (+10*⍞000D    ·    ·  val = (+14*⍞000D    ·    ·  spc = (+18*+c* nsr⍞000D⍞000D    how_many = (::''one'':''two'':''plenty'')         ⍝ primitive counting.⍞000D⍞000D    quit = ) quit           ⍝ exit from any level of ")"s.⍞000D⍞000D    aa = bb = cc = ''hello''  ⍝ aa defines bb, which defines cc.⍞000D⍞000DNotice that indented macro definitions may be rendered more legible by the pres-⍞000Dence of "white dots" (·), which are interpreted as white space and ignored.⍞000D⍞000DMacros are stored in a table, which is local to the current calling level.  This⍞000Dmeans that macros defined after a "(", disappear with the corresponding ")".⍞000D⍞000DPart of the charm, power and danger of any macro system is that incomplete expr-⍞000Dessions  may  be  named; it is inherently type-unsafe. This means that erroneous⍞000Ddefinitions may be hard to track down.⍞000D⍞000DPrior line editing⍞000D------------------⍞000DIt is often convenient to modify and resubmit lines previously entered into the⍞000Dhexdump session:⍞000D⍞000D        ''⎕dw=2''hexdump ⎕wsid,''.dws''         │ Examine WS with display width = 2.⍞000D    00000000:·050903aa 80050009·1234        │ set file posn to 1234 · · · · [A]⍞000D    00001234:·00000005 00003401·            │ <er> advances 1234+8→123c⍞000D    0000123c:·037e4fb8 037e50bc·            │ <er> advances 123c+8→1244⍞000D    00000000:·050903aa 80050009·1234+4321   │ edit & reinput line [A].⍞000D    00005555:·e4000008 e8037f1c·            │ file posn is now 1234+4321.⍞000D⍞000DBeware  however, that all (and only) those characters in the modified input line⍞000Dto  the right of the original prompt are entered into the input stream. This can⍞000Dbe confusing if the display width differs between the prior and current lines:⍞000D⍞000D        ''⎕dw=2''hexdump ⎕wsid,''.dws''     │ Examine WS with display width = 2.⍞000D    00000000:·050903aa 80050009·''hello'' │ file posn 0; output string  · · · [A]⍞000D    hello                               │⍞000D    00000000:·050903aa 80050009·⎕dw=1   │ reduce display width to 1.⍞000D    00000000:·050903aa·                 │ <er> advances 4 bytes.⍞000D    00000004:·80050009·                 │ edit and resubmit line [A]⍞000D    00000000:·050903aa 80050009·''world'' │ the prompt has been overwritten⍞000D    world                               │ note that the last word of the⍞000D    80050009:·)                         │ prompt 80050009 has been input!⍞000D⍞000DThis  is  also the cause of the problem, mentioned above, when following a sequ-⍞000Dence of backspaces with some characters intended for input:⍞000D⍞000D        ''((((''hexdump''''     │ start hexdump at depth 5.⍞000D    00000000:·····          │ <er> advances to posn 10.⍞000D    00000010:···1234        │ <bs><bs>1234, only ''34'' extends beyond prompt⍞000D    00000034:·····          │ so only 34 input.⍞000D⍞000D    to avoid confusion, always enter <bs> chars on a separate line.⍞000D⍞000DWriting to file⍞000D---------------⍞000DCommand  "←"  overwrites  the  word  at the current position with its hex-valued⍞000Dright  argument.  As a safeguard, writing is enabled only if the first character⍞000Din hexdump''s left argument is a ''←''.⍞000D⍞000D          ''←''hexdump''myfile''                                ⍝ enable write.⍞000D    00000000:·03020100 07060504 0b0a0908 0f0e0d0c·←ace⍞000D    00000000:·00000ace 07060504 0b0a0908 0f0e0d0c·(4←dead)⍞000D    00000000:·00000ace 0000dead 0b0a0908 0f0e0d0c·(8←(beef×10000))⍞000D    00000000:·00000ace 0000dead beef0000 0f0e0d0c·⍞000D⍞000DTo overwrite a single byte, we might use a macro to merge the new value with the⍞000Dexisting word:⍞000D⍞000D    00000000:·00000ace 0000dead beef0000 0f0e0d0c·setb = *÷100×100+⍞000D    00000000:·00000ace 0000dead beef0000 0f0e0d0c·(f←(f setb aa))⍞000D    00000000:·00000ace 0000dead beef0000 aa0e0d0c·⍞000D⍞000DTracing⍞000D-------⍞000DSetting trace mode using "⊤" shows the current input line as each token is proc-⍞000Dessed.  Addresses  generated during the trace are distinguished by a "⊤" char in⍞000Dplace of the ":", following the file position.⍞000D⍞000D          hexdump''nul''⍞000D    00000000:·2+3×4 ''''       ⍝ untraced expression.⍞000D⍞000D    00000014:·⊤2+3×4⊤ ''''     ⍝ traced expression.⍞000D    00000014⊤ 2+3×4⊤ ''''     ⍝ traced expression.⍞000D    00000002⊤ +3×4⊤ ''''     ⍝ traced expression.⍞000D    00000002⊤ 3×4⊤ ''''     ⍝ traced expression.⍞000D    00000005⊤ ×4⊤ ''''     ⍝ traced expression.⍞000D    00000005⊤ 4⊤ ''''     ⍝ traced expression.⍞000D    00000014⊤ ⊤ ''''     ⍝ traced expression.⍞000D⍞000D    00000014:·2+⊤3×4⊤ ''''     ⍝ traced subexpression.⍞000D    00000002⊤ 3×4⊤ ''''     ⍝ traced subexpression.⍞000D    00000005⊤ ×4⊤ ''''     ⍝ traced subexpression.⍞000D    00000005⊤ 4⊤ ''''     ⍝ traced subexpression.⍞000D    00000014⊤ ⊤ ''''     ⍝ traced subexpression.⍞000D⍞000D    00000014:·⍞000D⍞000DIncluding sub-scripts⍞000D---------------------⍞000DCommand  "<"  executes the APL name to its right and inserts the result into the⍞000Dinput stream at that point. It would typically be used to include a subscript in⍞000Dthe same way as the C language preprocessor''s #include statement.⍞000D⍞000DIn  order  for sub-scripts to take advantage of the offside rule, incoming lines⍞000Dare  aligned  with  the "<" symbol in the calling script. This means that a sub-⍞000Dscript  may  form  part  or all of the body of a macro definition in the calling⍞000Dscript:⍞000D⍞000D    00000000:·000901aa 00000002 00000001 00000001·<file     ⍝ include subscript.⍞000D    00000000:·000901aa 00000002 00000001 00000001·file      ⍝ show file type.⍞000D    Dyalog Component File V10.1⍞000D    00000000:·000901aa 00000002 00000001 00000001·⍞000D⍞000DCoding with macros⍞000D------------------⍞000DWith a little ingenuity, macros can be surprisingly flexible. For example:⍞000D⍞000D          display xd            ⍝ script for hex and decimal conversion macros.⍞000D    ┌→────────────────────────────────────────────────────────────────────┐⍞000D    │⍝ display decimal equivalent of hex value:                           │⍞000D    │                                                                     │⍞000D    │    dec = (:''0'':''1'':''2'':''3'':''4'':''5'':''6'':''7'':''8'':''9'':(÷a dec)(%a dec))│⍞000D    │                                                                     │⍞000D    │⍝ set hex equivalent of decimal value:                               │⍞000D    │                                                                     │⍞000D    │    hex =                                                            │⍞000D    │         . = ÷10 sub × a +                                           │⍞000D    │         sub = (::(%10:.0:.1:.2:.3:.4:.5:.6:.7:.8:.9))               │⍞000D    │         sub                                                         │⍞000D    └─────────────────────────────────────────────────────────────────────┘⍞000D⍞000D          xd hexdump''nul''⍞000D    00000000:·(42 dec)          ⍝ show decimal equivalent of 0x42.⍞000D    66⍞000D    00000000:·66 hex            ⍝ set hex equivalent of decimal 66.⍞000D    00000042:·)⍞000D⍞000DDecode the "magic" word at the start of a Dyalog binary file:⍞000D⍞000D          display file          ⍝ script for file identification macro:⍞000D    ┌→──────────────────────────────────────────────────────────┐⍞000D    │file = (0!⊥                                                │⍞000D    │·   ·   ; = ''   ⍝ newline                                  │⍞000D    │·   ·       ''                                              │⍞000D    │·   ·   dec = (_d:(÷a dec)(%a dec))                        │⍞000D    │·   ·   hex = (_d:''a'':''b'':''c'':''d'':''e'':''f'':(÷10hex)(%10hex))│⍞000D    │·   ·   ·_d = :''0'':''1'':''2'':''3'':''4'':''5'':''6'':''7'':''8'':''9''     │⍞000D    │·   ·   dd  = (%100 dec) ÷100  ⍝ show dec ''n skip.         │⍞000D    │·   ·   xx  = (%100 hex) ÷100  ⍝  ..  hex  ..              │⍞000D    │·   ·                                                      │⍞000D    │·   ·   wsfile =                                           │⍞000D    │·   ·   ·   ·   ''Version:  '' 2* dd ''.'' dd ;                │⍞000D    │·   ·   ·   ·   ''Saved by: '' 4* dd ''.'' dd ''.'' dd ;         │⍞000D    │·   ·   ·   ·   ''Type:     ''                               │⍞000D    │·   ·   ·   ·   ·   (÷80%2:''big'':''little'')''-endian''        │⍞000D    │·   ·   ·   ·   ·   (÷40%2::'' ,dextend'')                   │⍞000D    │·   ·   ·   ·   ·   (÷20%2::'' ,64-bit'' )                   │⍞000D    │·   ·   ·   ·   ·   (÷10%2::'' ,dalign'' )                   │⍞000D    │·   ·   ·   ·   ·   (÷08%2::'' ,unicode'')                   │⍞000D    │·   ·                                                      │⍞000D    │·   ·   (0*%100-aa                                         │⍞000D    │·   ·   ·:''Dyalog ''                                        │⍞000D    │·   ·   ·   default = 1* ''file 0x'' xx                      │⍞000D    │·   ·   ·   (1*%100                                        │⍞000D    │·   ·   ·   : default                                      │⍞000D    │·   ·   ·   :''32-bit component file: '' 2* dd ''.'' dd        │⍞000D    │·   ·   ·   :''External Variable: ''     2* dd ''.'' dd        │⍞000D    │·   ·   ·   :''Workspace''; wsfile                           │⍞000D    │·   ·   ·   : default                                      │⍞000D    │·   ·   ·   : default                                      │⍞000D    │·   ·   ·   : default                                      │⍞000D    │·   ·   ·   :''Session'';   wsfile                           │⍞000D    │·   ·   ·   : default                                      │⍞000D    │·   ·   ·   :''64-bit component file: '' 2* dd ''.'' dd        │⍞000D    │·   ·   ·   : default                                      │⍞000D    │·   ·   ·   )                                              │⍞000D    │·   ·   ·:''File '' 0* xx'' ''xx'' ''xx'' ''xx'' ...''               │⍞000D    │·   ·   )                                                  │⍞000D    │·   )                                                      │⍞000D    └───────────────────────────────────────────────────────────┘⍞000D⍞000DHere is the osc function (see →osc← and the example in →traj←):⍞000D⍞000D          hexdump''nul''⍞000D    00000000:·osc = dec '' ''(:''?''::(%2:÷2:×3+1) osc)⍞000D    00000000:·dec = (:''0'':''1'':''2'':''3'':''4'':''5'':''6'':''7'':''8'':''9'':(÷a dec)(%a dec))⍞000D    00000000:·3 osc⍞000D    3 10 5 16 8 4 2 1⍞000D    00000001:·7 osc⍞000D    7 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1⍞000D    00000001:·)⍞000D⍞000DThis repeater macro calls its operand sequence a specified number of times.⍞000D⍞000D00000000:·reps=(::oseq -1 reps)         ⍝ repeater macro.⍞000D00000000:·oseq=''ding ''                  ⍝ operand sequence.⍞000D00000000:·3 reps                        ⍝ 3 repetitions.⍞000Dding ding ding⍞000D00000000:·oseq=dec '' ''                  ⍝ new operand sequence.⍞000D00000000:·5 reps                        ⍝ 5 repetitions.⍞000D5 4 3 2 1⍞000D00000000:·⍞000D⍞000DMonadic macros⍞000D--------------⍞000DAs  the  above  examples show, a surprising amount may be achieved using niladic⍞000Dmacros,  which operate on the current value. Sometimes however, it is convenient⍞000Dto "parameterise" a macro with a right argument. Monadic macros are distinguish-⍞000Ded with a "⍵" between the name and the "=". Compare the niladic macro:⍞000D⍞000D    ⍝ Display current value "⍺" in decimal:⍞000D⍞000D        da   = (:''0'':''1'':''2'':''3'':''4'':''5'':''6'':''7'':''8'':''9'':(÷a da)(%a da))⍞000D⍞000Dwith its monadic counterpart:⍞000D⍞000D    ⍝ Display ⍵ in decimal:⍞000D⍞000D        dw ⍵ = (⍵:''0'':''1'':''2'':''3'':''4'':''5'':''6'':''7'':''8'':''9'':(dw(⍵÷a))(dw(⍵%a)))⍞000Dthen:⍞000D    ...⍞000D    00000000:·(3e8 da)      ⍝ display "⍺"⍞000D    1000⍞000D    00000000:·dw 3e8        ⍝ display ⍵⍞000D    1000⍞000D    00000000:·⍞000D    ...⍞000D⍞000Dwe can recode the osc function from above to take an explicit (right) argument:⍞000D⍞000D        osc ⍵ = dw ⍵                ⍝ osc: probably returns 1.⍞000D        ·     · (⍵                  ⍝ arg is :⍞000D        ·     · :''?''                ⍝ 0: huh?⍞000D        ·     · :1                  ⍝ 1: done.⍞000D        ·     · :'' ''                ⍝ display inter-number gap.⍞000D        ·     ·  (⍵%2               ⍝ parity:⍞000D        ·     ·  : osc(⍵÷2)         ⍝ even: ∇⍵÷2⍞000D        ·     ·  : osc(⍵×3+1)       ⍝ odd:  ∇1+3×⍵⍞000D        ·     ·  )⍞000D        ·     · )⍞000D    ...⍞000D    00000000:·osc 3⍞000D    3 10 5 16 8 4 2 1⍞000D    00000001:·osc 7⍞000D    7 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1⍞000D    00000001:·)⍞000D⍞000Dand even access both implicit (left) and explicit (right) arguments to emulate a⍞000Ddyadic function. Here is Ackermann''s function - but with the usual order of arg-⍞000Duments reversed, as this is easier to code. In other words: ack_ ≡≡ ack⍨.⍞000D⍞000D        ack_ ⍵ = ⍝ da''-''dw ⍵            ⍝ (commuted) Ackermann''s function.⍞000D        ·     · (⍵                      ⍝   ack_←{⍞000D        ·     · :+1 ⍝ '' ''               ⍝       ⍵=0:⍺+1⍞000D        ·     · :   ⍝ '' ''               ⍝⍞000D        ·     · ·(                      ⍝⍞000D        ·     · ·: 1 ack_ (⍵-1)         ⍝       ⍺=0:1 ∇ ⍵-1⍞000D        ·     · ·:-1 ack_ ⍵ ack_ (⍵-1)  ⍝       ((⍺-1)∇ ⍵)∇ ⍵-1⍞000D        ·     · ·)                      ⍝   }⍞000D        ·     · )⍞000D⍞000D    ...⍞000D    00000000:·dw(0 ack_ 0)      ⍝ 0 ack⍨ 0⍞000D    1⍞000D    00000000:·dw(1 ack_ 1)      ⍝ 1 ack⍨ 1⍞000D    3⍞000D    00000000:·dw(1 ack_ 2)      ⍝ 1 ack⍨ 2⍞000D    5⍞000D    00000000:·dw(2 ack_ 3)      ⍝ 2 ack⍨ 3⍞000D    29⍞000D    00000000:·dw(3 ack_ 3)      ⍝ 3 ack⍨ 3 (takes a minute or so).⍞000D    61⍞000D    00000000:·)⍞000D⍞000D(remove the ⍝ from within the first, third and forth lines to watch it working).⍞000D⍞000DFinally,  this  macro displays the sequence of prime numbers, until it is inter-⍞000Drupted:⍞000D⍞000D        primes = all=(prime 2::da'' '')+1 all         ⍝ display primes.⍞000D        ·      · da = (:''0'':''1'':''2'':''3'':''4'':''5'':''6'':''7'':''8'':''9'':(÷a da)(%a da))⍞000D        ·      · prime ⍵=(-⍵:1:(%⍵:0:prime(⍵+1)))   ⍝ ⍺ is prime?⍞000D        ·      · 2 all                              ⍝ starting from 2 ...⍞000D    ...⍞000D    00000000:·primes            ⍝ display the primes.⍞000D    2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101⍞000D⍞000DTechnical notes⍞000D---------------⍞000D[hexdump] maintains state variables, relatively global to the main command loop.⍞000DIt  commits the sin of destructive assignment, which is generally a bad thing as⍞000Dthis  introduces  "state". The presence of state makes reasoning about a program⍞000Ddifficult  and hinders code transformation. However, in this case, the alternat-⍞000Dive  would  be  to  pass  the variables among all participating functions, which⍞000Dwould make the code considerably more unwieldy.⍞000D⍞000DExtending Hexdump:⍞000D⍞000DFor  aesthetic (and pedagogic) reasons, hexdump is a pure macro processor; it is⍞000Dsurprising how much can be achieved with nothing other than simple text replace-⍞000Dment.  However, for serious use, coding macros would be considerably easier with⍞000Dthe addition of an extra primitive function or two.⍞000D⍞000DFor example,  if we want to implement a _stack_ in which to pass values as para-⍞000Dmeters, we need only add two more command lines to the loop function:⍞000D⍞000D            ''↓''≡cmd:rem ∇ vpush ⍵               ⍝⍝ ↓       push value.⍞000D            ''↑''≡cmd:rem ∇ vpop ⍵                ⍝⍝ ↑       pop value.⍞000D⍞000Dtogether with their support functions and an initialisation line:⍞000D⍞000D        vpush←{stack,⍨←⍵}                       ⍝ push value onto stack.⍞000D        vpop←{(stack↓⍨←1)⊢⊃stack,⍵}             ⍝ pop value from stack.⍞000D        stack←⍬                                 ⍝ global stack variable.⍞000D⍞000DThen:⍞000D⍞000D      hexdump_pro''''             ⍝ extended hexdump.⍞000D00000000:·50    ⍝ go 50⍞000D00000050:·↓     ⍝ push value⍞000D00000050:·80    ⍝ go 80⍞000D00000080:·↓999  ⍝ push and go 999⍞000D00000999:·↑     ⍝ pop last value (80)⍞000D00000080:·↑     ⍝ pop previous value (50)⍞000D00000050:·↑     ⍝ empty stack: pop does nothing⍞000D00000050:·)     ⍝ quit.⍞000D⍞000Dand  we  could commute the (implicit) left argument with the right argument of a⍞000Dmonadic function mfn:⍞000D⍞000D00000000:·larg ↓ rarg mfn ↑     ⍝ mfn⍨⍞000D⍞000DSome handy scripts⍞000D------------------⍞000DOpen an edit window on a new character vector using, for example:⍞000D⍞000D    )ed →script_name⍞000D⍞000Dthen cut & paste lines from the following:⍞000D⍞000D⍝─snip─here─────────────────────────────────────────────────────────────────────⍞000D⍞000Dapls=(*!%100::(*!%100 apl) +1 apls)     ⍝ APL string from file.⍞000D⍞000Dapl=(                                   ⍝ APL char translation.⍞000D    :''⌷'':''⌷'':''⍞000D             ''  :''⌷'':'' '':''⍞000C'':''⍞0006'':''⍞0007'':''⍞001B'':''⍞0009'':''⌶'':''ɫ'':''%'':'''''''':''⍺'':''⍵''⍞000D    :''_'':''a'':''b'':''c'':''d'':''e'':''f'':''g'':''h'':''i'':''j'':''k'':''l'':''m'':''n'':''o''⍞000D    :''p'':''q'':''r'':''s'':''t'':''u'':''v'':''w'':''x'':''y'':''z'':''⍞0001'':''⍞0002'':''¯'':''.'':''⍬''⍞000D    :''0'':''1'':''2'':''3'':''4'':''5'':''6'':''7'':''8'':''9'':''⍞0003'':''⊢'':''¥'':''$'':''£'':''¢''⍞000D    :''∆'':''A'':''B'':''C'':''D'':''E'':''F'':''G'':''H'':''I'':''J'':''K'':''L'':''M'':''N'':''O''⍞000D    :''P'':''Q'':''R'':''S'':''T'':''U'':''V'':''W'':''X'':''Y'':''Z'':''⍞0004'':''⍞0005'':''ý'':''·'':''''⍞000D    :''⍙'':''Á'':''Â'':''Ã'':''Ç'':''È'':''Ê'':''Ë'':''Ì'':''Í'':''Î'':''Ï'':''Ð'':''Ò'':''Ó'':''Ô''⍞000D    :''Õ'':''Ù'':''Ú'':''Û'':''Ý'':''þ'':''ã'':''ì'':''ð'':''ò'':''õ'':''{'':''⊢'':''}'':''⊣'':''⌷''⍞000D    :''¨'':''À'':''Ä'':''Å'':''Æ'':''⍨'':''É'':''Ñ'':''Ö'':''Ø'':''Ü'':''ß'':''à'':''á'':''â'':''ä''⍞000D    :''å'':''æ'':''ç'':''è'':''é'':''ê'':''ë'':''í'':''î'':''ï'':''ñ'':''['':''/'':''⌿'':''\'':''⍀''⍞000D    :''<'':''≤'':''='':''≥'':''>'':''≠'':''∨'':''∧'':''-'':''+'':''÷'':''×'':''?'':''∊'':''⍴'':''~''⍞000D    :''↑'':''↓'':''⍳'':''○'':''*'':''⌈'':''⌊'':''∇'':''∘'':''('':''⊂'':''⊃'':''∩'':''∪'':''⊥'':''⊤''⍞000D    :''|'':'';'':'','':''⍱'':''⍲'':''⍒'':''⍋'':''⍉'':''⌽'':''⊖'':''⍟'':''⌹'':''!'':''⍕'':''⍎'':''⍫''⍞000D    :''⍪'':''≡'':''≢'':''ó'':''ô'':''ö'':''ø'':''"'':''#'':''⍞001E'':''&'':''´'':''┘'':''┐'':''┌'':''└''⍞000D    :''┼'':''─'':''├'':''┤'':''┴'':''┬'':''│'':''@'':''ù'':''ú'':''û'':''^'':''ü'':''`'':''∣'':''¶''⍞000D    :'':'':''⍷'':''¿'':''¡'':''⋄'':''←'':''→'':''⍝'':'')'':'']'':''⍞001F'':''⍞00A0'':''§'':''⎕'':''⍞235E'':''⍣''⍞000D    )⍞000D⍞000D⍝─snip─here─────────────────────────────────────────────────────────────────────⍞000D⍞000Dascs=(*!%100::(*!%100 asc) +1 ascs)     ⍝ ASCII string from file.⍞000D⍞000Dasc=(                                   ⍝ ASCII char translation.⍞000D    :''⌷'':''⍞0001'':''⍞0002'':''⍞0003'':''⍞0004'':''⍞0005'':''⍞0006'':''⍞0007'':''·'':''⍞0009'':''⍞000D                                             ''  :''⌶'':''⍞000C'':''·'':''ɫ'':''^''⍞000D    :''Ø'':''É'':''Ü'':''À'':''Ö'':''Ñ'':''Æ'':''ø'':''Ä'':''Å'':''í'':''⍞001B'':''´'':''∣'':''⍞001E'':''⍞001F''⍞000D    :'' '':''!'':''"'':''#'':''$'':''%'':''&'':'''''''':''('':'')'':''*'':''+'':'','':''-'':''.'':''/''⍞000D    :''0'':''1'':''2'':''3'':''4'':''5'':''6'':''7'':''8'':''9'':'':'':'';'':''<'':''='':''>'':''?''⍞000D    :''@'':''A'':''B'':''C'':''D'':''E'':''F'':''G'':''H'':''I'':''J'':''K'':''L'':''M'':''N'':''O''⍞000D    :''P'':''Q'':''R'':''S'':''T'':''U'':''V'':''W'':''X'':''Y'':''Z'':''['':''\'':'']'':''∧'':''_''⍞000D    :''`'':''a'':''b'':''c'':''d'':''e'':''f'':''g'':''h'':''i'':''j'':''k'':''l'':''m'':''n'':''o''⍞000D    :''p'':''q'':''r'':''s'':''t'':''u'':''v'':''w'':''x'':''y'':''z'':''{'':''|'':''}'':''~'':''''⍞000D    :''⊢'':''⊣'':''⊤'':''⊥'':''←'':''→'':''↑'':''↓'':''≤'':''≥'':''⍲'':''⍱'':''⎕'':''⍞235E'':''⌹'':''⍙''⍞000D    :''⍫'':''∆'':''∇'':''⍋'':''⍒'':''⍕'':''⍎'':''⌈'':''⌊'':''⍀'':''⌿'':''⊂'':''⊃'':''∩'':''∪'':''∨''⍞000D    :''⍞00A0'':''¡'':''¢'':''£'':''⊢'':''¥'':''⌷'':''§'':''¨'':''⍝'':''⋄'':''⍬'':''≠'':''≡'':''⍪'':''¯''⍞000D    :''∘'':''○'':''⌽'':''⍉'':''⊖'':''⍟'':''¶'':''·'':''⍺'':''∊'':''⍷'':''≢'':''⍳'':''⍴'':''⍵'':''¿''⍞000D    :''└'':''Á'':''Â'':''Ã'':''┴'':''┬'':''├'':''Ç'':''È'':''┐'':''Ê'':''Ë'':''Ì'':''Í'':''Î'':''Ï''⍞000D    :''Ð'':''─'':''Ò'':''Ó'':''Ô'':''Õ'':''┼'':''×'':''┘'':''Ù'':''Ú'':''Û'':''┌'':''Ý'':''þ'':''ß''⍞000D    :''à'':''á'':''â'':''ã'':''ä'':''å'':''æ'':''ç'':''è'':''é'':''ê'':''ë'':''ì'':''│'':''î'':''ï''⍞000D    :''ð'':''ñ'':''ò'':''ó'':''ô'':''õ'':''ö'':''÷'':''┤'':''ù'':''ú'':''û'':''ü'':''ý'':''⍨'':''⍣''⍞000D    )⍞000D⍞000D⍝─snip─here─────────────────────────────────────────────────────────────────────⍞000D⍞000D⍝ display ASCII chars:⍞000D⍞000D    ch4 = ⎕dw=4                     ⍝ display 4 words ASCII⍞000D        · <ascs                     ⍝ include ascii translation.⍞000D        · ch = (*!%100'' ''asc) +1    ⍝ display char,⍞000D        · wd = '' ''ch ch ch ch       ⍝   ..    word,⍞000D        · ''         ''wd wd wd wd    ⍝   ..    line.⍞000D⍞000D⍝─snip─here─────────────────────────────────────────────────────────────────────⍞000D⍞000D⍝ display decimal equivalent of hex value:⍞000D⍞000D    dec = (:''0'':''1'':''2'':''3'':''4'':''5'':''6'':''7'':''8'':''9'':(÷a dec)(%a dec))⍞000D⍞000D⍝ set hex equivalent of decimal value:⍞000D⍞000D    hex =⍞000D         . = ÷10 sub × a +⍞000D         sub = (::(%10:.0:.1:.2:.3:.4:.5:.6:.7:.8:.9))⍞000D         sub⍞000D⍞000D⍝─snip─here─────────────────────────────────────────────────────────────────────⍞000D⍞000D⍝ display current value in hex:⍞000D⍞000D    $ = (:''0'':''1'':''2'':''3'':''4'':''5'':''6'':''7'':''8'':''9'':''a'':''b'':''c'':''d'':''e'':''f'':(÷10$)(%10$))⍞000D⍞000D⍝─snip─here─────────────────────────────────────────────────────────────────────⍞000D⍞000DExamples:⍞000D                                                                │Notes⍞000D      hexdump ⎕wsid,''.dws''                      ⍝ dump this WS  │⍞000D00000000:·050903aa 80050009 02310050 fffc3c45·                  │⍞000D00000010:·00000060 000019c0 00000000 02432f9b·''message''         │display msg.⍞000Dmessage                                                         │⍞000D00000010:·00000060 000019c0 00000000 02432f9b·                  │⍞000D00000020:·00000000 00000000 00000000 00000000·                  │⍞000D00000030:·00000000 02432cdd 00000000 00000000·0 ''''              │go 0.⍞000D                                                                │⍞000D00000000:·050903aa 80050009 02310050 fffc3c45·18c-(8*)⊥         │set base.⍞000D0000018c:·fffffff9 00000003 00003121 023141f8·⎕dw=2             │reduce width.⍞000D0000018c:·fffffff9 00000003·lft = +0c*  ⍝ follow left subtree   │define,⍞000D0000018c:·fffffff9 00000003·rgt = +10*  ⍝ follow right subtree  │   macros.⍞000D0000018c:·fffffff9 00000003·⎕dw=5                               │increase width.⍞000D0000018c:·fffffff9 00000003 00003121 023141f8 00000000·lft      │follow left.⍞000D00004334:·fffffff9 00000004 00004001 023123e8 02314d38·lft      │⍞000D00002524:·fffffff8 00000003 00000001 02315218 023152d0·rgt      │follow right.⍞000D0000540c:·fffffff9 00000003 00000001 02317210 02313a0c·rgt      │⍞000D00003b48:·fffffff9 00000003 00000001 0231546c 02315b80·?        │show help.⍞000D  hex   relative file posn.                                     │⍞000D+ hex   add.                                                    │⍞000D- hex   subtract.                                               │⍞000D× hex   multiply.                                               │⍞000D÷ hex   integer divide.                                         │⍞000D% hex   integer remainder.                                      │⍞000D*       get word from file.                                     │⍞000D← hex   put word to file.                                       │⍞000D!       absolute position.                                      │⍞000D: case  select case.                                            │⍞000D(       call.                                                   │⍞000D)       return.                                                 │⍞000D⊥       set base.                                               │⍞000D''···''   display message.                                        │⍞000D⍝       comment.                                                │⍞000D?       help.                                                   │⍞000D⊤       trace on/off.                                           │⍞000D< var   include subscript.                                      │⍞000Dname=·· define macro.                                           │⍞000D00003b48:·fffffff9 00000003 00000001 0231546c 02315b80·0!⊥''''    │reset base = 0.⍞000D                                                                │⍞000D00000000:·050903aa 80050009 02310050 fffc3c45 00000060·1234     │absolute addr.⍞000D00001234:·0000c801 0231c8e8 02311894 02311108 fffffffb·         │⍞000D00001248:·00000001 0000001f 00000003 00604010 fffffff8·)        │quit.⍞000D⍞000D⍝ Macro definitions may be included in the left argument command stream:⍞000D⍞000D      ''tlx=14*'' hexdump ''comp.dcf''                      ⍝ component file dump.⍞000D00000000:·000901aa 00000002 00000001 00000001·⍞000D00000010:·0000001b 00000234 00000000 00000000·tlx       ''top level index''⍞000Dtop level index⍞000D00000234:·0000004c 000001f4 00000000 00000000·⍞000D00000244:·00000000 00000000 00000000 00000000·⍞000D00000254:·00000000 00000000 00000000 00000000·⍞000D00000264:·00000000 00000000 00000000 00000000·tlx*      ''second level index''⍞000Dsecond level index⍞000D0000004c:·00000000 00000034 0000008c 000000a4·⍞000D0000005c:·000000bc 000000d4 000000ec 00000104·⍞000D0000006c:·0000011c 00000134 0000014c 00000164·⍞000D0000007c:·0000017c 00000194 000001ac 000001c4·tlx*+4*   ''first component''⍞000Dfirst component⍞000D00000034:·0000000c 41166bcd 00000000 00000004·⍞000D0000007c:·0000017c 00000194 000001ac 000001c4·tlx*+8*   ''second component''⍞000Dsecond component⍞000D0000008c:·0000000c 41166bcd 00000000 00000004·⍞000D0000007c:·0000017c 00000194 000001ac 000001c4·tlx*+c*   ''third component''⍞000Dthird component⍞000D000000a4:·0000000c 41166bcd 00000000 00000004·⍞000D000000b4:·0000000f 00000043 0000000c 41166bcd·)⍞000D⍞000D⍝ The following vector might be used by Dyalog developers⍞000D⍝ to analyse the state indicator in an aplcore file:⍞000D⍞000D      display stack⍞000D┌→──────────────────────────────────────────────────────────────────────────────────┐⍞000D│⍝ Examine aplcore stack                                                            │⍞000D│                                                                                   │⍞000D│    10*×4+c-(8*)⊥                   ⍝ Set WS bias                                  │⍞000D│                                                                                   │⍞000D│⍝ Stack                                                                            │⍞000D│                                                                                   │⍞000D│    n         =   +c*               ⍝ next frame                                   │⍞000D│    shad      = ( _shad +14         ⍝ call shadow block                            │⍞000D│    sname     = ( _sym +0*          ⍝ call shadow name                             │⍞000D│    svalue    = ( _gen +4*          ⍝ call shadow value                            │⍞000D│                                                                                   │⍞000D│⍝ Symbol                                                                           │⍞000D│                                                                                   │⍞000D│    lft   = ( _sym +c*              ⍝ call left subtree                            │⍞000D│    rgt   = ( _sym +10*             ⍝ call right subtree                           │⍞000D│    val   = ( _gen +14*             ⍝ call value                                   │⍞000D│                                                                                   │⍞000D│⍝ Cols and annotation by type:                                                     │⍞000D│                                                                                   │⍞000D│    _sym  = ⎕dw=8    ''symbol:                              left     right    value''│⍞000D│    _shad = ⎕dw=3    ''shadow:   sname    svalue   class''                           │⍞000D│    _gen  = ⎕dw=8                                                                  │⍞000D│                                                                                   │⍞000D│ ⎕dw=3  94!+c*                       ⍝ top of stack.                               │⍞000D└───────────────────────────────────────────────────────────────────────────────────┘⍞000D⍞000D      stack hexdump ''aplcore''               ⍝ examine stack:⍞000D000e55d8:·ffffffec 00000001 00003085·n⍞000D000e5570:·ffffffe6 00000001 00004005·n⍞000D000e554c:·fffffff7 00000001 00005385·n⍞000D000e5520:·fffffff5 00000001 00005475·n⍞000D000e54a4:·fffffff9 00000001 00006005·n⍞000D000e543c:·ffffffec 00000001 00003095·n⍞000D000e53d4:·ffffffe6 00000001 00004005·shad⍞000Dshadow:   sname    svalue   class⍞000D000e53e8:·02323270 00000000 00000000··⍞000D000e53f4:·02323250 00000000 00000000··⍞000D000e5400:·02311cc4 00000000 00000000··⍞000D000e540c:·02311ce4 00000000 00000000··⍞000D000e5418:·02311d44 00000000 00000000··⍞000D000e5424:·02311d24 0237c8d4 00000002··svalue⍞000D0006ca10:·fffffff8 00000005 00000627 00000001 00000003 02312084 0237c89c 0237c790···)⍞000D000e5424:·02311d24 0237c8d4 00000002··sname⍞000Dsymbol:                              left     right    value⍞000D00001e60:·fffffff8 00000009 00002001 02323270 02311d44 0237c89c 22202815 1d221f00···val⍞000D0006c9d8:·fffffff2 00000004 00000627 00000001 00000009 023121e4 0237c7b0 0237c7d0····(+14*⍞000D00002320:·fffffffc 00000003 0000000f 000000a6 fffffffa 00000003 0000c001 023242b8·····)))⍞000D000e5424:·02311d24 0237c8d4 00000002··⍞000D000e5430:·02311d04 0236f1b0 00000002··svalue⍞000D0005f2ec:·ffffd973 00000004 00000627 000009a2 00000004 0235a440 0235a334 0235a4b0···)⍞000D000e5430:·02311d04 0236f1b0 00000002··⍞000D000e543c:·ffffffec 00000001 00003095··)⍞000D000e53d4:·ffffffe6 00000001 00004005·n⍞000D0006cd0c:·fffffff7 00000001 00002015·n⍞000D0006ccbc:·ffffffec 00000001 00003095·n⍞000D0006cc84:·fffffff2 00000001 00004005·n⍞000D0006cc64:·fffffff8 00000001 00005455·n⍞000D0006cc4c:·fffffffa 00000001 000058a5·)⍞000D⍞000DSee also: hex osc traj⍞000D⍞000DIndex:hexadecimal|macro|native file|assignment, destructive|endian|offside rule⍞000DIndex:Ackermann''s function|prime number|white dots|REPL⍞000DIndex;Ackermann W.' 
