'rslt ← {cmp←1} ##.pack4 image               ⍝ Quad-tree packing.⍞000D⍞000DQuad-trees  are normally used to compress 2-dimensional data such as bitmaps (or⍞000Ddigital television images?). However, the technique generalises nicely to arrays⍞000Dof any rank. For compression, the function takes, as right argument, an array to⍞000Dbe compressed and returns an encoded quad-tree as result.⍞000D⍞000DLeft argument [cmp] specifies:⍞000D⍞000D⍺=1: [default] Full-precision compression of array right argument "image".⍞000D⍺=0: Expansion of right argument to reconstitute the original image.⍞000D⍺>1: Part-precision compression, stops when array has only ⍺ distinct items.⍞000D⍞000DThe underlying idea is simple: the compression is:⍞000D⍞000D    If all items of the array are identical, then that item.⍞000D    Otherwise, the recursive compression of 2*⍴⍴⍵ subarray "quadrants".⍞000D⍞000DFor roughly "square" arrays, such as TV screen  images,  this  quartering  works⍞000Dwell but in general, where axes may be of very different lengths, a better  sec-⍞000Dond rule is:⍞000D⍞000D    Otherwise, the  recursive  compression of each of the pair of subarrays that⍞000D    result from splitting the array along its longest axis.⍞000D⍞000DQuad-tree packing works best for arrays that contain significant regions of  id-⍞000Dentical adjacent values.  For more irregular arrays, the technique is poor owing⍞000Dto the overhead of keeping track of small regions.  A good bet for Rothko; a bad⍞000Dbet for Pollock.⍞000D⍞000DTechnical notes:⍞000D⍞000DThe compressed form is the triple:⍞000D⍞000D    uniq:  A vector of the unique items of array ⍵.⍞000D    shape: Shape of the subject array.⍞000D    subs:  A sequence of "sub" records, where a sub is either:⍞000D           - an atom representing a subarray of identical items or⍞000D           - a pair of subs, introduced by a ¯1 marker: (¯1, sub, sub)⍞000D⍞000DThe result is further compressed by replacing ¯1 ¯1 .. ¯1 with ¯⍵.⍞000D                                              └────⍵────┘⍞000D⍞000DNotice that it is not necessary to encode the _shapes_ of  compressed  subarrays⍞000Din the compression stream. This is because the array-splitting is completely de-⍞000Dtermined by the shape of the original subject array and so can  be  inferred  at⍞000Deach stage of decompression. The only  additional packing overhead is a ¯1 mark-⍞000Der, which distinguishes a "sub" from an "atom".⍞000D⍞000DNote the technique ↑{⍺ ⍵}/ of converting the stream vector to a push-down "list"⍞000Dfor decompression. This makes reading the stream, one item at  a  time,  quicker⍞000Dand more pleasant. See →list← for more on this technique.⍞000D⍞000DExamples:⍞000D⍞000D    ⎕←vec←10 20/''ab''            ⍝ vector of a''s and b''s.⍞000Daaaaaaaaaabbbbbbbbbbbbbbbbbbbb⍞000D⍞000D    0 pack4 pack4 10 20/''ab''    ⍝ round-trip⍞000Daaaaaaaaaabbbbbbbbbbbbbbbbbbbb⍞000D⍞000D    pack4 10 20/''ab''            ⍝ packed structure.⍞000D┌──┬──┬────────────────────┐⍞000D│ab│30│¯2 0 ¯2 0 ¯1 0 1 1 1│⍞000D└──┴──┴────────────────────┘⍞000D⍞000D    chk←{⍵≡0 pack4 pack4 ⍵}     ⍝ check round-trip⍞000D⍞000D    chk 10 20/''ab''⍞000D1⍞000D    ⎕←image←⌊0.5×∘.⌊⍨0 to 7     ⍝ 2D image⍞000D0 0 0 0 0 0 0 0⍞000D0 0 0 0 0 0 0 0⍞000D0 0 1 1 1 1 1 1⍞000D0 0 1 1 1 1 1 1⍞000D0 0 1 1 2 2 2 2⍞000D0 0 1 1 2 2 2 2⍞000D0 0 1 1 2 2 3 3⍞000D0 0 1 1 2 2 3 3⍞000D⍞000D    pack4 image⍞000D┌───────┬───┬────────────────────────────────────────────┐⍞000D│0 1 2 3│8 8│¯3 0 ¯1 0 1 ¯1 0 1 ¯3 0 1 ¯1 0 1 ¯1 2 ¯1 2 3│⍞000D└───────┴───┴────────────────────────────────────────────┘⍞000D⍞000D    mm←⎕fmt notes.Marilyn       ⍝ larger 2D ASCII-image →Marilyn←⍞000D⍞000D    chk mm                      ⍝ check round-trip.⍞000D1⍞000D    size←{⎕size''⍵''}             ⍝ byte-size of ⍵.⍞000D⍞000D    size mm                     ⍝ size of unpacked array.⍞000D11300⍞000D    size pack4 mm               ⍝ size of full-precision packed array.⍞000D9176⍞000D    size 2 pack4 mm             ⍝ size of reduced-resolution packed array.⍞000D3556⍞000D⍞000D    ⍝ diminishing sizes of decreasing-resolution packings:⍞000D⍞000D    {pk←⍵ pack4 mm ⋄ ⍬⍴⎕size''pk''}¨ 1 to 16⍞000D9176 3556 2068 1252 844 624 432 324 260 216 188 140 128 124 108 100⍞000D⍞000D⍝ This little function shows the effect of successively refined packing. After⍞000D⍝ popping up a blank-screen edit window, there is a delay of a couple of seconds⍞000D⍝ to give you time to maximise the window before the show starts:⍞000D⍞000D    movie←{                         ⍝ Increasingly refined image ⍵.⍞000D        show←{screen∘←(pk dl 1)⍵}   ⍝ show image.⍞000D        pk←{0 pack4 ⍵ pack4 image}  ⍝ ⍵-resolution image.⍞000D        dl←{(⎕DL ⍵⍵)⊢⍺⍺ ⍵}          ⍝ apply ⍺⍺ ⍵ then delay ⍵⍵.⍞000D        screen←{''·''}¨image←⍵        ⍝ blank screen.⍞000D        _←(⎕ED dl 2)''screen''        ⍝ window on image.⍞000D        1:_←(show¨dl 4)⌽⍳⍴∪,⍵       ⍝ show movie.⍞000D    }⍞000D⍞000D    movie ⎕fmt notes.Marilyn        ⍝ show movie.⍞000D⍞000D⍝ It works best if you reduce the session font size so that the whole⍞000D⍝ image is visible in the edit window:⍞000D⍞000D    pix←{                   ⍝ Apply ⍺⍺ ⍵ with font-size ⍵⍵.⍞000D        save←⎕SE.FontObj    ⍝ save current font settings.⍞000D        (2⊃⎕SE.FontObj)←⍵⍵  ⍝ set font size.⍞000D        rslt←⍺⍺ ⍵           ⍝ apply function.⍞000D        ⎕SE.FontObj←save    ⍝ restore font settings.⍞000D        1:_←rslt            ⍝ shy result of ⍺⍺ ⍵.⍞000D    }⍞000D⍞000D    movie pix 10 ⎕fmt notes.Marilyn     ⍝ show movie in 10-pixel font.⍞000D⍞000DSee also: Data_compression list Marilyn⍞000DIndex:packing|compression|quad-tree⍞000DIndex;Rothko M.|Pollock J.|Monroe M.' 
