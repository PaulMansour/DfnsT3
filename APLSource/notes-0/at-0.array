'rslt ← {new} (mod ##.at sel) old        ⍝ item substitution: new at sel in old⍞000D⍞000D[sel]ected items of [old] are [mod]ified with those in [new] to produce [rslt].⍞000D⍞000D    10(× at 2 4)⍳5              ⍝ ten-fold at 2nd and 4th items in 1..5⍞000D1 20 3 40 5⍞000D⍞000D    ⌽ at(2+⍳4) ⊢''redrawing''     ⍝ reversal of section of character vector⍞000Drewarding⍞000D⍞000DThe [sel]ection operand can be one of:⍞000D⍞000D- A simple numeric array of indices along the first axis, as above, or a⍞000D- A nested array of choose/reach indices, or a⍞000D- A monadic function which, when applied to [old], returns a Boolean mask:⍞000D⍞000D    ''*'' ⊣at(<∘0) 3 ¯1 4 1 ¯5        ⍝ function operand: stars for -ive values⍞000D3 * 4 1 *⍞000D⍞000D    (⊂''fizz'')⊣at{0=3|⍵} ⍳10         ⍝ "fizz" at every 3rd number⍞000D┌─┬─┬────┬─┬─┬────┬─┬─┬────┬──┐⍞000D│1│2│fizz│4│5│fizz│7│8│fizz│10│⍞000D└─┴─┴────┴─┴─┴────┴─┴─┴────┴──┘⍞000D⍞000DBackground⍞000D----------⍞000DClassic APL lacks a general, non-procedural  way to express the "triadic" funct-⍞000Dion: "THESE items at THOSE positions in THIS array".  For example: "Asterisks at⍞000Dthe vowel positions in the alphabet". Rather,  it  compels  us  to use a 3-stage⍞000D_procedure_  and requires us to name an intermediate subject array:⍞000D⍞000D    [1] Name the subject array,                 ⍝ THIS ← ...⍞000D    [2] Mutate the array, using its name,       ⍝ THIS[THOSE]←THESE⍞000D    [3] Dereference the name for the result.    ⍝ ... THIS⍞000D⍞000D(muse:⍞000D⍞000D    Ideally, the language should not force us into naming the results of expr-⍞000D    essions merely for reasons of syntax. Better that we choose to name things⍞000D    only in order to create mental abstractions that are easier to comprehend.⍞000D⍞000D    Sound bite: "Names let us chop up our programs into mind-sized chunks."⍞000D⍞000D    As an example, the following three code fragments are equivalent and each⍞000D    reducible by the language evaluator to the syntax tree on the right. Ideal-⍞000D    ly, the choice should depend only on the perceived simplicity of expression.⍞000D⍞000D    (+⌿⍵)÷≢⍵                                    ⍝⍞000D                                                ⍝        ┌───┼─┐⍞000D    sum←+⌿⍵ ⋄ num←≢⍵  ⋄ sum÷num                 ⍝        ├─┐ ÷ ├─┐⍞000D                                                ⍝      ┌─┤ ⍵   ≢ ⍵⍞000D    sum←+⌿ ⋄ num←≢ ⋄ (sum ⍵)÷num ⍵              ⍝      + ⌿⍞000D⍞000D    This approach differs from that of "variable-centric" languages, where names⍞000D    must be declared to reserve storage locations and otherwise participate in⍞000D    the mechanics of evaluation.⍞000D)⍞000D⍞000DTechnical notes:⍞000D⍞000D1. Internally [at] uses regular indexed assignment:⍞000D⍞000D        A⊣A[indx]←⍺ ⍺⍺(A←⍵)[indx]       ⍝ nb: duplicate indices ignored⍞000D⍞000D   in preference to the shorter _modified_ indexed assignment:⍞000D⍞000D        A⊣A[indx]←⍺⍺⍨←⍺⊣A←⍵             ⍝ (not used)⍞000D⍞000D   in order for the _whole_ of the selected sub-array, rather than just one item⍞000D   at a time, to be presented to  the  [mod]ification function ⍺⍺.  This allows,⍞000D   for example, operations on whole rows:⍞000D⍞000D        1 ⌽at 2 ⊢3 5⍴⍳15                ⍝ 1-rotation of middle row.⍞000D     1  2  3  4  5⍞000D     7  8  9 10  6⍞000D    11 12 13 14 15⍞000D⍞000D2. In the case where the  [sel]ection operand is a (Boolean-returning) function,⍞000D   the  ravel  of  the mask selects from the ravel of the right argument''s index⍞000D   array.⍞000D⍞000D        ''*''⊣at(∊∘''AEIOU'') 5 5⍴⎕A        ⍝ stars for vowels in char matrix⍞000D    *BCD*⍞000D    FGH*J⍞000D    KLMN*⍞000D    PQRST⍞000D    *VWXY⍞000D⍞000D3. This simple model claims only to be adequate for experimentation. An industr-⍞000D   ial strength version would need to add:⍞000D⍞000D - Better error messages. In particular indication of whether a problem has occ-⍞000D   urred with the left (modifier) or right (selection) operand.⍞000D⍞000D - Defence  against  the possibility of a nameclash between at''s local names and⍞000D   those of its operand functions.⍞000D⍞000D   Examples of such coding can be found towards the end of: ##.scripts.at⍞000D⍞000DExamples:⍞000D⍞000D    ''*''⊣at 2 4 ⊢5↑⎕A            ⍝ ''*'' at 2nd and 4th items⍞000DA*C*E⍞000D⍞000D    M ← 5 5⍴ ⍳25                ⍝ 5×5 numeric matrix⍞000D⍞000D    0 ⊣at 2 4 ⊢M                ⍝ 0 at 2nd and 4th rows⍞000D 1  2  3  4  5⍞000D 0  0  0  0  0⍞000D11 12 13 14 15⍞000D 0  0  0  0  0⍞000D21 22 23 24 25⍞000D⍞000D    (2 5⍴⎕a) ⊣at 2 4 ⊢M         ⍝ A..J at 2nd and 4th rows⍞000D 1  2  3  4  5⍞000D A  B  C  D  E⍞000D11 12 13 14 15⍞000D F  G  H  I  J⍞000D21 22 23 24 25⍞000D⍞000D    0 ⊣at 2 4⍤1 ⊢M              ⍝ 0 at 2nd and 4th cols⍞000D 1 0  3 0  5⍞000D 6 0  8 0 10⍞000D11 0 13 0 15⍞000D16 0 18 0 20⍞000D21 0 23 0 25⍞000D⍞000D    (⍉2 5⍴⎕a)⊣ at 2 4⍤1 ⊢M      ⍝ A..J at 2nd and 4th cols⍞000D 1 A  3 F  5⍞000D 6 B  8 G 10⍞000D11 C 13 H 15⍞000D16 D 18 I 20⍞000D21 E 23 J 25⍞000D⍞000D    0 ⊣at 2 3 4⍤1 at 2 3 4 ⊢M   ⍝ cf: M[2 3 4;2 3 4]←0      nested [at]s⍞000D 1  2  3  4  5⍞000D 6  0  0  0 10⍞000D11  0  0  0 15⍞000D16  0  0  0 20⍞000D21 22 23 24 25⍞000D⍞000D    (2 2⍴⎕A)⊣at(1 5∘.,1 5) ⊢M   ⍝ cf: M[1 5;1 5]←2 2⍴⎕A     choose indexing⍞000D A  2  3  4  B⍞000D 6  7  8  9 10⍞000D11 12 13 14 15⍞000D16 17 18 19 20⍞000D C 22 23 24  D⍞000D⍞000D    ⌽ at 2 4 ⊢M                 ⍝ reverse of 2nd and 4th row (boustrophedon)⍞000D 1  2  3  4  5⍞000D10  9  8  7  6⍞000D11 12 13 14 15⍞000D20 19 18 17 16⍞000D21 22 23 24 25⍞000D⍞000D    ''⍟''⊣at(1 5)(2 2)⊢''hello'' ''world''        ⍝ reach⍞000D┌─────┬─────┐⍞000D│hell⍟│w⍟rld│⍞000D└─────┴─────┘⍞000D⍞000D    10×at 2 4 ⍳5                ⍝ 10× at ...⍞000D1 20 3 40 5⍞000D⍞000D    10×at 2 2 ⍳5                ⍝ nb: dups ignored⍞000D1 20 3 4 5⍞000D⍞000D⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝ boolean selection:⍞000D⍞000D    ''*''⊣at(∊∘''AEIOU'') ⎕A        ⍝ vowels⍞000D*BCD*FGH*JKLMN*PQRST*VWXYZ⍞000D⍞000D    100×at(2∘|)⍤1 ⊢M            ⍝ alternately × 100⍞000D 100    2  300    4  500⍞000D   6  700    8  900   10⍞000D1100   12 1300   14 1500⍞000D  16 1700   18 1900   20⍞000D2100   22 2300   24 2500⍞000D⍞000D    {∊¨(0=3 5∘|¨⍵)/¨⊂''fizz'' ''buzz''}at{0∨.=3 5∘.|⍵}⍤1 ⊢3 4 5⍴⍳60⍞000D┌────┬────┬────┬────┬────────┐⍞000D│1   │2   │fizz│4   │buzz    │⍞000D├────┼────┼────┼────┼────────┤⍞000D│fizz│7   │8   │fizz│buzz    │⍞000D├────┼────┼────┼────┼────────┤⍞000D│11  │fizz│13  │14  │fizzbuzz│⍞000D├────┼────┼────┼────┼────────┤⍞000D│16  │17  │fizz│19  │buzz    │⍞000D└────┴────┴────┴────┴────────┘⍞000D┌────┬────┬────┬────┬────────┐⍞000D│fizz│22  │23  │fizz│buzz    │⍞000D├────┼────┼────┼────┼────────┤⍞000D│26  │fizz│28  │29  │fizzbuzz│⍞000D├────┼────┼────┼────┼────────┤⍞000D│31  │32  │fizz│34  │buzz    │⍞000D├────┼────┼────┼────┼────────┤⍞000D│fizz│37  │38  │fizz│buzz    │⍞000D└────┴────┴────┴────┴────────┘⍞000D┌────┬────┬────┬────┬────────┐⍞000D│41  │fizz│43  │44  │fizzbuzz│⍞000D├────┼────┼────┼────┼────────┤⍞000D│46  │47  │fizz│49  │buzz    │⍞000D├────┼────┼────┼────┼────────┤⍞000D│fizz│52  │53  │fizz│buzz    │⍞000D├────┼────┼────┼────┼────────┤⍞000D│56  │fizz│58  │59  │fizzbuzz│⍞000D└────┴────┴────┴────┴────────┘⍞000D⍞000D⍝ Roger Hui''s model of "Mesh" and "Mask", implemented using [at]:⍞000D⍞000D⍝ Mesh (APL, 1962) -------------------------------------------------------------⍞000D⍞000D⍝   c ← a (u Mesh) b    ←→    ((~u)⌿c)≡a and (u⌿c)≡b⍞000D⍞000D    ⎕io ← 0⍞000D    a ← 33 44 55⍞000D    b ← ⍳10⍞000D    u ← 1 1 0 1 1 1 1 0 1 1 1 0 1⍞000D⍞000D    ↑ u (b ⊣at(u⊣⊣) (~u)⍀a)⍞000D1 1  0 1 1 1 1  0 1 1 1  0 1⍞000D0 1 33 2 3 4 5 44 6 7 8 55 9⍞000D⍞000D    c ← b ⊣at(u⊣⊣) (~u)⍀a⍞000D    a ≡ (~u)⌿c⍞000D1⍞000D    b ≡ u⌿c⍞000D1⍞000D    c ≡ b ⊣at(u/⍳≢u) ⊢(~u)⍀a⍞000D1⍞000D⍞000D⍝ The last version with the integer right operand is required for meshing major⍞000D⍝ cells.⍞000D⍞000D      a ← 2⍴⍤0 ⊢33 44 55⍞000D      b ← 2⍴⍤0⍳10⍞000D      c ← b ⊣at(u/⍳≢u) ⊢(~u)⍀a⍞000D      a ≡ (~u)⌿c⍞000D1⍞000D      b ≡ u⌿c⍞000D1⍞000D⍞000D⍝ Mask (APL, 1962) -------------------------------------------------------------⍞000D⍞000D⍝   c ← a (u Mask) b    ←→    ((~u)⌿c)≡(~u)⌿a and (u⌿c)≡u⌿b⍞000D⍞000DFor numeric vectors a and b,⍞000D⍞000D    a ← ⍳13⍞000D    b ← 20+⍳13⍞000D    u ← 13⍴0 0 1⍞000D    c ← (a×~u) + b×u⍞000D⍞000D    ↑ u (b (u⌿⊣)at(u⊣⊣) a)⍞000D0 0  1 0 0  1 0 0  1 0  0  1  0⍞000D0 1 22 3 4 25 6 7 28 9 10 31 12⍞000D⍞000D    c ← b (u⌿⊣)at(u⊣⊣) a⍞000D    ((~u)⌿c) ≡ (~u)⌿a⍞000D1⍞000D    (u⌿c)≡u⌿b⍞000D1⍞000D    c ≡ b (u⌿⊣)at(u/⍳≢u) ⊢a⍞000D1⍞000D⍞000D⍝ Roger says: again, the last version with the integer right operand is⍞000D⍝ required for masking major cells.⍞000D⍞000D    a ← 2⍴⍤0 ⊢⍳13⍞000D    b ← 2⍴⍤0 ⊢20+⍳13⍞000D    c ← b (u⌿⊣)at(u/⍳≢u) ⊢a⍞000D    ((~u)⌿c) ≡ (~u)⌿a⍞000D1⍞000D    (u⌿c)≡u⌿b⍞000D1⍞000D⍞000D⍝ Here is how the inner "Gaussian elimination" function from →gauss_jordan←⍞000D⍝ might look when converted from a procedural style, which mutates the matrix⍞000D⍝ in two places:⍞000D⍞000D    elim←{                                  ⍝ elimination of row/col ⍺.⍞000D        mat←⍵                               ⍝ name matrix for updating.⍞000D        p←⍺+{⍵⍳⌈/⍵}|⍺↓mat[;⍺]               ⍝ index of pivot row.⍞000D        mat[⍺ p;]←mat[p ⍺;]                 ⍝ exchange ⍺th and pth rows.    !!⍞000D        mat[⍺;]÷←mat[⍺;⍺]                   ⍝ reduce col diagonal to 1.     !!⍞000D        mat-(mat[;⍺]×⍺≠⍳⊃⍴⍵)∘.×mat[⍺;]      ⍝ reduce col off-diagonals to 0.⍞000D    }⍞000D⍞000D⍝ ... to a functional definition using [at], which does not. To better show the⍞000D⍝ impact of a _primitive_ operator, the glyph "@" has abitrarily been chosen to⍞000D⍝ represent [at] in these coding examples:⍞000D⍞000D    elim←{                                  ⍝ elimination of row/col ⍺.⍞000D        p←⍺+{⍵⍳⌈/⍵}|⍺↓⍵[;⍺]                 ⍝ index of pivot row.⍞000D        swap←⊖@⍺ p⊢⍵                        ⍝ ⍺th and pth rows exchanged.   !⍞000D        mat←swap[⍺;⍺]÷⍨@⍺⊢swap              ⍝ col diagonal reduced to 1.    !⍞000D        mat-(mat[;⍺]×⍺≠⍳⊃⍴⍵)∘.×mat[⍺;]      ⍝ col off-diagonals reduced to 0.⍞000D    }⍞000D⍞000D⍝ and here''s the same indexed-assignment replacement for function →span←⍞000D⍞000D    span←{                      ⍝ Spanning tree for graph ⍺ from vertex(ices) ⍵.⍞000D        graph←⍺                 ⍝ ⍺ is graph vector.⍞000D        tree←¯2+(⍳⍴⍺)∊⍵         ⍝ initial spanning tree.⍞000D        free←{(¯2=tree[⍵])/⍵}   ⍝ free vertices in ⍵.⍞000D        {                       ⍝ visit adjacent vertices:⍞000D            ⍵≡⍬:tree            ⍝ no vertices: done.⍞000D            next←free¨graph[⍵]  ⍝ next vertices to visit.⍞000D            back←↑,/⍵+0×next    ⍝ back links.⍞000D            wave←↑,/next        ⍝ wave front.⍞000D            tree[wave]←back     ⍝ set back links in tree        !!⍞000D            ∇ ∪wave             ⍝ advance wave front.⍞000D        }⍵                      ⍝ from starting vertex.⍞000D    }⍞000D⍞000D⍝ which becomes:⍞000D⍞000D    span←{                        ⍝ Spanning tree for graph ⍺ from vertex(ices).⍞000D        graph←⍺                   ⍝ ⍺ is graph vector.⍞000D        tree←¯2+(⍳⍴⍺)∊⍵           ⍝ initial spanning tree.⍞000D        free←{(¯2=⍺[⍵])/⍵}        ⍝ free vertices in ⍵.                 !⍞000D        tree{                     ⍝ ⍺: partial spanning tree.           !⍞000D            ⍵≡⍬:⍺                 ⍝ no vertices: done.                  !⍞000D            next←⍺∘free¨graph[⍵]  ⍝ next vertices to visit.             !⍞000D            back←↑,/⍵+0×next      ⍝ back links.⍞000D            wave←↑,/next          ⍝ wave front.⍞000D            part←back⊣@wave⊢⍺     ⍝ back links at wave front            !⍞000D            part ∇ ∪wave          ⍝ partial tree; advanced wave front   !⍞000D        }⍵                        ⍝ ⍵: next wave of vertices to visit.⍞000D    }⍞000D⍞000D⍝ Finally, here are some more code snippets from this workspace, which might be⍞000D⍝ improved with the introduction of a primitive @ (say) operator. The lines are⍞000D⍝ marked: <old and >new:⍞000D⍞000D<dots[11-14] dmask←,2=flood-xdents ⋄ crep←⍵ ⋄ crep[dmask/,⍳⍴⍵]←⍺ ⋄ crep⍞000D>dots[11]    ⍺⊣@{2=flood-xdents}⍵⍞000D⍞000D<packZ[14]  tree←⍵ ⋄ tree[posn]←⊂sub⍞000D>packZ[14]  tree←(⊂sub)⊣@posn⊢⍵⍞000D⍞000D<remlink[1-2] graph←⍺ ⋄ fm to←⍵ ⋄ graph⊣(fm⊃graph)~←to⍞000D>remlink[1-2]           fm to←⍵ ⋄ ~∘to¨@fm⊢⍺⍞000D⍞000D<ssword[5-7] cvex←⍺ words srce ⋄ mask←cvex∊⊂find ⋄ ∊cvex⊣(mask/cvex)←⊂repl⍞000D>ssword[7]   ∊(⊂repl)⊣@{⍵∊⊂find}⍺ words srce⍞000D⍞000D<sudoku[30] ⍵∘{m←⍺ ⋄ (i⊃m)←,⍵ ⋄ m}¨i⊃⍵⍞000D>sudoku[30] (i⊃⍵)⊣@i¨⊂⍵⍞000D⍞000D<notes.sudoku[242 244] pvec←{(⍺ avl ⍵)(⍺ at)¨⊂⍵} ⋄ at←{⍵+⍺×(⍳⍴⍵)∊⊂⍺⍺}⍞000D>notes.sudoku[242]     pvec←{(⍺ avl ⍵)⊣@(⊂⍺)¨⊂⍵}⍞000D⍞000D<von[27] (b/tx)←ucase b/tx ⋄ ¯1↓tx⍞000D>von[27] ¯1↓ucase@{b}tx⍞000D⍞000D<wsdiff[38-39] mask←,(⍵='' '')∧(⍴⍵)⍴cols⍴4↑1 ⋄ mat←⍵ ⋄ mat⊣(mask/,mat)←''·''⍞000D>wsdiff[38]    ''·''⊣@{(⍵='' '')∧(⍴⍵)⍴cols⍴4↑1}⍵⍞000D⍞000DSee also: sam⍞000D⍞000DIndex:assignment, indexed|assignment, destructive|assignment, selective⍞000DIndex:boustrophedon|merge|mask|mesh⍞000DIndex;Hui R.K.W.|Hsu A.|Last P.' 
