'rslt ← {larg)(op ##.avl) rarg           ⍝ Adelson-Velskii, Landis (AVL) trees.⍞000D⍞000D     T∆ ← T ∪ avl (key val)     ⍝ tree ⍺ with key=val ⍵.⍞000D     T∆ ← T ~ avl key           ⍝ tree ⍺ without key ⍵.⍞000D     T∆ ← T ⍎ avl key           ⍝ value for key ⍵ in tree ⍺.⍞000D    fmt ←   ⍕ avl T             ⍝ format of tree ⍵.⍞000D    vec ←   ∊ avl T             ⍝ enlist of tree ⍵.⍞000D    chk ←   ? avl T             ⍝ stats for tree ⍵: ok size mean_depth height.⍞000D⍞000DSee →BST←⍞000D⍞000DAn  AVL  tree is a binary search tree in which subtree heights differ by no more⍞000Dthan 1.⍞000D⍞000DAVL  trees  do not guarantee minimal height. In the following diagram, the nodes⍞000Dare  marked  with  their  height  (maximum distance to a leaf). For example, B↓2⍞000Dsignifies  a node with search key ''B'' and height 2. Notice that sibling subtrees⍞000Ddiffer in height by at most 1:⍞000D⍞000D    Height 4 AVL tree       Shallower reordering (also an AVL tree)⍞000D⍞000D           E↓4                      D↓3⍞000D          /   \                    /   \⍞000D         /     \                  /     \⍞000D        C↓3     F↓2              B↓2     F↓2⍞000D       /   \     \              /  \    /  \⍞000D      B↓2   D↓1   G↓1        A↓1  C↓1  E↓1  G↓1⍞000D     /⍞000D    A↓1⍞000D⍞000DIf we remove node G↓1 from the diagram above left, the resulting tree is said to⍞000D"overbalance" as F↓1 differs in height by 2 from its sibling C↓3:⍞000D⍞000D           E↓4⍞000D          /  \⍞000D         /    \⍞000D        C↓3     F↓1         overbalanced: C↓3 >> F↓1⍞000D       /   \⍞000D      B↓2   D↓1⍞000D     /⍞000D    A↓1⍞000D⍞000DWe  can  maintain  the tree without keeping explicit track of the height of each⍞000Dnode''s subtrees.  Instead, we record only the _difference_ in the heights of its⍞000Dsubtrees.⍞000D⍞000DBy keeping only the difference in subtree heights, addition and removal of nodes⍞000Drequires adjustment to only local regions of the tree.⍞000D⍞000DFurther, in a correctly balanced AVL tree, this difference must be one of ¯1 0 1⍞000Dwhich  means that only two bits per node are required to store balancing inform-⍞000Dation.⍞000D⍞000D(⍞000D    We  could reduce this to just one bit per node by devolving each node''s bal-⍞000D    ance bits to its left and right subtree. This works because leaf nodes, with⍞000D    only  null  subtrees, are (clearly) balanced and so need no balance bits. We⍞000D    can see this scheme in  operation by looking at  the output from ⍕avl, where⍞000D    the balance bits are represented by arrows supporting the subtrees.⍞000D)⍞000D⍞000D  < left subtree higher ·   ·  ¯1⍞000D    subtrees of equal height·   0⍞000D  > right subtree higher    ·   1⍞000D⍞000D           <E⍞000D           / \⍞000D          /   \⍞000D        <C     F>⍞000D        / \     \⍞000D      <B   D     G⍞000D      /⍞000D     A⍞000D⍞000DWorst-case AVL trees⍞000D--------------------⍞000DHeight:  0   1       2       3       4           5⍞000DSize:    0   1       2       4       7          12⍞000D         ·   ·       ·       ·       ·           ·⍞000D         .   A       B       C       E           H⍞000D                    /       / \     / \         / \⍞000D                   A       B   D   C   F       /   \⍞000D                          /       / \   \     /     \⍞000D                         A       B   D   G   E       J⍞000D                                /           / \     / \⍞000D                               A           C   F   I   K⍞000D                                          / \   \       \⍞000D                                         B   D   G       L⍞000D                                        /⍞000D                                       A⍞000D⍞000DWe  see  that successive worst cases consist of a new node with the previous two⍞000Dcases as subtrees. This means that the number of nodes in the worst case follows⍞000Dthe →fibonacci← sequence and for an AVL tree of height ⍵ is:⍞000D⍞000D    {¯1+fibonacci ⍵+2}      ⍝ number of nodes in worst case tree of height ⍵.⍞000D⍞000DAn approximation for the ⍵th Fibonacci number implies that the worst-case height⍞000Dfor an ⍵-node AVL tree is 1.44×⍟⍵ (search the Internet for "AVL 1.44").⍞000D⍞000DSee →avl_worst← for more.⍞000D⍞000DBalancing⍞000D---------⍞000DDuring  insertion or deletion, nodes may overbalance and need to be corrected by⍞000Drotation. In the following examples node A overbalances to the left <<A. If node⍞000DA were to overbalance right A>>, the mirror-image transformations would be used.⍞000DTo  avoid  coding  separate  mirror-image rotation functions, the implementation⍞000Dparameterises the direction of rotation, see Technical notes below.⍞000D⍞000DDepending  on  case, rebalancing decreases or leaves the height of the node as a⍞000Dwhole  unaltered. A decrease in height may cause the node''s parent to become un-⍞000Dbalanced and so itself to require rebalancing, and so on.⍞000D⍞000DOn  deletion of a node, a worst-case of ⌈2⍟⍵ rotations may be needed to preserve⍞000Dthe tree''s balance; on insertion of a new node, at most a single rotation is re-⍞000Dquired.⍞000D⍞000DTo simplify the following diagrams, a little additional notation is used:⍞000D⍞000D    <<N     node N overbalances left⍞000D     <N>    node N balances⍞000D    /n n\   arbitrary left and right subtrees of node N⍞000D     ⌿ ⍀    edge about to be rotated⍞000D     |      edge to parent node (if any).⍞000D     |=     height unchanged⍞000D     |-     height decreased⍞000D⍞000DCase 1: <<A''s left subtree <B hangs left:⍞000D⍞000D         |              |-                          rotation reduces height⍞000D       <<A      =>     <B>⍞000D        ⌿ \            / \                          Bal(A) = Bal(B)-r⍞000D      <B   a\        /b  <A>⍞000D      / \            /   / \⍞000D    /b   b\        /bb  b\  a\⍞000D    /⍞000D  /bb⍞000D⍞000DCase 2: <<A''s left subtree <B> balances:⍞000D⍞000D         |              |=                          height unaltered⍞000D       <<A      =>      B>⍞000D        ⌿ \            / \                          Bal(A) = Bal(B)-r⍞000D      <B>  a\        /b  <A⍞000D      / \                / \⍞000D    /b   b\             b\  a\⍞000D⍞000DCase 3: <<A''s left subtree B> hangs right:⍞000D⍞000D         |              |              |-           rotations reduce height⍞000D       <<A      =>    <<A      =>     <C>⍞000D        / \            ⌿ \            / \⍞000D       B>  a\        <C?  a\         /   \          Bal(A) ← 0⌈-Bal(C)⍞000D      / ⍀            / \           <B?   ?A>        Bal(B) ← 0⌊-Bal(C)⍞000D    /b  ?C?        <B?  c\         / \   / \⍞000D        / \        / \           /b  /c c\  a\⍞000D      /c   c\    /b  /c⍞000D⍞000DBalancing  is  perhaps better understood by considering the effects of change on⍞000Dnodes and edges:⍞000D⍞000D   ┌────────────────────────────────────────────────────────────────────────┐⍞000D   │A node  signals a height increment (i) of ¯1 0 1 to its supporting edge.│⍞000D   │An edge signals a balancing moment (b) of ¯1 0 1 to its parent node.    │⍞000D   └────────────────────────────────────────────────────────────────────────┘⍞000D⍞000DFor  example,  inserting  a  new  leaf  imparts  a  height increment of 1 to its⍞000Dsupporting  edge.  If  this  edge  is a right edge (say), it imparts a balancing⍞000Dmoment  of  1 to its parent node. If this node is already balanced (0), then its⍞000Dbalance  would be changed to 1 and it in turn would pass a height increment of 1⍞000Dto its supporting edge, and so on.⍞000D⍞000DHeight Increments⍞000D-----------------⍞000DCase  analysis  yields  a  simple rule for determining the height increment of a⍞000Dnode  following  insertion  or deletion in one of its subtrees. In the following⍞000Ddiagrams,  without  loss  of generality, we can assume that the height increment⍞000D(or decrement) is transmitted by the tree''s right subtree:⍞000D⍞000DInsertion, 3 cases:⍞000D⍞000D    ┌───────────────┬───────────────┬───────────────┐⍞000D    │   |       |=  │   |       |+  │  |        |=  │⍞000D    │  <A  =>  <A>  │  <A>  =>  A>  │  A>  =>  <b>  │⍞000D    │  / +     / \  │    +       \  │   \      / \  │⍞000D    │               │               │    b    A     │⍞000D    │               │       INCR    │     +         │⍞000D    └───────────────┴───────────────┴───────────────┘⍞000D⍞000Dleading to the rule:⍞000D⍞000D    ┌──────────────────────────────────────────────────────────────────────────┐⍞000D    │ A height <increment> is transmitted iff the <initial> node was balanced. │⍞000D    └──────────────────────────────────────────────────────────────────────────┘⍞000D⍞000DDeletion, 9 cases:⍞000D⍞000D    ┌───────────────────┬───────────────────┬───────────────────┐⍞000D    │    |        |-    │    |        |=    │    |        |-    │⍞000D    │   <A  =>   <B>    │   <A>  =>   A>    │    A>  =>  <A>    │⍞000D    │   / ⍀      / \    │   / \      / \    │   / \      / \    │⍞000D    │ <B            A   │ <B   c   <B   c   │ <B   c   <B   c   │⍞000D    │ /                 │ /   ⌿    /        │ /   / \  /   / \  │⍞000D    │                   │                   │    d        d     │⍞000D    │           DECR    │                   │   ⌿       DECR    │⍞000D    ├───────────────────┼───────────────────┼───────────────────┤⍞000D    │    |        |=    │    |        |=    │    |        |-    │⍞000D    │   <A   =>   B>    │   <A>  =>  <A     │    A>  =>  <A>    │⍞000D    │   / ⍀      / \    │   / ⍀      /      │   / \      / \    │⍞000D    │ <B>          <A   │ <B>      <B>      │ <B>  c   <B>  c   │⍞000D    │ / \          /    │                   │     ⌿             │⍞000D    │    c        c     │                   │                   │⍞000D    │                   │                   │           DECR    │⍞000D    ├───────────────────┼───────────────────┼───────────────────┤⍞000D    │    |        |-    │    |         |=   │    |        |-    │⍞000D    │   <A  =>   <c>    │   <A>  =>   <A    │    A>  =>  <A>    │⍞000D    │   / ⍀      / \    │   / \       / \   │   / \      / \    │⍞000D    │  B>       B   A   │  B>  c     B>  c  │  B>  c    B>  c   │⍞000D    │   \               │   \ ⌿       \     │   \   \    \   \  │⍞000D    │    c              │                   │        d        d │⍞000D    │           DECR    │                   │       ⌿   DECR    │⍞000D    └───────────────────┴───────────────────┴───────────────────┘⍞000D⍞000Dleading to the rule:⍞000D⍞000D   ┌───────────────────────────────────────────────────────────────────────────┐⍞000D   │ A height <decrement> is transmitted iff the <resulting> node is balanced. │⍞000D   └───────────────────────────────────────────────────────────────────────────┘⍞000D⍞000DOperations on AVL trees⍞000D-----------------------⍞000D[avl]  uses  the standard →BST← methods for search, insertion, and node removal.⍞000DIn  the case of insertion a single rotation, and in the case of removal, several⍞000Drotations, may be necessary to maintain the tree''s balance.⍞000D⍞000DStatistics⍞000D----------⍞000DAn invocation of [avl] with a left operand of ? reports a 4-vector of statistics⍞000D(ok size depth height) for its tree right argument, where:⍞000D⍞000D        ok:  boolean -> balance = difference in subtree heights, for all nodes.⍞000D      size:  number of (non-null) nodes.⍞000D     depth:  mean distance from the root of all nodes.⍞000D    height:  maximum distance from root to each leaf; a null tree has height 0.⍞000D⍞000DTechnical notes⍞000D---------------⍞000DThese  AVL  functions  are implemented using a recursive triple, with 0 standing⍞000Dfor the null tree:⍞000D⍞000D    (key val) bal (lft rgt)⍞000D⍞000Dwhere:⍞000D⍞000D    key : numeric scalar or character vector⍞000D    val : any array value⍞000D    bal : balance ¯1 0 1⍞000D    lft : left subtree or 0⍞000D    rgt : right subtree or 0⍞000D⍞000DThe AVL tree functions: insert/replace, delete, search, ... are derived from the⍞000Dsingle  operator  [avl]  by binding an appropriate left operand. This is so that⍞000Dcommon auxiliary functions such as balancing and rotation, which have little use⍞000Doutside  the context of AVL trees, may be hidden within the capsule (encapsulat-⍞000Ded). It is conceivable that an implementation of D: could retain a partial eval-⍞000Duation of such bindings to speed up subsequent application of the derived funct-⍞000Dions.⍞000D⍞000DParameterising direction:⍞000D⍞000DIn  order to avoid having to code mirror-image subfunctions for left/right trav-⍞000Dersal and left/right rotation, the direction is parameterised using subfunction:⍞000D⍞000D     wise←{(⍺=1)⌽⍵}             ⍝ subtrees ⍵ in -⍺, +⍺ order.⍞000D⍞000D     1 wise 4 5⍞000D5 4⍞000D⍞000D    ¯1 wise 4 5⍞000D4 5⍞000D⍞000DSimilarly, a complete tree may be presented in either +1 or -1 orientation:⍞000D⍞000D     proj←{(⍺=0 0 ¯1)⌽¨⍵}       ⍝ ⍺-projection of node ⍵.⍞000D⍞000D     1 proj 2 3(4 5)⍞000D2 3  4 5⍞000D⍞000D    ¯1 proj 2 3(4 5)⍞000D2 3  5 4⍞000D⍞000D(muse:⍞000D    In  general,  parameterisation saves duplication at the expense of abstract-⍞000D    ion.  In  other  words, it produces more concentrated code, which is smaller⍞000D    but harder to understand.⍞000D)⍞000D⍞000DFormatting⍞000D----------⍞000DDerived  function ⍕avl transposes the tree and pushes the balance indicators out⍞000Dto either end of the subtree  branches.  Unlike the diagrams above, sibling sub-⍞000Dtrees of differing height are _each_ preceded by a ''>'' or ''<'' indicator. For ex-⍞000Dample:⍞000D⍞000D    Notes Diagram               Equivalent ⍕avl⍞000D⍞000D           <E⍞000D           / \          =>                   ┌>A=A⍞000D          /   \                         ┌>B=B┘⍞000D        <C     F>                  ┌>C=C┤⍞000D        / \     \                  │    └<D=D⍞000D      <B   D     G              E=E┤⍞000D      /                            └<F=F┐⍞000D     A                                  └>G=G⍞000D⍞000DReferences:⍞000D⍞000D[1] An algorithm for the organization of information,⍞000D    G. M. Adelson-Velskii and E. M. Landis (1962).⍞000D          ¯       ¯                 ¯⍞000D[2] Knuth: The Art of Computer Programming, Vol 2, Ch. 6.2.3, "Balanced Trees".⍞000D⍞000D[3] The Internet: Search for "AVL trees".⍞000D⍞000D[4] http://en.wikipedia.org/wiki/AVL_trees⍞000D⍞000DExamples:⍞000D⍞000D⍝ derivation of AVL tree functions:⍞000D⍞000D    chk ← ? avl     ⍝ stats for tree ⍵              :: ∇ t → y s d h⍞000D⍞000D    tt ← 0                          ⍝ null tree⍞000D⍞000D    tt ← tt ∪avl ''one'' 1            ⍝ single node tree: (key val) bal (lft rgt)⍞000D⍞000D    tt                              ⍝ nested structure of single tree node.⍞000D┌───────┬─┬───┐⍞000D│┌───┬─┐│0│0 0│⍞000D││one│1││ │   │⍞000D│└───┴─┘│ │   │⍞000D└───────┴─┴───┘⍞000D⍞000D    ⊢ tt ← tt ∪avl ''two'' 2          ⍝ insert of second⍞000D┌───────┬─┬───────────────────┐⍞000D│┌───┬─┐│1│┌─┬───────────────┐│⍞000D││one│1││ ││0│┌───────┬─┬───┐││⍞000D│└───┴─┘│ ││ ││┌───┬─┐│0│0 0│││⍞000D│       │ ││ │││two│2││ │   │││⍞000D│       │ ││ ││└───┴─┘│ │   │││⍞000D│       │ ││ │└───────┴─┴───┘││⍞000D│       │ │└─┴───────────────┘│⍞000D└───────┴─┴───────────────────┘⍞000D⍞000D⍝ NB: In the following examples, the _values_ are numeric: 1 2 3 ...⍞000D⍝     but the _keys_ are alphabetic: ''one'' ''two'' ''three'' ...⍞000D⍝     this means that ''one'' precedes ''two'' but that ''four'' follows ''five''.⍞000D⍞000D    tt ← tt ∪avl ''three'' 3          ⍝ insert third node.⍞000D⍞000D    disp tt⍞000D┌─────────┬─┬─────────────────────────────────┐⍞000D│┌─────┬─┐│0│┌───────────────┬───────────────┐│⍞000D││three│3││ ││┌───────┬─┬───┐│┌───────┬─┬───┐││⍞000D│└─────┴─┘│ │││┌───┬─┐│0│0 0│││┌───┬─┐│0│0 0│││⍞000D│         │ ││││one│1││ │   ││││two│2││ │   │││⍞000D│         │ │││└───┴─┘│ │   │││└───┴─┘│ │   │││⍞000D│         │ ││└───────┴─┴───┘│└───────┴─┴───┘││⍞000D│         │ │└───────────────┴───────────────┘│⍞000D└─────────┴─┴─────────────────────────────────┘⍞000D⍞000D    ⍕avl tt                         ⍝ format of tree.⍞000D       ┌─one=1⍞000Dthree=3┤⍞000D       └─two=2⍞000D⍞000D    tt ← tt ∪avl foldl (''four'' 4) (''five'' 5) (''six'' 6) (''seven'' 7)⍞000D⍞000D    ⍕avl tt                         ⍝ 7-node tree.⍞000D             ┌>five=5⍞000D     ┌<four=4┘⍞000Done=1┤⍞000D     │               ┌>seven=7⍞000D     │        ┌>six=6┘⍞000D     └>three=3┤⍞000D              └<two=2⍞000D⍞000D    disp ∊avl tt                    ⍝ enlist of tree.⍞000D┌────────┬────────┬───────┬─────────┬───────┬─────────┬───────┐⍞000D│┌────┬─┐│┌────┬─┐│┌───┬─┐│┌─────┬─┐│┌───┬─┐│┌─────┬─┐│┌───┬─┐│⍞000D││five│5│││four│4│││one│1│││seven│7│││six│6│││three│3│││two│2││⍞000D│└────┴─┘│└────┴─┘│└───┴─┘│└─────┴─┘│└───┴─┘│└─────┴─┘│└───┴─┘│⍞000D└────────┴────────┴───────┴─────────┴───────┴─────────┴───────┘⍞000D⍞000D    chk tt                          ⍝ tree stats: ok size mean_depth height.⍞000D1 7 2 4⍞000D⍞000D    ⍕avl tt ∪avl ''six'' 666          ⍝ tree with value of ''six'' replaced.⍞000D             ┌>five=5⍞000D     ┌<four=4┘⍞000Done=1┤⍞000D     │                 ┌>seven=7⍞000D     │        ┌>six=666┘⍞000D     └>three=3┤⍞000D              └<two=2⍞000D⍞000D    ⍕avl tt ~avl ''one''              ⍝ tree with key ''one'' removed.⍞000D             ┌─five=5⍞000D     ┌─four=4┤⍞000D     │       └─seven=7⍞000Dsix=6┤⍞000D     └─three=3┐⍞000D              └>two=2⍞000D⍞000D    tt ~avl foldl ⊃¨∊avl tt         ⍝ tree with all keys removed.⍞000D0⍞000D⍞000D⍝ Notice how insertion may require local rotation to maintain balance:⍞000D⍞000D    ⍪ ⍕avl∘(0∘(∪avl foldl))¨,\6↑⎕a  ⍝ insert of A B .. F⍞000D┌─────────────┐⍞000D│A=A          │⍞000D├─────────────┤⍞000D│A=A┐         │⍞000D│   └>B=B     │⍞000D├─────────────┤⍞000D│   ┌─A=A     │⍞000D│B=B┤         │⍞000D│   └─C=C     │⍞000D├─────────────┤⍞000D│   ┌<A=A     │⍞000D│B=B┤         │⍞000D│   └>C=C┐    │⍞000D│        └>D=D│⍞000D├─────────────┤⍞000D│   ┌<A=A     │⍞000D│B=B┤         │⍞000D│   │    ┌─C=C│⍞000D│   └>D=D┤    │⍞000D│        └─E=E│⍞000D├─────────────┤⍞000D│        ┌─A=A│⍞000D│   ┌─B=B┤    │⍞000D│   │    └─C=C│⍞000D│D=D┤         │⍞000D│   └─E=E┐    │⍞000D│        └>F=F│⍞000D└─────────────┘⍞000D⍞000D⍝ Removal may also need rotation to maintain balance:⍞000D⍞000D    A_F←0 ∪avl foldl ''ABCDEF''                   ⍝ tree A B .. F⍞000D⍞000D    ⍪ ⍕avl¨ A_F∘(~avl foldl)¨,\'' ABCDEF''        ⍝ removal of A B .. F⍞000D┌─────────────┐⍞000D│        ┌─A=A│⍞000D│   ┌─B=B┤    │⍞000D│   │    └─C=C│⍞000D│D=D┤         │⍞000D│   └─E=E┐    │⍞000D│        └>F=F│⍞000D├─────────────┤⍞000D│   ┌─B=B┐    │⍞000D│   │    └>C=C│⍞000D│D=D┤         │⍞000D│   └─E=E┐    │⍞000D│        └>F=F│⍞000D├─────────────┤⍞000D│   ┌<C=C     │⍞000D│D=D┤         │⍞000D│   └>E=E┐    │⍞000D│        └>F=F│⍞000D├─────────────┤⍞000D│   ┌─D=D     │⍞000D│E=E┤         │⍞000D│   └─F=F     │⍞000D├─────────────┤⍞000D│E=E┐         │⍞000D│   └>F=F     │⍞000D├─────────────┤⍞000D│F=F          │⍞000D├─────────────┤⍞000D└─────────────┘⍞000D⍞000D    ⍪ ⍕avl¨ A_F∘(~avl foldl)¨,\'' DEBCFA''    ⍝ repeated removal of root node⍞000D┌─────────────┐⍞000D│        ┌─A=A│⍞000D│   ┌─B=B┤    │⍞000D│   │    └─C=C│⍞000D│D=D┤         │⍞000D│   └─E=E┐    │⍞000D│        └>F=F│⍞000D├─────────────┤⍞000D│        ┌─A=A│⍞000D│   ┌>B=B┤    │⍞000D│   │    └─C=C│⍞000D│E=E┤         │⍞000D│   └<F=F     │⍞000D├─────────────┤⍞000D│   ┌<A=A     │⍞000D│B=B┤         │⍞000D│   │    ┌>C=C│⍞000D│   └>F=F┘    │⍞000D├─────────────┤⍞000D│   ┌─A=A     │⍞000D│C=C┤         │⍞000D│   └─F=F     │⍞000D├─────────────┤⍞000D│   ┌>A=A     │⍞000D│F=F┘         │⍞000D├─────────────┤⍞000D│A=A          │⍞000D├─────────────┤⍞000D└─────────────┘⍞000D⍞000DSee also: BST alists sbst splay redblack foldl fibonacci avl_worst⍞000D⍞000DIndex:tree|binary search tree|type notation|expression transformation⍞000DIndex:fibonacci number|enlist⍞000DIndex;Adelson-Velskii G.M.|Landis E.M.|Knuth D.E.' 
