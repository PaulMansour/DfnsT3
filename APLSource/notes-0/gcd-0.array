'num ← num ##.gcd num                        ⍝ Greatest Common Divisor.⍞000D                                            ⍝ Euclid ¯330-¯275.⍞000DAn illustration of tail recursion.⍞000D⍞000D    gcd←{       ⍝ Greatest common divisor.⍞000D        ⍵=0:|⍺⍞000D        ⍵ ∇ ⍵|⍺⍞000D    }⍞000D⍞000DNB: This function is for illustrative purposes only;  GCD and LCM are  primitive⍞000D    functions ∨ and ∧.⍞000D⍞000DWikipedia says: "The  original  algorithm as described by Euclid treated it as a⍞000Dgeometric  problem,  and  hence  used repeated subtraction of the smaller number⍞000Dfrom  the  larger  number rather than integer division ... which is considerably⍞000Dless efficient than ... (using residue)."⍞000D⍞000DRef: http://en.wikipedia.org/wiki/Euclidean_algorithm⍞000D⍞000DEuclid  might  have coded something like the following, which works for positive⍞000Darguments:⍞000D⍞000D    gcd←{               ⍝ Euclid''s algorithm.⍞000D        ⍺<⍵: ⍺ ∇ ⍵-⍺    ⍝ ... using repeated⍞000D        ⍺>⍵: ⍵ ∇ ⍺-⍵    ⍝ ... subtraction.⍞000D        ⍺=⍵: ⍺⍞000D    }⍞000D⍞000DBinary GCD⍞000D----------⍞000DThis  algorithm,  which  takes  a  pair of non-negative whole (unsigned integer)⍞000Dnumbers as argument, is suitable for implementing GCD in a low-level compiled or⍞000Dassembly language. In such languages, 2|⍵ and ⍺÷2 are fast operations.⍞000D⍞000D    bgcd←{                  ⍝ Binary gcd.⍞000D        0∊⍵:+/⍵             ⍝ either is 0:      m ? m : n⍞000D        0 0≡2|⍵:2×∇ ⍵÷2     ⍝ even even:       (∇ (m >> 1) (n >> 1)) << 1⍞000D        0 1≡2|⍵:∇ ⍵÷2 1     ⍝ even odd:         ∇ (m >> 1) n⍞000D        1 0≡2|⍵:∇ ⍵÷1 2     ⍝ odd  even:        ∇ m (n >> 1)⍞000D        ≤/⍵:∇(-\⍵)÷1 ¯2     ⍝ odd  odd: m≤n:    ∇ m (n-m >> 1)⍞000D        ∇(⌽-\⌽⍵)÷¯2 1       ⍝ odd  odd: m>n:    ∇ (m-n >> 1) n⍞000D    }⍞000D⍞000D        bgcd 105 330        ⍝ takes a pair of non-negative whole numbers.⍞000D    15⍞000D⍞000DRef: http://en.wikipedia.org/wiki/Binary_gcd⍞000D⍞000DArray GCD⍞000D---------⍞000DWe  can  modify  the  coding  slightly to find the GCDs of conformable (possibly⍞000Dnested) arrays in parallel:⍞000D⍞000D    gcds←{                          ⍝ Array-GCD.⍞000D        ⍺≡⍺+⍺:|⍵                    ⍝ all 0s: done.⍞000D        (⍺⌊⍵)∇(⍺⌊⍵)|⍺⌈⍵             ⍝ min ∇ min | max.⍞000D    }⍞000D⍞000D    ⎕←pvec←sieve 2 to 80            ⍝ primes 2..80⍞000D2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79⍞000D⍞000D    ⎕←tvec←×/¨3,/pvec               ⍝ products of consecutive triples.⍞000D30 105 385 1001 2431 4199 7429 12673 20677 33263 47027 65231 82861 107113 146969 190747 241133 290177 347261 409457⍞000D⍞000D    ⎕←ll rr←4 5∘⍴¨0 ¯1⌽¨⊂tvec       ⍝ matrices of adjacent triple products.⍞000D     30    105    385   1001   2431  409457     30    105    385   1001⍞000D   4199   7429  12673  20677  33263    2431   4199   7429  12673  20677⍞000D  47027  65231  82861 107113 146969   33263  47027  65231  82861 107113⍞000D 190747 241133 290177 347261 409457  146969 190747 241133 290177 347261⍞000D⍞000D    ll gcd¨rr                       ⍝ GCDs using each.⍞000D   1   15   35   77  143⍞000D 221  323  437  667  899⍞000D1147 1517 1763 2021 2491⍞000D3127 3599 4087 4757 5183⍞000D⍞000D    ll gcds rr                      ⍝ parallel GCDs.⍞000D   1   15   35   77  143⍞000D 221  323  437  667  899⍞000D1147 1517 1763 2021 2491⍞000D3127 3599 4087 4757 5183⍞000D⍞000D    cmpx''ll gcd¨rr'' ''ll gcds rr''    ⍝ timing comparison: parallel is faster.⍞000D  ll gcd¨rr  1.2E¯4   0% ⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⍞000D  ll gcds rr 5.2E¯5 -56% ⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⍞000D⍞000D    (↓ll) gcds ↓rr                  ⍝ nested GCDs.⍞000D┌──────────────┬───────────────────┬────────────────────────┬────────────────────────┐⍞000D│1 15 35 77 143│221 323 437 667 899│1147 1517 1763 2021 2491│3127 3599 4087 4757 5183│⍞000D└──────────────┴───────────────────┴────────────────────────┴────────────────────────┘⍞000D⍞000DA better version for non-integral arguments⍞000D-------------------------------------------⍞000DEuclid''s  algorithm works well for whole-number arguments but gives poor results⍞000Dfor floating-point numbers.  We can generalise Euclid to →rational← arguments by⍞000Dnoting that:⍞000D⍞000D    (A÷B) gcd (C÷D)  ≡≡  (A gcd C) ÷ (B lcm D)⍞000D⍞000Dwhere lcm is least-common-multiple. The following code does the trick:⍞000D⍞000D    ggcd←{                          ⍝ General gcd.⍞000D        (a b)(c d)←rational¨⍺ ⍵     ⍝ rational approximations.⍞000D        lcm←{⍺×⍵÷⍺ gcd ⍵}           ⍝ least common multiple.⍞000D        (a gcd c)÷b lcm d           ⍝ (see notes.rats).⍞000D    }⍞000D⍞000Dthen:⍞000D⍞000D    (1 to 11) ggcd¨ 0.111           ⍝ Gianluigi Quario''s example.⍞000D0.001 0.001 0.003 0.001 0.001 0.003 0.001 0.001 0.003 0.001 0.001⍞000D⍞000DExamples:⍞000D⍞000D      105 gcd 330⍞000D15⍞000D      factors (3×5×7) gcd 5×7×11⍞000D5 7⍞000D      lcm←{⍺×⍵÷⍺ gcd ⍵}                     ⍝ least common multiple⍞000D⍞000D      factors (3×5×7) lcm 5×7×11⍞000D3 5 7 11⍞000D⍞000D      simple←{⍵÷gcd/⍵}                      ⍝ simplest fraction.⍞000D⍞000D      simple 24 36                          ⍝ simplify:  24/36 → 2/3.⍞000D2 3⍞000D⍞000DSee also: sieve factors nats rats rational⍞000D⍞000DIndex:greatest common divisor|least common multiple|tail recursion⍞000DIndex;Euclid|Quario G.' 
