'rslt ← (if ##.cond then cond else) arg     ⍝ proposition:consequence:alternative⍞000D⍞000DPhil Last says: this operator implements the triadic structure:⍞000D⍞000D    [if] proposition [then] consequence [else] alternative.⍞000D⍞000DThe  correct way to call it is as above, monadically with two calls to the oper-⍞000Dator  separating the three operands.  The resulting derived conditional function⍞000Dis similar to the D: guard construct ...⍞000D⍞000D    proposition : consequence ⋄ alternative⍞000D⍞000Dexcepting  that it is a function, can be assigned a name, and within the D: con-⍞000Dtext its result is captured regardless of the truth of the proposition or not at⍞000Dall.  Any  of the three, proposition, consequence and alternative, can be either⍞000Darrays  or  monadic (ambivalent) functions on arg. (proposition) or (proposition⍞000Darg)  must  be a boolean singleton. Any of them can of course be further (paren-⍞000Dthesised) or named conditionals on arg.⍞000D⍞000DThe development started two decades ago in APL2 with defined operators such as:⍞000D⍞000D        ┌──────────────────────┬────────────────────────────────┐⍞000D        │ ∇ r←(f then g)w      │ ∇ r←a(f else g)w               │⍞000D        │   r←↑g mon/(⍳f w),⊂w │   r←↑f mon/(⍳a),g mon/(⍳~a),⊂w │⍞000D        │ ∇                    │ ∇                              │⍞000D        └──────────────────────┴────────────────────────────────┘⍞000Dwhere:⍞000D        ┌───────────────┐⍞000D        │ ∇ r←a(f mon)w │⍞000D        │   r←f w       │⍞000D        │ ∇             │⍞000D        └───────────────┘⍞000D⍞000D    rslt ← (proposition then consequence) arg⍞000D⍞000D    rslt ← test (consequence else alternative) arg⍞000D⍞000DIn  different  versions  of  both operators the control, here effected by use of⍞000Dreduction  on  a  one   or two item vector, could instead be by branching, using⍞000D:If &c. control structures or latterly by use of a guard in a D:op. The idea was⍞000Dto  make all of these methods redundant. The operators, (then) and (else), could⍞000Dnot  be  used together because the derived function (f then g else h) is dyadic,⍞000Das it is derived from (else), and will run either (f then g) or (h) according to⍞000Dits  boolean  left argument where what is required is to run (f) unconditionally⍞000Dfollowed by (g) or (h) according to its boolean result.⍞000D⍞000DA  breakthrough was made on a napkin in Helsingør, a day or two earlier in truth⍞000Dand  a  notebook,  by  coding  the two operators to work together to produce the⍞000DMONADIC  derived function (f then g else h) fulfilling these criteria. To do so,⍞000Darguments  were  passed from (else) to (then) to control the calling of the pro-⍞000Dposition  and consequence separately if at all. These worked exactly as expected⍞000Dand  were  also  upwardly  compatible with the definitions above. Here are their⍞000Ddefinitions ...⍞000D⍞000D    ┌─────────────────────┬───────────────────────┐⍞000D    │ then←{⍺←''M''         │ else←{⍺←''M''           │⍞000D    │     ⍺=''Q'':(⊢∘⍺⍺)⍵   │     ⍺=1:(⊢∘⍺⍺)⍵       │⍞000D    │     ⍺=''Y'':(⊢∘⍵⍵)⍵   │     ⍺=0:(⊢∘⍵⍵)⍵       │⍞000D    │     (⊢∘⍺⍺)⍵:(⊢∘⍵⍵)⍵ │     ''Q'' ⍺⍺ ⍵:''Y'' ⍺⍺ ⍵ │⍞000D    │     ⍵               │     (⊢∘⍵⍵)⍵           │⍞000D    │ }                   │ }                     │⍞000D    └─────────────────────┴───────────────────────┘⍞000D⍞000DNotice the (almost) identical lines in each.⍞000D⍞000DIn  (else)  these operate the older standalone use where a boolean left argument⍞000Ddetermines  whether  the consequence or the alternative should be run. In (then)⍞000Dthese carry out the instruction passed in the left argument by the third line of⍞000D(else)  to  run the proposition and possibly the consequence. The other lines of⍞000D(then)  operate  the  older  standalone monadic use. However rigorously defined,⍞000Dhaving  two  disparate  operators which can both be used independently but which⍞000DCAN  work  in  concert  and  must  agree  on an arbitrary protocol to do so goes⍞000Dagainst the spirit if not the letter of good functional programming.⍞000D⍞000DAlso,  a conditional without an alternative, (proposition then consequence), can⍞000Dbe  considered  in  the same dim light. Nevertheless they lasted a month before,⍞000Dwalking  around  Københavns  Søen, I realised this weakness could be overcome by⍞000Dproducing a single operator that implements the best of both without any depend-⍞000Dencies.  In  fact  the  napkin coding of (else) as it stood was adequate for the⍞000Dtask after substituting 2, 1 and 0 for ''M'', ''Q'' and ''Y'' but the clause ...⍞000D⍞000D    rslt ← (proposition else consequence else alternative) arg⍞000D⍞000Dhas  lost  its meaning and confuses more by the fact that it SEEMS to mean some-⍞000Dthing while not actually doing so.⍞000D⍞000D(⍞000D    This  may be the prejudice of a native English speaker; I have heard, though⍞000D    I  think  it''s probably a misunderstanding, that some eastern languages lack⍞000D    words  for  the  concepts  carried by "therefore" and "because". I have also⍞000D    heard  that programmers in eastern countries prefer the APL language because⍞000D    it is not encumbered with English (or western) language contructs.⍞000D)⍞000D⍞000DThe  final  coding  of  the  operator  dispenses with the standalone use of both⍞000D(then) and (else). Thus it is always coded twice separating the three operands.⍞000D⍞000DI  decided  that  using  the left argument as an "internal" flag really aught to⍞000Dpreclude  its  use otherwise so although it''s not impossible to call the derived⍞000Dfunction  dyadically its use is deprecated and its results are rather unpredict-⍞000Dable.  Including the different permutations of array and function operands there⍞000Dwere sixteen calling sequences for the (then) and (else) operators used individ-⍞000Dually  and in combination. With the restrictions imposed by a single conditional⍞000Dsymbol only usable in combination we are left with eight ...⍞000D⍞000D    RSLT ← (proposition cond consequence cond alternative) ARG⍞000D    RSLT ← (proposition cond consequence cond OTHER) ARG⍞000D    RSLT ← (proposition cond VALUE cond alternative) ARG⍞000D    RSLT ← (proposition cond VALUE cond OTHER) ARG⍞000D    RSLT ← (TEST cond consequence cond alternative) ARG⍞000D    RSLT ← (TEST cond consequence cond OTHER) ARG⍞000D    RSLT ← (TEST cond VALUE cond alternative) ARG⍞000D    RSLT ← (TEST cond VALUE cond OTHER) ARG⍞000D⍞000DSome of the parentheses in the above are redundant. If you don''t know which, you⍞000Dare  best  to leave them in. The last clause makes no use of ARG except to force⍞000DAPL to call the derived function rather than assigning it into RSLT!⍞000D⍞000DAn alternative coding⍞000D---------------------⍞000DAn alternative, if slightly more challenging, coding of cond might be:⍞000D⍞000D    cond←{ ⍝ proposition : consequence : alternative⍞000D        m q y←147036925 258147036 369258147⍞000D        ⍺←m⍞000D        ⊢∘⍺⍺⍣(⍺=q)⊢⊢∘⍵⍵⍣(⍺=y)⊢⍺⍺{(q ⍺⍺ ⍵)⍺⍺{y∘⍺⍺⍣⍺⊢⊢∘⍵⍵⍣(~⍺)⊢⍵}⍵⍵ ⍵}⍵⍵⍣(⍺=m)⊢⍵⍞000D    }⍞000D⍞000DExamples:⍞000D⍞000D    eis←1∘=∘≡cond⊂cond⊢         ⍝ enclose if depth=1.⍞000D⍞000D    1 disp      1 (,1) (⊂,1)    ⍝ items have depth 0 1 2⍞000D┌→┬─┬───┐⍞000D│ │ │┌─┐│⍞000D│1│1││1││⍞000D│ │ │└→┘│⍞000D└─┴→┴───┘⍞000D    1 disp eis¨ 1 (,1) (⊂,1)    ⍝ enclose depth-1 items.⍞000D┌→┬───┬───┐⍞000D│ │┌─┐│┌─┐│⍞000D│1││1│││1││⍞000D│ │└→┘│└→┘│⍞000D└─┴───┴───┘⍞000D⍞000D    unless←{~∘⍵⍵ cond ⍺⍺ cond⊢⍵}⍞000D⍞000D    log←⍟unless(≤∘0)⍞000D⍞000D    log 3⍞000D1.098612289⍞000D⍞000D    log 0⍞000D0⍞000D    or←{(∨/⍺)cond((0⊥⍺)cond ⍵⍵ cond((2=⍴⍺)cond ⍺⍺ cond((¯1↓⍺)∘⍺⍺)))cond⊢⍵}⍞000D⍞000D    0 0 0 0-or×or⌈or⌊7.5⍞000D7.5⍞000D    0 0 0 1-or×or⌈or⌊7.5⍞000D7⍞000D    0 0 1 0-or×or⌈or⌊7.5⍞000D8⍞000D    0 1 0 0-or×or⌈or⌊7.5⍞000D1⍞000D    1 0 0 0-or×or⌈or⌊7.5⍞000D¯7.5⍞000D⍞000D    ⍝ Used as a dyadic, rather than "triadic" construct,⍞000D    ⍝ cond is equivalent to →else←:⍞000D⍞000D    0 1 ÷cond-¨ 3⍞000D¯3 0.3333333333⍞000D⍞000D    0 1 ÷else-¨ 3⍞000D¯3 0.3333333333⍞000D⍞000DSee also: while until else and or co_ops⍞000D⍞000DIndex:conditional operator|Helsingør|hyperator|co-operator⍞000DIndex;Last P.' 
