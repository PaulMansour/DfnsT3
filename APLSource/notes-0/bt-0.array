'tvec ← {larg} (fn ##.bt) rarg               ⍝ Balanced Ternary Arithmetic.⍞000D⍞000D    "Perhaps the prettiest number system of all." - Donald Knuth.⍞000D⍞000DBackground⍞000D----------⍞000DBalanced  Ternary (BT) is a number system in which each place represents a power⍞000Dof 3: 1 9 27 81 243 ...  It  differs  from "standard" ternary in that instead of⍞000Dusing  non-negative  digits  (0 1 2), BT uses (¯1 0 1), the first of which, pro-⍞000Dnounced "bar-one",  is more properly written with the bar or "vinculum" directly⍞000Dover the 1. Here are the first few non-negative numbers together with their dec-⍞000Dimal equivalents:⍞000D⍞000D          BT     Decimal⍞000D           0     0⍞000D           1     1⍞000D        1 ¯1     2  = 3 + ¯1        "one, bar-one"⍞000D        1  0     3⍞000D        1  1     4⍞000D     1 ¯1 ¯1     5  = 9 + ¯3 + ¯1   "one, bar-one, bar-one"⍞000D     1 ¯1  0     6⍞000D     1 ¯1  1     7  = 9 + ¯3 +  1⍞000D     1  0 ¯1     8⍞000D     1  0  0     9⍞000D     1  0  1    10⍞000D     1  1 ¯1    11⍞000D     1  1  0    12⍞000D     1  1  1    13⍞000D  1 ¯1 ¯1 ¯1    14  = 27 + ¯9 + ¯3 + ¯1⍞000D⍞000DOperation⍞000D---------⍞000DOperator  [bt]  applies its operand function to or between balanced ternary (BT)⍞000Darguments. Each scalar argument is represented by a vector of the balanced tern-⍞000Dary digits ∊ ¯1 0 1. For example:⍞000D⍞000D        1 ¯1 +bt 1 0                ⍝ 2+3 → 5⍞000D    1 ¯1 ¯1⍞000D⍞000DSpecial monadic operands ⊤ and ⊥ encode and decode between regular integer scal-⍞000Dars and their BT equivalents.⍞000D⍞000D        ⊤bt 100                     ⍝ BT encoding of 100⍞000D    1 1 ¯1 0 1⍞000D⍞000D        ⊥bt 1 0 ¯1 1                ⍝ decoding of BT 1 0 ¯1 1⍞000D    25⍞000D        ⊥bt (⊤bt 20) +bt ⊤bt 30     ⍝ 20+30 → 50⍞000D    50⍞000D⍞000DA monadic operand may be one of:⍞000D  ¯¯¯¯¯¯¯⍞000D    +       identity⍞000D    -       negative⍞000D    ×       signum⍞000D    |       absolute⍞000D    ⊤       encode BT from integer⍞000D    ⊥       decode integer from BT⍞000D⍞000DA dyadic operand may be one of:⍞000D  ¯¯¯¯¯¯⍞000D    +       sum⍞000D    -       difference⍞000D    ×       product⍞000D    ÷       quotient⍞000D    |       residue⍞000D    *       exponent⍞000D    ⌊       min⍞000D    ⌈       max⍞000D    ∨       greatest common divisor⍞000D    ∧       least common multiple⍞000D    <≤=≥>≠  relational⍞000D⍞000DMany arithmetic operations on BT numbers are particularly elegant:⍞000D⍞000DConversion between BT and integers⍞000D----------------------------------⍞000DBT_vector to integer is just 3∘⊥⍞000D⍞000D        3⊥  1 ¯1 ¯1     ⍝ decode BT⍞000D    5⍞000D        3⊥ ¯1 ¯1  1     ⍝ decode BT⍞000D    ¯11⍞000D⍞000DInteger to BT_vector is also relatively simple:⍞000D⍞000D    encode←{¯1 + norm 1 + 3 enco ⍵}⍞000D⍞000D    where:⍞000D        enco, coded {3..3⊤⍵}, encodes with an appropriate number of 3-digits,⍞000D        norm, coded {3..3⊤3⊥⍵}, resolves (carries) overflows.⍞000D⍞000DFor example:⍞000D                      3 enco 50     ⍝ standard 3-encode.⍞000D    0 1 2 1 2⍞000D⍞000D                  1 + 3 enco 50     ⍝ + 1 1 ... 1⍞000D    1 2 3 2 3⍞000D⍞000D             norm 1 + 3 enco 50     ⍝ normalised (3-overflows carried forward).⍞000D    2 0 1 0 0⍞000D⍞000D        ¯1 + norm 1 + 3 enco 50     ⍝ - 1 1 ... 1 → BT.⍞000D    1 ¯1 0 ¯1 ¯1⍞000D⍞000DNegation⍞000D--------⍞000DBalanced ternary numbers are symmetrical with respect to sign; the negative of a⍞000DBT  number  is  just  the negative of each of its digits. Here are the first few⍞000Dnegative BT numbers:⍞000D⍞000D          BT     Decimal⍞000D           0     0⍞000D          ¯1    ¯1⍞000D       ¯1  1    ¯2  = ¯3+1⍞000D       ¯1  0    ¯3⍞000D       ¯1 ¯1    ¯4⍞000D    ¯1  1  1    ¯5  = ¯9+3+1⍞000D⍞000D        ⊤bt  100            ⍝ BT representation of +100 (+/ 81 27 ¯9 0 1)⍞000D    1 1 ¯1 0 1⍞000D⍞000D        ⊤bt ¯100            ⍝ BT representation of ¯100 (+/ ¯81 ¯27 9 0 ¯1)⍞000D    ¯1 ¯1 1 0 ¯1⍞000D⍞000D        ⊥bt - ⊤bt 100       ⍝ (negating its digits negates the number)⍞000D    ¯100⍞000D⍞000DNotice  that, unlike two''s complement binary numbers, both positive and negative⍞000Dnumbers  have  notional leading zeros to the left of the most significant digit.⍞000DA normal BT form would remove these leading zeros  except for the anomalous case⍞000D(shared with standard decimal notation) of the number zero itself.⍞000D⍞000D    ... 0  0  1  1 ¯1  0  1  →   1  1 ¯1  0  1     ⍝  100⍞000D⍞000D    ... 0  0 ¯1 ¯1  1  0 ¯1  →  ¯1 ¯1  1  0 ¯1     ⍝ ¯100⍞000D⍞000D    ... 0  0  0  0  0  0  0  →               0     ⍝    0⍞000D⍞000DSignum⍞000D------⍞000DThe signum (sign) of a BT number is just its most significant digit.⍞000D⍞000D        ×bt ¯1 1 1 0        ⍝ ×¯15 → ¯1⍞000D    ¯1⍞000D        ×bt 1 ¯1 ¯1 0       ⍝ ×15 → 1⍞000D    1⍞000D        ×bt 0               ⍝ ×0 → 0⍞000D    0⍞000D⍞000DAddition⍞000D--------⍞000DThe addition table for BT digits is:⍞000D⍞000D     +  ¯1   0   1⍞000D       ┌───┬───┬───┐⍞000D    ¯1 │ 1-│¯1 │ 0 │   where:⍞000D       ├───┼───┼───┤⍞000D     0 │¯1 │ 0 │ 1 │       1- means 1 with a carry of ¯1 to the next column.⍞000D       ├───┼───┼───┤⍞000D     1 │ 0 │ 1 │¯1+│      ¯1+ means ¯1 with a carry of 1 to the next column.⍞000D       └───┴───┴───┘⍞000D⍞000DFor example:⍞000D⍞000D     1  0 ¯1  0  1            73 +⍞000D       ¯1 ¯1 ¯1  1           ¯38⍞000D    --------------           ---⍞000D     0  1  1  0 ¯1            35⍞000D    --------------           ---⍞000D    ¯1 ¯1     1    ← carry⍞000D⍞000D(subtraction is just addition of the negative of the subtrahend).⍞000D⍞000DMultiplication⍞000D--------------⍞000DWe use high-school long-multiplication with the following table:⍞000D⍞000D     ×  ¯1   0   1⍞000D       ┌───┬───┬───┐⍞000D    ¯1 │ 1 │ 0 │¯1 │⍞000D       ├───┼───┼───┤⍞000D     0 │ 0 │ 0 │ 0 │⍞000D       ├───┼───┼───┤⍞000D     1 │¯1 │ 0 │ 1 │⍞000D       └───┴───┴───┘⍞000D⍞000DFor example:⍞000D⍞000D           1  0 ¯1  1           25 ×⍞000D             ¯1  1  1           ¯5⍞000D          -----------         ----⍞000D    ¯1  0  1 ¯1  0  0 +       ¯225 +⍞000D        1  0 ¯1  1  0           75⍞000D           1  0 ¯1  1           25⍞000D    -----------------         ----⍞000D    ¯1  1  1  1  0  1         ¯125⍞000D    -----------------         ----⍞000D          ¯1⍞000D⍞000DDivision⍞000D--------⍞000D[bt] uses standard high-school long division. See: eval.dws/notes.Long_division.⍞000D⍞000DFirst  the dividend is partitioned into two vectors p and s, where p has at most⍞000Dthe  same number of digits as the divisor (q) and s is a vector of the remaining⍞000Ddigits.  For  example,  if divisor q is 1 ¯1 ¯1 and the dividend is 1 ¯1 1 1 ¯1,⍞000Dthen p is 1 ¯1 1 and s is 1 ¯1.                                     └──p─┘ └s─┘⍞000D⍞000DMultiples (1 or ¯1) of q are repeatedly (actually, only once or twice) subtract-⍞000Ded  from  p  until  p lies in the half-closed interval from (and including) 0 to⍞000D(but excluding) q. Note that q might be negative, so this means:⍞000D⍞000D    q>0: (0≤p)∧(p<q)    ⍝ q positive: 0≤p<q⍞000D    q<0: (q<p)∧(p≤0)    ⍝ q negative: q<p≤0⍞000D⍞000DAt each step, the multiple (1 or ¯1) is added to the result r. When p is reduced⍞000Dto  lie  within the interval bounded by q, the result is multiplied by 3 (by ap-⍞000Dpending a 0) and the next digit from s is transferred to p. When s is exhausted,⍞000Dresult r and dividend p constitute the final quotient and remainder.⍞000D⍞000D(muse:⍞000D⍞000D    We can restate this procedure in →declarative← terms.⍞000D⍞000D    Here is a definition of BT-division in a pattern-matching notation.  Defined⍞000D    infix  function  names are underlined and an indented definition is local to⍞000D    its exdented predecessor. Lexical name-scope rules apply.  Functions bind to⍞000D    the right as in APL.  The name alphabet is extended with additional charact-⍞000D    ers  prime ('') and double-prime (").  White dots "·" are cosmetic and may be⍞000D    ignored.⍞000D⍞000D    Notice that there are no guards!  In this notation, pattern-matching is used⍞000D    as an _alternative_ to the guard mechanism. See min.dws for more on pattern-⍞000D    matching.⍞000D⍞000D    p div q = 0 div'' q part p                       ⍝ result 0, q-partitioned p⍞000D      ¯¯¯       ¯¯¯    ¯¯¯¯⍞000D    ·   r div'' p s = r div" p s, p in q             ⍝ p in interval [0..q)⍞000D    ·   · ¯¯¯          ¯¯¯         ¯¯⍞000D    ·   ·   r div" p ⍬ 1 = r p                      ⍝ null s: quotient remainder⍞000D    ·   ·     ¯¯¯⍞000D    ·   ·   r div" p s 1 = (r,0) div'' p xfer s      ⍝ shift of dividend and rslt⍞000D    ·   ·   · ¯¯¯                ¯¯¯    ¯¯¯¯⍞000D    ·   ·   ·   p xfer s = (p,1↑s) (1↓s)            ⍝ transfer of next digit.⍞000D    ·   ·   ·     ¯¯¯¯⍞000D    ·   ·   r div" p s 0 = (r + m) div'' (p-m×q) s   ⍝ rslt +← m, dividend -← m×q⍞000D    ·   ·   · ¯¯¯             ¯    ¯¯¯    ¯ ¯⍞000D    ·   ·   ·   m = ×/×p q                          ⍝ multiple: ¯1 or 1.⍞000D    ·   ·   ·         ¯⍞000D    ·   ·   p in q = p in'' q (q>0)                  ⍝ p in half-interval [0..q)⍞000D    ·   ·   · ¯¯       ¯¯      ¯⍞000D    ·   ·   ·   p in'' q 1 = (0≤p)∧(p<q)             ⍝ q positive: 0≤p<q⍞000D    ·   ·   ·     ¯¯          ¯     ¯⍞000D    ·   ·   ·   p in'' q 0 = (-p) in (-q)            ⍝ q negative: q<p≤0⍞000D    ·   ·   ·     ¯¯         ¯   ¯¯  ¯⍞000D    ·   q part p = (min↑p)(min↓p)                   ⍝ q-partition of p.⍞000D    ·   · ¯¯¯¯⍞000D    ·   ·   min = (⍴p) ⌊ ⍴q                         ⍝ minimum number of digits.⍞000D⍞000D    where:⍞000D        p q r s         are BT numbers.⍞000D        ↑ ↓ ∧ ⌊ ⍴ ,     are regular APL functions on numeric vectors.⍞000D        + - × > ≤ <     are BT functions on BT numbers.⍞000D)       ¯ ¯ ¯ ¯ ¯ ¯⍞000D⍞000DAs  a  worked  example, let''s divide 1 ¯1 1 1 by ¯1 1 1, giving quotient ¯1 1 1,⍞000Dremainder  ¯1 0.  In the commentary, q refers to the divisor ¯1 1 1, p refers to⍞000Dthe current residue, and r to the result:⍞000D⍞000D                     ¯1  1  1       ⍝ quotient: ¯5⍞000D                        ¯1          ⍝ (¯1 → ¯1 1 in second step below)⍞000D                 ┌────────┬──⍞000D        ¯1  1  1 │ 1 ¯1  1  1       ⍝ ~ q < p ≤ 0:⍞000D                   1 ¯1 ¯1          ⍝   p -← ¯1 × q  ⋄  r +← ¯1  ⍝ r: 0 → ¯1⍞000D                  --------          ⍝⍞000D                      1 ¯1          ⍝ ~ q < p ≤ 0:⍞000D                   1 ¯1 ¯1          ⍝   p -← ¯1 × q  ⋄  r +← ¯1  ⍝ r: ¯1 → ¯1 1⍞000D                  --------          ⍝⍞000D                     ¯1  0          ⍝   q < p ≤ 0: append next digit.⍞000D                     ¯1  0  1       ⍝ ~ q < p ≤ 0:⍞000D                     ¯1  1  1       ⍝   p -← 1 × q  ⋄  r +← 1  ⍝ r:¯1 1 → ¯1 1 1⍞000D                     --------       ⍝   q < p ≤ 0: no more digits.⍞000D                        ¯1  0       ⍝ remainder: ¯3⍞000D⍞000D(NB: if you try this method using pencil and paper, you might find it convenient⍞000D to  negate  the  multiple  of the divisor as you write it under the dividend at⍞000D each stage, and then use addition rather than subtraction:⍞000D⍞000D                  ¯1⍞000D                 ┌───────────⍞000D        ¯1  1  1 │ 1 ¯1  1  1⍞000D                  ¯1  1  1  ← add negative of multiple⍞000D                  --------⍞000D                      1 ¯1⍞000D                  ...⍞000D)⍞000D⍞000DDivision by (powers of) 3⍞000D-------------------------⍞000DTo divide a BT number by 3 (rounding down the result) we add ¯1; then all digits⍞000Dbut  the last constitute the integer quotient and the last digit + 1 is the rem-⍞000Dainder. Using the example 86÷3 → 28r2:⍞000D⍞000D    1  0  1 ¯1 ¯1 +      86 +⍞000D               ¯1        ¯1⍞000D    -------------⍞000D    1  0  0  1  1 +      85⍞000D    └────┬───┘  1⍞000D         │   ----⍞000D         │   1 ¯1⍞000D         │   └─┬┘⍞000D         │     └────── remainder  2⍞000D         └──────────── quotient  28⍞000D⍞000DMore  generally, to divide a BT number by 3*⍵, we add ⍵⍴¯1 digits, then the int-⍞000Deger quotient is all but the rightmost ⍵ digits, and rightmost ⍵ digits + ⍵⍴1 is⍞000Dthe remainder. For example, to divide 54321 by 81 (81=3*4):⍞000D⍞000D    54321÷81 → 670r51:⍞000D⍞000D      1  0 ¯1  1  0 ¯1 ¯1 ¯1  0 ¯1  0 +     ⍝ 54321⍞000D                          ¯1 ¯1 ¯1 ¯1       ⍝ (3⍟81)⍴¯1⍞000D     --------------------------------⍞000D      1  0 ¯1  1 ¯1  1  1  0  1  1 ¯1 +⍞000D      └────────┬────────┘  1  1  1  1       ⍝ (3⍟81)⍴1⍞000D               │           ----------⍞000D               │        1 ¯1  0 ¯1  0⍞000D               │        └─────┬─────┘⍞000D               │              └─────── remainder 51⍞000D               └────────────────────── quotient 670⍞000D⍞000D[bt] uses fast division by 3 to implement power (⍺ *bt ⍵).⍞000D⍞000DOther fast divisors⍞000D-------------------⍞000DLeRoy Eide has an algorithm for fast division-by-2 of BT numbers. The method may⍞000Dbe  generalised  to division by numbers of the form ¯1 1+3*⍵, which include such⍞000Duseful divisors as 2 4 8 and 10. See →JitSub←⍞000D⍞000DNote  that  the  parity  (2|) of a BT number is just the parity of the (absolute⍞000Dvalue of the) sum of its digits. For a proof, see: eval.dws/notes.proof.⍞000D⍞000D        ↑+bt/ 1 ¯1 ¯1 ¯1 0              ⍝ bt-sum of digits → ¯2 (even)⍞000D    ¯1 1⍞000D        ↑+bt/ ↑+bt/ 1 ¯1 ¯1 ¯1 0        ⍝ bt-sum bt-sum of digits → 0 (even)⍞000D    0⍞000D        ↑∘(+bt/)⍣≡ 1 ¯1 ¯1 ¯1 0         ⍝ bt-sum →limit← of digits → 0 (even)⍞000D    0⍞000D        ↑∘(+bt/)⍣≡ 99⍴¯1                ⍝ bt-sum limit of ¯1 ¯1 .. ¯1 → ¯1 (odd)⍞000D    ¯1⍞000D        |↑∘(+bt/)⍣≡¨ ⊤bt¨ ¯10 to 10⍞000D    0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0⍞000D⍞000DPower ⍺*⍵ (⍵≥0)⍞000D---------------⍞000DFor  ⍺*⍵, we avoid calculating ⍵ products  ⍺ × ⍺ × ···,  by using the recurrence⍞000Drelation:                                  └─── ⍵ ───┘⍞000D⍞000D    ⍺*0 = 1⍞000D    ⍺*1 = ⍺⍞000D    ⍺*2 = ⍺×⍺⍞000D    ⍺*⍵ = (⍺*3|⍵) × {⍵×⍵×⍵} ⍺*⌊⍵÷3⍞000D⍞000Dwhich  needs  only  O(3×3⍟⍵)  products. 3|⍵ and ⍵÷3 use the fast division method⍞000Doutlined above.⍞000D⍞000DExtension to fractional numbers⍞000D-------------------------------⍞000DOperator [bt] deals only in integers.  Balanced ternary numbers extend nicely to⍞000Dfractional values using a "ternary point", as the following sequence shows:⍞000D⍞000D    decimal         balanced ternary⍞000D    -------         ----------------⍞000D    120             1 1 1 1 0⍞000D    120÷3             1 1 1 1⍞000D    120÷9               1 1 1 . 1⍞000D    120÷27                1 1 . 1 1⍞000D    120÷81                  1 . 1 1 1⍞000D    120÷243                 0 . 1 1 1 1⍞000D⍞000D... and so on.⍞000D⍞000DFractional  BT  numbers  have  the pleasant property that truncating them on the⍞000Dright  rounds  to  the  nearest number; in other words truncation is the same as⍞000Drounding.⍞000D⍞000DNotice that, in common with all number bases, a rational number, whose denomina-⍞000Dtor contains prime factors other than those of the base, gives rise to an infin-⍞000Ditely  repeated  fractional sequence. Specifically, with BT numbers, this occurs⍞000Dif  the  divisor  has prime factors other than 3. Here are some decimal rational⍞000Dnumbers together with their BT equivalents:⍞000D⍞000D    1÷3     0  .  1⍞000D    2÷3     1  . ¯1⍞000D    1÷9     0  .  0  1⍞000D    2÷9     0  .  1 ¯1⍞000D    1÷2     0  .  1  1  1  1 ...⍞000D    1÷4     0  .  1 ¯1  1 ¯1 ...⍞000D    1÷8     0  .  0  1  0  1 ...⍞000D    1÷10    0  .  0  1  0 ¯1 0 1 0 ¯1 ...⍞000D⍞000DNotice  also that, in common with decimal notation, some BT numbers have altern-⍞000Dative representations. For example, in decimal, one half may be expressed either⍞000Das 0.5 or as 0.4999... Similarly, in BT notation, one half may be written either⍞000Das 0 . 1 1 1 ... or as 1 .¯1 ¯1 ¯1 ...⍞000D⍞000DFor more on fractional BT numbers, see →ratsum← and →ratrep←.⍞000D⍞000DHistorical notes⍞000D----------------⍞000DIn  1840, Thomas Fowler, a contemporary of Charles Babbage, designed and built a⍞000Dbalanced ternary calculating machine. See:⍞000D⍞000D    http://www.mortati.com/glusker/fowler/index.htm⍞000D    http://www.ThomasFowler.org.uk⍞000D⍞000DIn  the early days of electronic computing, several attempts were made to employ⍞000D3-state  logic, in which case balanced ternary was a natural coding for numbers.⍞000DNotable among  these were the Russian Setun (1958) and Setun-70 (1970) machines.⍞000DSee:⍞000D⍞000D    http://www.computer-museum.ru/english/setun.htm⍞000D⍞000DExamples:⍞000D⍞000D    1 0 1 +bt 1 0 1             ⍝ 10+10 → 20⍞000D1 ¯1 1 ¯1⍞000D⍞000D    1 0 1 -bt 1 ¯1 1 ¯1         ⍝ 10-20 → ¯10⍞000D¯1 0 ¯1⍞000D⍞000D    1 0 1 ×bt 1 0 1             ⍝ 10×10 → 100⍞000D1 1 ¯1 0 1⍞000D⍞000D    1 0 1 *bt 1 0 1             ⍝ 10*10 → 10,000,000,000⍞000D1 0 0 ¯1 ¯1 1 1 0 ¯1 1 ¯1 1 0 ¯1 0 ¯1 0 1 0 1 0 1⍞000D⍞000D    ⊤bt 100                     ⍝ integer to BT⍞000D1 1 ¯1 0 1⍞000D⍞000D    ⊥bt 1 1 ¯1 0 1              ⍝ BT to integer⍞000D100⍞000D⍞000DSee also: abc nats rats ratsum to limit stamps⍞000DSee also: eval.dws/notes.bta⍞000DSee also: JitSub ratrep⍞000DSee also: ary ratsum phinary⍞000D⍞000DIndex:balanced ternary|ternary|Setun computer⍞000DIndex:pattern-matching|declarative programming|division, long⍞000DIndex;Fowler T.|Eide L.N.|Knuth D.E.|Babbage C.' 
