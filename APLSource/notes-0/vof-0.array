'rslt ← {larg} {''''} ##.vof F vof G vof ··· rarg      ⍝ Vector of functions.⍞000D⍞000DFrom Phil Last:⍞000D⍞000D[vof]  simulates  the distribution of a "vector of functions" among the items of⍞000Dits  argument(s).  It  can be illustrated by the practical problem: "What is the⍞000Dsize  of the rectangle that bounds these three rectangles, with B and C side-by-⍞000Dside and below A?".⍞000D⍞000D    ┌──────────────────────────┐⍞000D    │             A            │⍞000D    │                          │⍞000D    ├────────────┬─────────────┴──┐⍞000D    │            │                │⍞000D    │            │       C        │⍞000D    │     B      │                │⍞000D    │            │                │⍞000D    │            ├────────────────┘⍞000D    │            │⍞000D    └────────────┘⍞000D⍞000DThe answer is:⍞000D⍞000D    ((1↑⍴A) + (1↑⍴B) ⌈ (1↑⍴C)) , (¯1↑⍴A) ⌈ (¯1↑⍴B) + (¯1↑⍴C)⍞000D⍞000Dbut it would be much nicer to be able to say:⍞000D⍞000D    (⍴A) (+⌈) (⍴B) (⌈+) (⍴C)⍞000D⍞000DA diagram shows the distribution of functions with respect to argument items:⍞000D⍞000D         ┌─────┬────────┬─────┬────────┐⍞000D         │     │        │     │        │⍞000D    (⍴A)[0 1] (+⌈) (⍴B)[0 1] (⌈+) (⍴C)[0 1]⍞000D           │    │         │    │         │⍞000D           └────┴─────────┴────┴─────────┘⍞000D⍞000Dwhere  (+⌈)  and  (⌈+) are both 2-item "function vectors" to be distributed over⍞000Dtheir  2-item  argument(s). Compare this with the way that a vector of namespace⍞000Dreferences in a function expression, distributes its function over its arguments⍞000Dwithout needing to specify each:⍞000D⍞000D    (ref0 ref1 ref2 ref3).{···w} ⍳4⍞000D⍞000DMore generally:⍞000D⍞000D    a b c···(f g h···) x y z··· ←→ (a f x)(b g y)(c h z)··· ⍝ vector vector⍞000D⍞000D       (⊂a) (f g h···) x y z··· ←→ (a f x)(a g y)(a h z)··· ⍝ scalar vector⍞000D⍞000D    a b c···(f g h···) ⊂x       ←→ (a f x)(b g x)(c h x)··· ⍝ vector scalar⍞000D⍞000D       (⊂a) (f g h···) ⊂x       ←→ (a f x)(a g x)(a h x)··· ⍝ scalar scalar⍞000D⍞000D            (f g h···) x y z··· ←→ (f x)(g y)(h z)···       ⍝ monadic vector⍞000D⍞000D            (f g h···) ⊂x       ←→ (f x)(g x)(h x)···       ⍝ monadic scalar⍞000D⍞000D[vof]  implements  the  distributive  function vector in the alternating mode we⍞000Dhave seen with →of←, →case← and →lof←.⍞000D⍞000D    {a b c ···} {''''} vof f vof g vof h ··· x y z⍞000D⍞000DAs  with  →lof←  we need (except in special circumstances) the closing call with⍞000Dthe  null  function.  An  alternative  would  be to provide a slightly different⍞000D"special" coding for the leftmost operator:⍞000D⍞000D    _vof←{                          ⍝ Close vector of functions.⍞000D        ⍺←⊂                         ⍝ ⍺ elided: ⊂⍵.⍞000D        (al ar)(wl wr)←⍺ ⍵          ⍝ distrubute arg(s).⍞000D        1≡⍺ 1:(⍺⍺ wl)(⍵⍵ wr)        ⍝ mondadic.⍞000D        (al ⍺⍺ wl)(ar ⍵⍵ wr)        ⍝ dyadic.⍞000D    }⍞000D⍞000DAlthough more expensive,  the following coding works without a terminator to the⍞000Dleft.  The control over the iteration is the length of the data so if the number⍞000Dof functions is different it goes wrong as do the others.⍞000D⍞000DUses the same method of self reference as the coding of fk in →fork←:⍞000D⍞000D    vof←{⍞000D        (M D)←112358314594370 774156178538190⍞000D        ⍺←M⍞000D        (m d)←M D∊⊂⍺⍞000D        e←2∊⍴⍵⍞000D        e<m:(M ⍺⍺ ¯1↓⍵),⊂⍵⍵⊃⊢/⍵⍞000D        e<d:(D ⍺⍺ ¯1↓⍵),⍵⍵/⊃⊢/⍵⍞000D        e∧m:⊃⍺⍺{(⍺⍺ ⍺)(⍵⍵ ⍵)}⍵⍵/⍵⍞000D        e∧d:⊃⍺⍺{(⍺⍺/⍺),⍵⍵/⍵}⍵⍵/⍵⍞000D        D ∇ ⍺{⍺ ⍵}¨⍵⍞000D    }⍞000D⍞000DExamples:⍞000D⍞000D    1 2 3 4 {''''} vof + vof ! vof ? vof | 5 6 7 8        ⍝ vector vector⍞000D6 15  1 6 4  0⍞000D⍞000D          4 {''''} vof + vof ! vof ? vof | 5 6 7 8        ⍝ scalar vector⍞000D9 15  4 2 1 5  0⍞000D⍞000D    1 2 3 4 {''''} vof + vof ! vof ? vof | 5              ⍝ vector scalar⍞000D6 10  4 5 2  1⍞000D⍞000D          4 {''''} vof + vof ! vof ? vof | 5              ⍝ scalar scalar⍞000D9 5  3 5 1 4  1⍞000D⍞000D            {''''} vof + vof ! vof ? vof | 5 6 7 8        ⍝ monadic vector⍞000D5 720 1 8⍞000D⍞000D            {''''} vof + vof ! vof ? vof | 5              ⍝ monadic scalar⍞000D5 120 2 5⍞000D⍞000D    {2⍴⍵} vof {3⍴⍵} vof {4⍴⍵} 2 3 4                     ⍝ without left closure⍞000D┌─┬─┬─────┬───────┐⍞000D│2│2│3 3 3│4 4 4 4│⍞000D└─┴─┴─────┴───────┘⍞000D⍞000D    {⍬} vof {2⍴⍵} vof {3⍴⍵} vof {4⍴⍵} 2 3 4             ⍝ explicit left closure⍞000D┌───┬─────┬───────┐⍞000D│2 2│3 3 3│4 4 4 4│⍞000D└───┴─────┴───────┘⍞000D⍞000D    {2⍴⍵} _vof {3⍴⍵} vof {4⍴⍵} 2 3 4                    ⍝ closure using [_vof]⍞000D┌───┬─────┬───────┐⍞000D│2 2│3 3 3│4 4 4 4│⍞000D└───┴─────┴───────┘⍞000D⍞000DNotice that the length of the result is the number of functions, not necessarily⍞000Dthe length of the argument(s).⍞000D⍞000DSee also: case of lof Function_arrays co_ops⍞000D⍞000DIndex:function array|vector of functions|fork|co-operator⍞000DIndex;Last P.' 
