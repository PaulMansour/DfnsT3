'rslt ← {larg} (op ##.sbst) rarg                 ⍝ Simple Binary Search Trees.⍞000D⍞000D     T∆ ← T ∪ sbst (key val)    ⍝ tree ⍺ with key=val ⍵.⍞000D     T∆ ← T ~ sbst key          ⍝ tree ⍺ without key ⍵.⍞000D     T∆ ← T ⍎ sbst key          ⍝ value for key ⍵ in tree ⍺.⍞000D     T∆ ←   = sbst T            ⍝ balanced tree.⍞000D    fmt ←   ⍕ sbst T            ⍝ format of tree ⍵.⍞000D    vec ←   ∊ sbst T            ⍝ enlist of tree ⍵.⍞000D    chk ←   ? sbst T            ⍝ stats for tree ⍵: ok size mean_depth height.⍞000D⍞000DSee →BST←⍞000D⍞000D[sbst]  implements the simplest form of binary search tree (BST) with no attempt⍞000Dto keep the tree balanced. This means that it performs well only if the keys are⍞000Dinserted in random order or the tree is periodically rebalanced.⍞000D⍞000DTechnical notes:⍞000D⍞000DIn  contrast  with the other BST operators, [sbst] includes a balancing function⍞000D=sbst, which uses the DSW algorithm [0] and works as follows.⍞000D⍞000DFirst,  the  tree is stripped into a degenerate left list, or "vine". A vine may⍞000Dbe pictured as a stem supporting (initially depth-0) leaves,  each of which is a⍞000Dcomplete  tree.  Starting  at  the (leftmost) leaf and working back up the vine,⍞000Dalternate  sections are "compressed" by rotation, merging adjacent n-leaves into⍞000D(n+1)-leaves. The process is repeated until, after ⌈2⍟⍵ iterations the vine is a⍞000Dbalanced tree.⍞000D⍞000D                         left vine of 0-leaves⍞000D                             ···⍞000D                             /⍞000D                            O⍞000D                           ⌿⍞000D                          N⍞000D                         /⍞000D                        M⍞000D                       ⌿    ← alternate ⌿ edges are rotated.⍞000D                      L⍞000D                     /⍞000D                    K⍞000D                   ⌿⍞000D                  J⍞000D                 /       1-leaves →   2-leaves    →        3-leaves  →    ...⍞000D                I       ···          ···                  ···⍞000D               ⌿        /            /                    /⍞000D              H        N            L                    H⍞000D             /        ⌿ \          ⌿ \                  / \⍞000D            G        L   O        ⌿   \                /   \⍞000D           ⌿        / \          ⌿     \              /     \⍞000D          F        J   M        H       N            /       \⍞000D         /        ⌿ \          / \     / \          /         \⍞000D        E        H   K        /   \   M   0        /           \⍞000D       ⌿        / \          /     \              /             \⍞000D      D        F   I        D       J            D               L⍞000D     /        ⌿ \          / \     / \          / \             / \⍞000D    C        D   G        /   \   I   K        /   \           /   \⍞000D   ⌿        / \          /     \              /     \         /     \⍞000D  B        B   E        B       F            B       F       J       N⍞000D /        / \          / \     / \          / \     / \     / \     / \⍞000DA        A   C        A   C   E   G        A   C   E   G   I   K   M   O⍞000D⍞000DIf  the  vine  starts  with  exactly  ¯1+2*⍵  nodes, for some ⍵, the result is a⍞000Dperfectly  balanced tree. Otherwise, a pre-pass is required to reduce the length⍞000Dby  folding those adjacent 0-leaves over and above ¯1+2*⍵ to form 1-leaves. This⍞000Dproduces  a  vine with exactly ¯1+2*⍵ (0 or 1)-leaves, which becomes a tree that⍞000Dis  perfectly  balanced  except for extra nodes located at an incomplete deepest⍞000Dlevel. For example, a 10-node vine is reduced to a 7-node vine with 3 rotations:⍞000D⍞000D                      J ← vine with (3 + ¯1+2*3) 0-leaves.⍞000D                     ⌿⍞000D                    I   →   I ← vine with ¯1+2*3 (0 1)-leaves.⍞000D                   /       ⌿ \⍞000D                  H       G   J   →   G  ← compression to (1 2)-leaves.⍞000D                 ⌿       / \         / \⍞000D                G       E   H       ⌿   \⍞000D               /       ⌿ \         /     \⍞000D              F       D   F       D       I   →   D  ← complete tree⍞000D             ⌿       /           / \     / \     / \    with 3 extra⍞000D            E       C           B   E   H   J   /   \    nodes F H J⍞000D           /       ⌿           / \   \         /     \    at deepest⍞000D          D       B           A   C   F       /       \    level.⍞000D         /       /                           /         \⍞000D        C       A                           /           \⍞000D       /                                   /             \⍞000D      B                                   B               G⍞000D     /                                   / \             / \⍞000D    A                                   /   \           /   \⍞000D                                       /     \         /     \⍞000D                                      A       C       E       I⍞000D                                                       \     / \⍞000D                                                        F   H   J⍞000D⍞000DA  left-hanging  vine, which uses right rotation, is chosen because [sbst] has a⍞000Dhard-coded right rotation subfunction [rrot], used during node removal.⍞000D⍞000D                                                            B   →   A⍞000D    rrot←{                          ⍝ right rotation.      / \     / \⍞000D        B((A(p q))r)←⍵              ⍝ unpack nodes.       A   r   p   B⍞000D        A(p(B(q r)))                ⍝ repack nodes.      / \         / \⍞000D    }                               ⍝ :: t ← ∇ t        p   q       q   r⍞000D⍞000DClearly, right vines and left rotations would work just as well. Here is the DSW⍞000Dcode. Notice how the size of the tree is discovered by the enlisting function.⍞000D⍞000D    bal←{                           ⍝ dsw-balancing.⍞000D        vine size←0 0 list ⍵        ⍝ vine of 0-leaves and size.⍞000D        log←⌊2⍟size+1               ⍝ largest complete tree ≤ ⍵.⍞000D        rem←1+size-2*log            ⍝ no of surplus nodes.⍞000D        cmps←¯2+2*1+⍳log            ⍝ compression vector.⍞000D        ↑cmp/(1↓cmps,2×rem),⊂vine   ⍝ compression reduction → balanced tree.⍞000D    }                               ⍝ :: t ← ∇ t⍞000D⍞000D    cmp←{                           ⍝ compress of alternate vine sections.⍞000D        ⍺=0:⍵                       ⍝ far enough: terminal leaf.⍞000D        inf(lft rgt)←⍵              ⍝ parts of node.⍞000D        lev←(⍺-1)∇ lft              ⍝ leftmost vine leaf.⍞000D        2|⍺:inf(lev rgt)            ⍝ copying of alternate vine sections.⍞000D        rrot inf(lev rgt)           ⍝ rotation of alternate vine sections.⍞000D    }                               ⍝ :: t ← n ∇ v⍞000D⍞000D    list←{                          ⍝ list (0-vine) from tree ⍵.         /⍞000D        0≡⍵:⍺                       ⍝ null: accumulated vine.   /       C⍞000D        inf(lft rgt)←⍵              ⍝ node info & subtrees.    B   →   /⍞000D        lev s←⍺ ∇ lft               ⍝ left vine & size,       / \     B⍞000D        (inf(lev 0))(s+1)∇ rgt      ⍝ ++ right vine.         A   C   /⍞000D    }                               ⍝ :: v s ← v ∇ t                A⍞000D⍞000DAn  alternative  "brute force" method of rebalancing would be to take the vector⍞000Dof key=value pairs returned by ∊sbst and re-insert them sequentially into a null⍞000Dtree in an order that guarantees a good balance.⍞000D⍞000D    bal←{                               ⍝ rebalance of tree ⍵.⍞000D        pairs←∊sbst ⍵                   ⍝ vector of key=value pairs.⍞000D        order←{⍋⌽⍉((⌈2⍟⍵)/2)⊤⍳⍵}⍴pairs  ⍝ binary insert order.⍞000D        ⊃{⊃⍵ ∪sbst ⍺}/pairs[order],0    ⍝ new balanced tree.⍞000D    }                                   ⍝ :: t ← ∇ t⍞000D⍞000DHowever,  this method performs poorly compared with DSW, as it uses O(2∘⍟) comp-⍞000Darisons for each of ⍵ insertions:⍞000D⍞000D    tt ← 0 ∪sbst foldl 1000?1000    ⍝ 1,000-node tree.⍞000D⍞000D    cmpx''bal tt'' ''bal2 tt''          ⍝ compare with DSW.⍞000D  bal tt  2.2E¯1    0% ⎕⎕⎕⎕⎕⍞000D  bal2 tt 1.8E0  +715% ⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⍞000D⍞000DReferences:⍞000D⍞000D[0] ''DSW'' stands for Day-Stout-Warren:⍞000D⍞000D[1] Day A.C., Balancing a binary tree, Computer Journal 19.4, Nov 1976, 360-361.⍞000D⍞000D[2] Stout Q.F. Warren B.L., Tree Rebalancing in Optimal Time and Space,⍞000D    Comms ACM 29.9, Sept 1986, 902-908.⍞000D⍞000DExamples:⍞000D⍞000D    ⍕sbst 0 ∪sbst foldl⍳7           ⍝ no balancing if keys inserted in order.⍞000D1=1┐⍞000D   └2=2┐⍞000D       └3=3┐⍞000D           └4=4┐⍞000D               └5=5┐⍞000D                   └6=6┐⍞000D                       └7=7⍞000D⍞000D    ⍕sbst =sbst 0 ∪sbst foldl⍳7     ⍝ explicit rebalancing.⍞000D       ┌1=1⍞000D   ┌2=2┤⍞000D   │   └3=3⍞000D4=4┤⍞000D   │   ┌5=5⍞000D   └6=6┤⍞000D       └7=7⍞000D⍞000D    ⍝ vector of key=value pairs:⍞000D⍞000D    pairs ← (''one''1) (''two''2) (''three''3) (''four''4) (''five''5) (''six''6) (''seven''7)⍞000D⍞000D    tt←0 ∪sbst foldl pairs          ⍝ pairs folded into tree.⍞000D⍞000D    ⍕sbst tt                        ⍝ format of tree.⍞000D            ┌five=5⍞000D     ┌four=4┘⍞000Done=1┤⍞000D     │                   ┌seven=7⍞000D     │             ┌six=6┘⍞000D     │     ┌three=3┘⍞000D     └two=2┘⍞000D⍞000D    tt ← =sbst tt                   ⍝ balanced tree.⍞000D⍞000D    ⍕sbst tt⍞000D              ┌five=5⍞000D       ┌four=4┤⍞000D       │      └one=1⍞000Dseven=7┤⍞000D       │       ┌six=6⍞000D       └three=3┤⍞000D               └two=2⍞000D⍞000D    ''six''⍎sbst tt                   ⍝ value for key ''six''⍞000D6⍞000D    tt ← tt ~sbst''four''             ⍝ key ''four'' removed.⍞000D⍞000D    ⍕sbst tt⍞000D             ┌five=5⍞000D       ┌one=1┘⍞000Dseven=7┤⍞000D       │       ┌six=6⍞000D       └three=3┤⍞000D               └two=2⍞000D⍞000D    ∊sbst tt                        ⍝ vector of key=value pairs.⍞000D┌────────┬───────┬─────────┬───────┬─────────┬───────┐⍞000D│┌────┬─┐│┌───┬─┐│┌─────┬─┐│┌───┬─┐│┌─────┬─┐│┌───┬─┐│⍞000D││five│5│││one│1│││seven│7│││six│6│││three│3│││two│2││⍞000D│└────┴─┘│└───┴─┘│└─────┴─┘│└───┴─┘│└─────┴─┘│└───┴─┘│⍞000D└────────┴───────┴─────────┴───────┴─────────┴───────┘⍞000D⍞000D    ?sbst tt                        ⍝ tree stats: ok size mean_depth height.⍞000D1 6 2 3⍞000D⍞000D    ⍕sbst =sbst 0 ∪sbst foldl ⎕a    ⍝ balance of (11+¯1+2*4)-node tree.⍞000D           ┌A=A⍞000D       ┌B=B┤⍞000D       │   └C=C⍞000D   ┌D=D┤⍞000D   │   │   ┌E=E┐⍞000D   │   │   │   └F=F⍞000D   │   └G=G┤⍞000D   │       │   ┌H=H⍞000D   │       └I=I┤⍞000D   │           └J=J⍞000DK=K┤⍞000D   │           ┌L=L⍞000D   │       ┌M=M┤⍞000D   │       │   └N=N⍞000D   │   ┌O=O┤⍞000D   │   │   │   ┌P=P⍞000D   │   │   └Q=Q┤⍞000D   │   │       └R=R⍞000D   └S=S┤⍞000D       │       ┌T=T⍞000D       │   ┌U=U┤⍞000D       │   │   └V=V⍞000D       └W=W┤⍞000D           │   ┌X=X⍞000D           └Y=Y┤⍞000D               └Z=Z⍞000D⍞000D    ?sbst tt                        ⍝ tree stats: ok size mean_depth height.⍞000D1 6 2 3⍞000D⍞000DSee also: BST alists avl splay redblack⍞000D⍞000DIndex:tree|binary search tree|type notation|enlist⍞000DIndex;Day A.C.|Stout Q.F.|Warren B.L.' 
