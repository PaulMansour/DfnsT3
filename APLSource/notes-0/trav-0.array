'rslt ← ival (accm ##.trav subs) tree    ⍝ Generic depth-first tree traversal.⍞000Drslt ← ival (accm ##.ravt subs) tree    ⍝ trav: parent-first, ravt: parent last.⍞000D⍞000D[trav] and [ravt] traverse a [tree], applying left operand accumulating function⍞000D[accm] between the current value of the accumulator  (initial value [ival])  and⍞000Deach node. Right operand function [subs] is required to  return a (possibly emp-⍞000Dty) vector of subtrees for each node.⍞000D⍞000D[trav] and [ravt] differ only in the order in which they visit the nodes of  the⍞000Dsubject [tree].⍞000D⍞000D[trav] visits (applies [accm] to) the parent node before visiting any children.⍞000D                                                  ¯¯¯¯¯¯⍞000D[ravt] visits the parent node after visiting any children.⍞000D                              ¯¯¯¯¯⍞000DMnemonic: given this tree:⍞000D⍞000D      t         trav visits: t r a v⍞000D    ┌─┼─┐       ravt visits: r a v t⍞000D    r a v⍞000D⍞000DBoth left and right operand functions are ambi-valent, with the current accumul-⍞000Dator value as left argument and current node as right argument.  To  borrow  the⍞000Dtype notation developed in →foldl←:⍞000D⍞000D    trav ravt :: ⍺ (⍺ ∇ ⍵ → ⍺) ∇∇ (⍺ ∇ ⍵ → [⍵]) ⍵ → ⍺   ⍝ type of trav & ravt⍞000D⍞000DRight operand function [subs] "projects" a tree structure onto its  right  argu-⍞000Dment. [tree] could be concrete, as with a collection of nested  namespaces,  but⍞000Dcould equally be a _notional_ tree, which is not instantiated in the workspace.⍞000D⍞000DIn particular, successive arguments, produced during the evaluation  of  a  pure⍞000Drecursive function, may be viewed as a tree. This means that, theoretically, any⍞000Drelationship that can be expressed as a pure recursive function,  may  be  coded⍞000Dusing [trav] or [ravt]: the ⍵th Fibonacci  number; arithmetic functions, such as⍞000DGCD and Ackermann; the solution(s) of a Sudoku puzzle; the best next move  in  a⍞000Dgame of chess; and so on.⍞000D⍞000DAn alternative interpretation is that right operand [subs] replaces the task  at⍞000Dhand with 0 (base-case) or more sub-tasks and left  operand  [accm]  accumulates⍞000Dthe results of these sub-tasks to produce the answer.⍞000D⍞000DFor example, the ⍵th Fibonacci number may be expressed recursively as:⍞000D⍞000D    ⍵, if ⍵ is 0 or 1⍞000D    the sum of the previous two Fibonacci numbers, otherwise.⍞000D⍞000DLeading to this [trav] coding:⍞000D⍞000D    fib ← {⍺+⍵×⍵∊0 1} trav {(⍵-2 1)~-2 1}   ⍝ ⍵th fibonacci number⍞000D⍞000D    0 fib¨ 0 to 10                          ⍝ fibonacci sequence.⍞000D0 1 1 2 3 5 8 13 21 34 55⍞000D⍞000DThis trace operator shows  what''s happening by displaying accumulator ⍺ and node⍞000Dvalue ⍵ as a node is visited:⍞000D⍞000D    tc←{                    ⍝ Indented trace of node visit.⍞000D        depth←¯2+⍴⎕SI       ⍝ depth of recursion⍞000D        tab←∊depth⍴⊂''·   ''  ⍝ indentation vector⍞000D        ⎕←tab,⍕⍺ ⍵          ⍝ display of ⍺ and ⍵⍞000D        ⍺ ⍺⍺ ⍵              ⍝ node visit.⍞000D    }⍞000D⍞000D    0 {⍺+⍵×⍵∊0 1}tc trav {(⍵-2 1)~-2 1} 5       ⍝ fib 5⍞000D0 5⍞000D·   0 3⍞000D·   ·   0 1⍞000D·   ·   ·   1 0⍞000D·   ·   1 2⍞000D·   ·   ·   1 0⍞000D·   ·   ·   1 1⍞000D·   ·   ·   ·   2 0⍞000D·   2 4⍞000D·   ·   2 2⍞000D·   ·   ·   2 0⍞000D·   ·   ·   2 1⍞000D·   ·   ·   ·   3 0⍞000D·   ·   3 3⍞000D·   ·   ·   3 1⍞000D·   ·   ·   ·   4 0⍞000D·   ·   ·   4 2⍞000D·   ·   ·   ·   4 0⍞000D·   ·   ·   ·   4 1⍞000D·   ·   ·   ·   ·   5 0⍞000D5⍞000D⍞000D(muse:⍞000D·⍞000D·   The above naïve coding of the ⍵th Fibonacci is  very  inefficient.  Operator⍞000D·   →memo← effectively transforms the above _tree_ into the much smaller _graph_⍞000D·   which, by removing duplication, leads  to  an  evaulation  with  many  fewer⍞000D·   steps:⍞000D·⍞000D·   ┌─→─┐─→─┐─→─┐─→─┐─→─┐⍞000D·   5   4   3   2   1   0⍞000D·   └─→─┼─→─┤   │   │   │⍞000D·       └─→─┼─→─┤   │   │⍞000D·           └─→─┼─→─┤   │⍞000D·               └─→─┼─→─┤⍞000D·                   └─→─┘⍞000D)⍞000D⍞000DSometimes, there is only ever 1 (or 0 in the base case) sub-task.  In such cases⍞000Dwe have a "unary" tree (AKA "List") as for Euclid''s algorithm for Greatest Comm-⍞000Don Divisor →gcd←:⍞000D⍞000D    ⍵, if ⍺ is 0⍞000D    gcd of ⍵ and |⍵-⍺, otherwise⍞000D⍞000Dleading to this [trav] coding:⍞000D⍞000D    gcd ← ⊢ trav {|⍵-⍺~0}           ⍝ Euclid''s GCD.⍞000D⍞000D    35 gcd 55                       ⍝ cf: 15∨35⍞000D5⍞000D    35 ⊢tc trav {|⍵-⍺~0} 55         ⍝ traced evaluation⍞000D35 55⍞000D·   55 20⍞000D·   ·   20 35⍞000D·   ·   ·   35 15⍞000D·   ·   ·   ·   15 20⍞000D·   ·   ·   ·   ·   20 5⍞000D·   ·   ·   ·   ·   ·   5 15⍞000D·   ·   ·   ·   ·   ·   ·   15 10⍞000D·   ·   ·   ·   ·   ·   ·   ·   10 5⍞000D·   ·   ·   ·   ·   ·   ·   ·   ·   5 5⍞000D·   ·   ·   ·   ·   ·   ·   ·   ·   ·   5 0⍞000D·   ·   ·   ·   ·   ·   ·   ·   ·   ·   ·   0 5⍞000D5⍞000D⍞000D.. and this more efficient version, which uses residue in place of repeated sub-⍞000Dtraction:⍞000D⍞000D    35 |tc trav {⍺~0} 55            ⍝ traced evaluation⍞000D35 55⍞000D·   20 35⍞000D·   ·   15 20⍞000D·   ·   ·   5 15⍞000D·   ·   ·   ·   0 5⍞000D5⍞000D⍞000D(muse:⍞000D·⍞000D·   Perhaps, in cases where there can be more than one  sub-task at each node⍞000D·   (Fibonacci, chess problems, ...), an operator like [trav] could help with⍞000D·   organising their parallel evaluation, using multiple processors.⍞000D)⍞000D⍞000DTechnical notes:⍞000D⍞000DThe coding of the body of trav is surprisingly simple:⍞000D⍞000D    ⊃∇⍨/⌽(⊂⍺ ⍺⍺ ⍵),⍺ ⍵⍵ ⍵⍞000D     │└┬┘  └─┬──┘  └─┬──┘⍞000D     │ │     │       └──── (possibly empty) vector of sub-trees.⍞000D     │ │     └──────────── new value of accumulator.⍞000D     │ └────────────────── left-to-right reduction →foldl←⍞000D     └──────────────────── recursive call on (⍺⍺ trav ⍵⍵).⍞000D⍞000DAt first sight, the code appears to be missing a test to back out of the recurs-⍞000Dion after a leaf-node has been visited.  In fact, this occurs automatically:  if⍞000Dthe vector of sub-trees (⍺ ⍵⍵ ⍵) is empty, the  sub-expression: (⊂⍺ ⍺⍺ ⍵),⍺ ⍵⍵ ⍵⍞000Dis a 1-item vector and so the reduction ∇⍨/ passes it along  as  result  without⍞000Dapplying its operand function and thus avoiding the recursive call on trav.⍞000D⍞000D[ravt] is essentially the same but with the  accumulation (... ⍺⍺ ⍵)  following,⍞000Drather than preceding, the recursive call:⍞000D⍞000D        (⊃∇⍨/⌽(⊂⍺),⍺ ⍵⍵ ⍵)⍺⍺ ⍵      ⍝ visit nodes _after_ subnodes.⍞000D⍞000DIt is comforting to have the accumulator as left argument and the  subject  tree⍞000Don the right. Swapping (commuting) these arguments would give a slightly simpler⍞000Dcoding of the operator:⍞000D⍞000D    vart←{                          ⍝ commuted version of trav,⍞000D        ⊃∇/(⍵ ⍵⍵ ⍺),⊂⍺ ⍺⍺ ⍵         ⍝ ... produces simpler coding.⍞000D    }⍞000D⍞000Dat the expense of a correspondingly less intuitive coding for the [accm] operand⍞000Dfunction:⍞000D⍞000D    accm ← {((0=≡⍺)/⍺),⍵}           ⍝ accumulating simple scalars⍞000D    subs ← {(0≠≡⍵)/⍵}               ⍝ non-atoms for processing⍞000D    list ← accm vart subs           ⍝ accumulation of atoms.⍞000D⍞000D    ''ab''(''cd'' ''e'') list ''''⍞000Dabcde⍞000D⍞000D(muse:⍞000D·⍞000D·   Right operand [subs] determines how (for example) a nested array or a  coll-⍞000D·   ection of namespaces, constitute a tree. Given such an association, left op-⍞000D·   erand [accm] defines a _property_ of the resulting  tree, such as  its  size⍞000D·   (number of nodes or leaves) or the enlisted vector of its leaves.⍞000D·⍞000D·   "Right Operand Currying", where an operator''s right operand may be bound in-⍞000D·   dependently of its left operand, is useful in this situation. For example:⍞000D·⍞000D·       atree ← trav {(0≠≡⍵)/⍵}         ⍝ vector as tree.      Operand currying.⍞000D·                                       ⍝                      ¯¯¯¯¯¯¯⍞000D·       acount ← {⍺+1} atree            ⍝ property: node count.⍞000D·       aleaves ← {⍺,(0=≡⍵)/,⍵} atree   ⍝ property: leaf list.⍞000D·⍞000D·   By analogy, "Left _Argument_ Currying" would allow us to bind an initial ac-⍞000D·   cumulator value to produce a monadic derived function:⍞000D·⍞000D·       asize ← 0 acount                ⍝ array-as-tree size. Argument currying.⍞000D·       alist ← ⍬ aleaves               ⍝ enlist              ¯¯¯¯¯¯¯¯⍞000D·⍞000D·   Of course, left arguments may already be bound using the slightly less beau-⍞000D·   tiful composition:  asize ← 0∘acount  ⋄  alist ← ⍬∘aleaves⍞000D·⍞000D·   Either way:⍞000D·⍞000D·       asize (1 2)(3 4)                ⍝ tree size (see examples below).⍞000D·   7⍞000D·       alist ''ab''(''cd'' ''e'')            ⍝ enlist.⍞000D·   abcde⍞000D)⍞000D⍞000DNon-termination:⍞000D⍞000DIf the "tree" turns out to have cycles and is therefore a  more  general  graph-⍞000Dstructure, as may be the case with collections of  namespace  references,  it is⍞000Dnecessary to detect this condition to prevent further node traversal. Otherwise,⍞000Dthe traversal will fail to terminate. See example below.⍞000D⍞000DBreadth-first search⍞000D--------------------⍞000DThe equivalent coding for a breadth-first search, which visits all nodes at each⍞000Dlevel _before_ proceeding to any of their subnodes, is  slightly  more  complex.⍞000DSee also →search←.⍞000D⍞000D    bftrav←{⎕ML←1           ⍝ Generic breadth-first tree traversal.⍞000D        ⍺ ⍺⍺{⍞000D            0=⍴⍵:⍺⍞000D            (⍺ ⍺⍺⊃⍵)∇(1↓⍵),(⍺ ⍵⍵⊃⍵)⍞000D        }⍵⍵,⊂⍵⍞000D    }⍞000D⍞000D    subs ← {⍵.(1↓⍎¨''0'',↓⎕nl 9)}             ⍝ sub-namespaces for space ⍵.⍞000D⍞000D    ''t.r.rr'' ''t.a.aa'' ''t.v.vv'' ⎕ns¨ ⊂''''     ⍝ create tree.⍞000D⍞000D    tree t                                  ⍝ depth-2 tree.⍞000D#.t⍞000D·   a⍞000D·   ·   aa⍞000D·   r⍞000D·   ·   rr⍞000D·   v⍞000D·   ·   vv⍞000D⍞000D    ⍬ ,bftrav subs t                        ⍝ nodes in breadth-first order.⍞000D#.t #.t.a #.t.r #.t.v #.t.a.aa #.t.r.rr #.t.v.vv⍞000D⍞000DExamples:⍞000D⍞000D    subs ← {⍵.(1↓⍎¨''#'',↓⎕nl 9)}     ⍝ sub-namespaces for space ⍵.⍞000D⍞000D    accm ← {⍺+1}                    ⍝ counting nodes.⍞000D    0 accm trav subs #              ⍝ count of spaces.⍞000D3⍞000D    accm ← ,                        ⍝ accumulating into a vector.⍞000D    ⍬ accm trav subs #              ⍝ vector of spaces. C.f. →refs←⍞000D #  #.notes  #.scripts⍞000D⍞000D    ⍬ accm ravt subs #              ⍝ ravt visits node _after_ subnodes.⍞000D #.notes  #.scripts  #⍞000D⍞000D    usp ← {⍵.(1↓⍎¨''#'',↓⎕nl 9)~⍺}    ⍝ unique sub-spaces, ignoring cycles.⍞000D⍞000D    ''xy''⎕ns¨⊂''''                     ⍝ spaces x and y.⍞000D    (x y).(x y)←⊂x y                ⍝ create some cycles⍞000D⍞000D    ⍬ ∪ trav usp x                  ⍝ vector of spaces in graph. C.f. →refs←⍞000D #.x  #.y⍞000D⍞000D⍝ A (nested) array may be                           ┌─┴─┐⍞000D⍝ considered as a tree with         (1 2)(3 4) ←→  ┌┴┐ ┌┴┐⍞000D⍝ depth-0 items as leaves:                         1 2 3 4⍞000D⍞000D    subs ← {(0≠≡⍵)/,⍵}              ⍝ sub-items of array ⍵.⍞000D⍞000D    accm ← {⍺+1}                    ⍝ counting nodes.⍞000D    0 accm trav subs (1 2)(3 4)     ⍝ node-count⍞000D7⍞000D    accm ← {⍺,(0=≡⍵)/,⍵}            ⍝ accumulating simple scalars⍞000D    ⍬ accm trav subs ''ab''(''cd'' ''e'') ⍝ enlist⍞000Dabcde⍞000D⍞000D⍝ N-queens problem:⍞000D⍞000D    accm ← {⍺,(⍺⍺=⍴⍵)/⊂⍵}           ⍝ accumulated leaves.⍞000D⍞000D    subs←{⎕io←1                     ⍝ possible placements          \|/\  | \/| /⍞000D        dd←⌽⍳⍴⍵                     ⍝ diagonal                      ⍟  \ | /\|/⍞000D        ak←(⍵-dd),⍵,(⍵+dd)          ⍝ attacked cols in next row :       \|/  ⍟⍞000D        ⍵∘,¨(⍳⍺⍺)~ak                ⍝ subnodes                           ⍟⍞000D    }⍞000D⍞000D    ⍬(4 accm)trav(4 subs)⍬          ⍝ 4-queens solutions vector.⍞000D 2 4 1 3  3 1 4 2⍞000D⍞000D⍝ A similar expression for N-Queens using depth-first search is developed⍞000D⍝ in YouTube video:  https://www.youtube.com/watch?v=DsZdfnlh_d0⍞000D⍞000DSee also: refs acc foldl osc gcd search queens⍞000D⍞000DIndex:tree|currying|type notation|fibonacci number|N-Queens⍞000DIndex:depth-first search|breadth-first search|unary|YouTube' 
