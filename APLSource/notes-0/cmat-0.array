'mat ← m ##.cmat n                           ⍝ ⍺-combination matrix of ⍳⍵.⍞000D⍞000DReturns  an  m!n-row,  m-column, matrix of the m-item combination vectors of ⍳n.⍞000DBoth  rows  and  row  items  of  the result are in ascending order, thus for any⍞000D⍺ ⍵≥0:⍞000D⍞000D        {⍵≡⍳⍴⍵}⍋⍺ cmat ⍵            ⍝ Rows in ascending order.⍞000D⍞000D        ∧/{{⍵≡⍳⍴⍵}⍋⍵}¨↓⍺ cmat ⍵     ⍝ Items in each row in ascending order.⍞000D⍞000DTechnical notes:⍞000D⍞000DNotice that a combination matrix can be divided into sections, some of which are⍞000Dthemselves, combination matrices. For example:⍞000D⍞000D                             ┌─┬───┐              ┌───┐⍞000D                  1 2 3      │1│2 3│              │1 2│⍞000D                  1 2 4      │1│2 4│              │1 3│⍞000D                  1 2 5      │1│2 5│      1 , 1 + │1 4│     1 , 1 + 2 cmat 4⍞000D                  1 3 4      │1│3 4│              │2 3│⍞000D    3 cmat 5  =>  1 3 5  =>  │1│3 5│  =>    ⍪     │2 4│  =>   ⍪⍞000D                  1 4 5      │1│4 5│              │3 4│⍞000D                  2 3 4      ├─┴───┤              └───┘⍞000D                  2 3 5      │2 3 4│              ┌─────┐⍞000D                  2 4 5      │2 3 5│          1 + │1 2 3│       1 + 3 cmat 4⍞000D                  3 4 5      │2 4 5│              │1 2 4│⍞000D                             │3 4 5│              │1 3 4│⍞000D                             └─────┘              │2 3 4│⍞000D                                                  └─────┘⍞000D⍞000DThis observation leads to the recurrence relationship:⍞000D⍞000D    ⍺ cmat ⍵ ←→ (1,1+(⍺-1)cmat ⍵-1)⍪1+⍺ cmat ⍵-1⍞000D⍞000DSuccessive transformations of the expression on the right, produce:⍞000D⍞000D        Expression                              Transformation⍞000D        ----------                              --------------⍞000D        (1,1+(⍺-1)cmat ⍵-1)⍪1+⍺ cmat ⍵-1        [0] cmat → ∇⍞000D                  ¯¯¯¯          ¯¯¯¯⍞000D    →   (1,1+(⍺-1)∇⍵-1)⍪1+⍺ ∇⍵-1                [1] ⍺⍪⍵ → ↑⍪/⍺ ⍵⍞000D                       ¯⍞000D    →   ↑⍪/(1,1+(⍺-1)∇ ⍵-1)(1+⍺ ∇ ⍵-1)          [2] ⍺ ⍵ → ⌽ ⍵ ⍺⍞000D            ¯¯¯¯¯¯¯¯¯¯¯¯¯¯  ¯¯¯¯¯¯¯¯¯⍞000D    →   ↑⍪/⌽(1+⍺ ∇ ⍵-1)(1,1+(⍺-1)∇⍵-1)          [3] ⍺({}⍵) → {}\⍺ ⍵⍞000D                        ¯¯⍞000D    →   ↑⍪/⌽{1,⍵}\(1+⍺ ∇ ⍵-1)(1+(⍺-1)∇⍵-1)      [4] (1+⍺)(1+⍵) → 1+⍺ ⍵⍞000D                   ¯¯         ¯¯⍞000D    →   ↑⍪/⌽{1,⍵}\1+(⍺ ∇ ⍵-1)((⍺-1)∇⍵-1)        [5] (⍺{}⍵)(ß{}⍵) → ⍺ ß{}¨⊂⍵⍞000D                     ¯¯¯      ¯¯¯¯¯¯⍞000D    →   ↑⍪/⌽{1,⍵}\1+(⍺-0 1)¨∇⍵-1                [6]⍞000D⍞000DNotice  transformation[3]:  ⍺({}⍵) → {}\⍺ ⍵,  which  applies  a  function to the⍞000D_second_  item of a 2-vector. Using this technique, we can avoid temporary local⍞000Dnames in situations such as:⍞000D⍞000D    lft rgt←pair ⋄ lft({···⍵}rgt)           ⍝ clumsier.⍞000D⍞000D    {···⍵}\pair                             ⍝ neater.⍞000D⍞000DThe base cases for the recursion are:⍞000D⍞000D    0 cmat ⍵ → 1 0⍴0⍞000D    ⍺ cmat 0 → 0 ⍺⍴0⍞000D⍞000Dor:⍞000D    0∊⍺ ⍵:(⍺=0)⍺⍴0⍞000D⍞000DThe (index-origin independent) code is therefore:⍞000D⍞000D    cmat←{                              ⍝ ⍺-combination matrix of ⍳⍵.⍞000D        0∊⍺ ⍵:(⍺=0)⍺⍴0                  ⍝ done if zero ⍺ or ⍵, otherwise,⍞000D        ↑⍪/⌽{⎕IO,⍵}\1+(⍺-0 1)∇¨⍵-1      ⍝ catenate sub-combinations.⍞000D    }⍞000D⍞000DNotice  however,  that  the  algorithm is inefficient in the same way as a naïve⍞000Dcoding  of  →fibonacci←, in that the function is applied to the _same_ arguments⍞000Dmany  times  over. If we display the arguments for the function calls as a tree,⍞000Dby injecting:⍞000D⍞000D        ⎕←(,↑(⍴⎕LC)⍴⊂''·   ''),''['',(⍕⍺ ⍵),'']''⍞000D⍞000Das the first line of the function, we see the following "dependency tree", where⍞000D[⍺ ⍵] stands for (⍺ cmat ⍵):⍞000D⍞000D      2 cmat 4⍞000D·   [2 4]⍞000D·   ·   [2 3]⍞000D·   ·   ·   [2 2]⍞000D·   ·   ·   ·   [2 1]⍞000D·   ·   ·   ·   ·   [2 0]⍞000D·   ·   ·   ·   ·   [1 0]⍞000D·   ·   ·   ·   [1 1]⍞000D·   ·   ·   ·   ·   [1 0]⍞000D·   ·   ·   ·   ·   [0 0]⍞000D·   ·   ·   [1 2]⍞000D·   ·   ·   ·   [1 1]⍞000D·   ·   ·   ·   ·   [1 0]⍞000D·   ·   ·   ·   ·   [0 0]⍞000D·   ·   ·   ·   [0 1]⍞000D·   ·   [1 3]⍞000D·   ·   ·   [1 2]⍞000D·   ·   ·   ·   [1 1]⍞000D·   ·   ·   ·   ·   [1 0]⍞000D·   ·   ·   ·   ·   [0 0]⍞000D·   ·   ·   ·   [0 1]⍞000D·   ·   ·   [0 2]⍞000D⍞000DThis is interpreted:⍞000D⍞000D    [2 4] depends on⍞000D    ·   [2 3] which depends on⍞000D    ·   ·   [2 2] which depends on⍞000D    ·   ·   ···⍞000D        and⍞000D    ·   ·   [1 2] which depends on     ⍝ [1 2] evaluated here.⍞000D    ·   ·   ···⍞000D    and⍞000D    ·   [1 3] which depends on⍞000D    ·   ·   [1 2] which depends on     ⍝ [1 2] evaluated again here.⍞000D    ·   ·    ···⍞000D··· and so on.⍞000D⍞000DNotice  how [1 2], together with its whole sub tree, is evaluated twice. In this⍞000Dcase,  [2 4] generates 21 function calls. This number increases very rapidly and⍞000Din general, [⍵ ⍵] generates (¯1+2*⍵+1) calls.⍞000D                                                              ┌─┐     ┌───┐⍞000DThe dependencies are better represented as a _lattice_, where │↑│ and │←--│ mean⍞000D"depends on":                                                 │|│     └───┘⍞000D                                                              └─┘⍞000D    [2 4]←--[2 3]←--[2 2]←--[2 1]←--[2 0]⍞000D    ↑       ↑       ↑       ↑⍞000D    |       |       |       |⍞000D    [1 3]←--[1 2]←--[1 1]←--[1 0]⍞000D    ↑       ↑       ↑⍞000D    |       |       |⍞000D    [0 2]   [0 1]   [0 0]⍞000D⍞000DThis expresses exactly the same recurrence relationship as the tree, except that⍞000Din  this representation, the nodes are _shared_. Notice how the lattice has only⍞000D12,  as opposed to the tree''s 21 nodes. If we can find a way to evaluate each of⍞000Dits nodes only once, a significant performance benefit should result.⍞000D⍞000DIn  fact,  we can do a little better than this. We chose [⍺ 0] and [0 ⍵] as base⍞000Dcases for the recursion, because we can "conjure these results out of thin air".⍞000DLooking  at  the  lattice,  we see a column at the base of the "ramp", which has⍞000Dvalues  [2 2] [1 1] [0 0].  As  we  know that [⍵ ⍵] = (1 ⍵⍴⍳⍵) for all ⍵, we can⍞000Dequally  easily  use  [⍵ ⍵]  and [0 ⍵] as base cases, as long as we make special⍞000Dprovision  for starting values from _inside_ the ramp where ⍺>⍵. This enables us⍞000Dto trim the lattice to:⍞000D⍞000D    [2 4]←--[2 3]←--[2 2]⍞000D    ↑       ↑⍞000D    |       |⍞000D    [1 3]←--[1 2]←--[1 1]⍞000D    ↑       ↑⍞000D    |       |⍞000D    [0 2]   [0 1]⍞000D⍞000DA slightly larger example (4 cmat 8), shows more clearly what''s going on. Notice⍞000Dthat  this lattice has 24 nodes, while its corresponding dependency _tree_ would⍞000Dhave 325.⍞000D⍞000D    [4 8]←--[4 7]←--[4 6]←--[4 5]←--[4 4]⍞000D    ↑       ↑       ↑       ↑⍞000D    |       |       |       |⍞000D    [3 7]←--[3 6]←--[3 5]←--[3 4]←--[3 3]⍞000D    ↑       ↑       ↑       ↑⍞000D    |       |       |       |⍞000D    [2 6]←--[2 5]←--[2 4]←--[2 3]←--[2 2]⍞000D    ↑       ↑       ↑       ↑⍞000D    |       |       |       |⍞000D    [1 5]←--[1 4]←--[1 3]←--[1 2]←--[1 1]⍞000D    ↑       ↑       ↑       ↑⍞000D    |       |       |       |⍞000D    [0 4]   [0 3]   [0 2]   [0 1]⍞000D⍞000DThe  diagram  suggests  using  right-to-left  or  bottom-to-top  _reduction_  to⍞000Daccumulate  values towards the top left corner which is the required result. For⍞000Dreasons  that  will  become apparent, reduction from the right turns out to be a⍞000Dslightly better bet. Using ⎕ML←2, so that "↑" means "first":⍞000D⍞000D    ↑↑{⍺···⍵}/ [0 4] ··· [0 2] [0 1] ,⊂ [4 4] ··· [2 2] [1 1]⍞000D⍞000DNow,  as  the  [0 ⍵]''s  all have the same value: (1 0⍴0), we can substitute this⍞000Dvalue for ⍺ _inside_ the reduction''s operand and ignore the value that is passed⍞000Dinto  the  operand function as left argument. This means that we may replace the⍞000Dvector [0 4] ··· [0 2] [0 1] by _any_ vector providing it has the same number of⍞000Ditems:  (⍳⍵-⍺) will suffice.⍞000D⍞000D    ↑↑{(1 0⍴0)···⍵}/ (⍳⍵-⍺),⊂ [4 4] ··· [2 2] [1 1]⍞000D⍞000DFinally,  to  squeeze out the last drop of refinement, we can compute the little⍞000Darray  (1 0⍴0)  just  once and bind it as an operand to the reduction''s operand,⍞000Dwhere it becomes "⍺⍺".⍞000D⍞000D    ↑↑(1 0⍴0){⍺⍺···⍵}/ (⍳⍵-⍺),⊂ [4 4] ··· [2 2] [1 1]⍞000D⍞000DThe base cases: [4 4] ··· [2 2] [1 1], evaluate to ({1 ⍵⍴⍳⍵}¨+\⍺⍴1), noting that⍞000D(+\⍺⍴1) is an origin independent expression for "1 to ⍺", which gives:⍞000D⍞000D    ↑↑(1 0⍴0){⍺⍺···⍵}/ (⍳⍵-⍺),⊂{1 ⍵⍴⍳⍵}¨+\⍺⍴1⍞000D⍞000DAt this point, we can cover the "special provision" for the null case where ⍺>⍵.⍞000DThe result is a matrix of shape (0 ⍺), so the reshape becomes: (⍺≤⍵){⍺ ⍵⍴⍳⍵}.⍞000D⍞000D    ↑↑(1 0⍴0){⍺⍺···⍵}/ (⍳⍵-⍺),⊂(⍺≤⍵){⍺ ⍵⍴⍳⍵}¨+\⍺⍴1⍞000D⍞000DNow  all  that  remains,  is  to  code  the workings of the reduction''s operand:⍞000D{⍺⍺···⍵}. Each application of the operand will take a _column_ of the lattice as⍞000Dright argument and a nominal [0 ⍵] as left operand.⍞000D⍞000DTransposing  the  rightmost  column  of  the  lattice above, the operand will be⍞000D⍞000Dapplied to:    ⍵: [4 4]   [3 3]   [2 2]   [1 1]  ⍺⍺: [0 1]⍞000D                  ↓       ↓       ↓       ↓          ↓⍞000Dwith result:      [4 5]←--[3 4]←--[2 3]←--[1 2]←-----''⍞000D⍞000DTo  achieve  this  result,  we need to do a further, but this time, _cumulative_⍞000Dreduction. Without accumulation, the result of the "inner" reduction in the case⍞000Dabove  would be [4 5], whereas we need the whole vector [4 5] ··· [1 2], but ex-⍞000Dcluding the initial base case ⍺⍺:[0 1], to pass back to the outer reduction. The⍞000Dtemplate for such a reduction is:⍞000D⍞000D    ¯1↓↑{(⍺ ··· ↑⍵),⍵}/(⊂···),···,(⊂···),(⊂⊂···)⍞000D      ││     │  │  │    │          │      └────── _Extra_ rightmost enclosure,⍞000D      ││     │  │  │    │          │                      for accumulation.⍞000D      ││     │  │  │    └──────────┴───────────── Items of reduction argument.⍞000D      ││     │  │  └─── Prefix new result item to accumulation.⍞000D      ││     │  └────── First item of accumulated result.⍞000D      ││     └───────── Operation between successive left and right args.⍞000D      │└─────────────── Disclose vector result of vector reduction.⍞000D      └──────────────── Discard initial base case ⍺⍺:[0 1].⍞000D⍞000DSubstituting our specific cases:⍞000D⍞000D    ¯1↓↑{(⍺ ··· ↑⍵),⍵}/⍵,⊂⊂⍺⍺⍞000D⍞000DThe  remaining "···" is exactly the expression developed right back at the start⍞000Dfor the "tree" algorithm: ⍪/⌽{⎕IO,⍵}\1+···, so the complete operand function is:⍞000D⍞000D    ¯1↓↑{(⍪/⌽{⎕IO,⍵}\1+⍺(↑⍵)),⍵}/⍵,⊂⊂⍺⍺⍞000D⍞000DA last tweak is to "factor out" (⊂⊂⍺⍺) to where ⍺⍺ is generated, so that:⍞000D⍞000D        ···(1 0⍴0){···{···}/⍵,⊂⊂⍺⍺}/···⍞000Dbecomes:    __                ¯¯⍞000D        ···(⊂⊂1 0⍴0){···{···}/⍵,⍺⍺}/···⍞000D⍞000DThe final code looks like this. Notice that apart from the specification of ⎕ML,⍞000Dit''s  a one-liner. More to the point, there are no assignments, tests or control⍞000Dbranches; it is a single expression:⍞000D⍞000D    cmat←{⎕ML←2                             ⍝ ⍺-combination matrix of ⍳⍵.⍞000D        ↑↑(⊂⊂1 0⍴0){                        ⍝ base-case: [0 ⍵].⍞000D            ¯1↓↑{                           ⍝ removing base case from,⍞000D                (⍪/⌽{⎕IO,⍵}\1+⍺(↑⍵)),⍵      ⍝ accumulation of,⍞000D            }/⍵,⍺⍺                          ⍝ sub- (⍺ ⍵-1) combinations,⍞000D        }/(⍳0⌈⍵-⍺),⊂(⍺≤⍵){⍺ ⍵⍴⍳⍵}¨⌽+\⍺⍴1    ⍝ with base cases [⍺ 0].⍞000D    }⍞000D⍞000DAlternative codings⍞000D-------------------⍞000DJohn  Niss  Hansen  suggests  the  following  much  simpler coding. Effectively,⍞000Dthe  function  generates  all binary numbers of width ⍵ and selects those with ⍺⍞000Dbits set. Each binary "mask" is then used to select a different ⍺ combination of⍞000Dnumbers  from  0  to ⍵-1.  This  works  well  for small values of ⍵ but the sub-⍞000Dexpression  (⍳⍵⍴2)  uses  an  exponential  amount  of space (and time) as ⍵ gets⍞000Dlarger. The function assumes ⎕io=0 and ⎕ml<2.⍞000D⍞000D      cmat←{↑⌽((⍺=+/¨t)/t←,⍳⍵⍴2)/¨⊂⍳⍵}⍞000D⍞000DVMJ suggests the following one-line speedy alternative for small-to-medium sized⍞000Dresults.⍞000D⍞000D      cmat←{⎕ML←3 ⋄ ⊃⊃{{(</2↑[⎕IO+1]⊃⍵)/⍵},⍺∘.,⍵}/(⍳⍺)+⊂(-⎕IO)+⍳⍵-⍺-1}⍞000D⍞000Dand also:⍞000D⍞000D      cmat←{⍞000D           (⎕IO ⎕ML)←1 3 ⋄ wd←⍺ ⋄ mx←⍵⍞000D           ⊃↑2{⍺>wd:⍵⍞000D               a←2⊃⍵⍞000D               b←mx-a+wd-⍺ ⋄ q←∊a+⍳¨b⍞000D               (⍺+1)∇((b/↑⍵),¨q)q⍞000D           }2⍴⊂⍳⍵-⍺-1⍞000D       }⍞000D⍞000DThis  version  is based on Ken Gradney''s code, which was published in Vector Vol⍞000D18.1:⍞000D⍞000D      cmat←{⍞000D          ⎕ML←3 ⋄ n←1+⍵-⍺ ⋄ c←(⍺-1)+⍳n⍞000D⍞000D          c{⎕IO≥↑⍺:↑⍵⍞000D              m←⌽+\⌽↑1↓⍵⍞000D              (⍺-1)∇((m/⍺-1),(↑⍵)[∊((↑m)-m)+⍳¨m;])m⍞000D          }((n,1)⍴c)(n⍴1)⍞000D      }⍞000D⍞000D⍞000DRoger Hui proposes this short coding:⍞000D⍞000D      cmat←{⊖⊃⍪/{k,¨⍪\1+⍵}⍣⍺⊢(⊂⍉⍪⍬),d⍴⊂0 0⍴k←⌽⍳1+d←⍵-⍺}⍞000D⍞000Dwhich  is  faster than the others except on really large arguments (when it is a⍞000Dbit slower).⍞000D⍞000DRoger says:  The ⊖ is needed because Dyalog does not have "suffix scan" (⊖f⍀⊖⍵).⍞000DI am led to doing the regular APL scan on the reversed argument,  then reversing⍞000Dthe whole thing at the end.⍞000D⍞000DExamples:⍞000D⍞000D      display 0 cmat 5⍞000D┌⊖┐⍞000D↓0│⍞000D└~┘⍞000D⍞000D      display 1 cmat 5⍞000D┌→┐⍞000D↓1│⍞000D│2│⍞000D│3│⍞000D│4│⍞000D│5│⍞000D└~┘⍞000D⍞000D      display 2 cmat 5⍞000D┌→──┐⍞000D↓1 2│⍞000D│1 3│⍞000D│1 4│⍞000D│1 5│⍞000D│2 3│⍞000D│2 4│⍞000D│2 5│⍞000D│3 4│⍞000D│3 5│⍞000D│4 5│⍞000D└~──┘⍞000D⍞000D      display 3 cmat 5⍞000D┌→────┐⍞000D↓1 2 3│⍞000D│1 2 4│⍞000D│1 2 5│⍞000D│1 3 4│⍞000D│1 3 5│⍞000D│1 4 5│⍞000D│2 3 4│⍞000D│2 3 5│⍞000D│2 4 5│⍞000D│3 4 5│⍞000D└~────┘⍞000D⍞000D      display 4 cmat 5⍞000D┌→──────┐⍞000D↓1 2 3 4│⍞000D│1 2 3 5│⍞000D│1 2 4 5│⍞000D│1 3 4 5│⍞000D│2 3 4 5│⍞000D└~──────┘⍞000D⍞000D      display 5 cmat 5⍞000D┌→────────┐⍞000D↓1 2 3 4 5│⍞000D└~────────┘⍞000D⍞000D      display 6 cmat 5⍞000D┌→──────────┐⍞000D⌽0 0 0 0 0 0│⍞000D└~──────────┘⍞000D⍞000D      ⍉↑{⍴⍵ cmat 5}¨0 to 6                      ⍝ Row and column sizes.⍞000D1 5 10 10 5 1 0⍞000D0 1  2  3 4 5 6⍞000D⍞000D      2{⍵[⍺ cmat⍴⍵]}''scissors'' ''paper'' ''stone''  ⍝ 2-combos of nested vector.⍞000D scissors  paper⍞000D scissors  stone⍞000D paper     stone⍞000D⍞000D      ↓3{⍵[⍺ cmat⍴⍵]}''abcde''                    ⍝ 3-combos of char vector.⍞000D abc  abd  abe  acd  ace  ade  bcd  bce  bde  cde⍞000D⍞000D      display¨0 1 2 3∘.cmat 0 1 2 3             ⍝ Combos of small vectors.⍞000D ┌⊖┐      ┌⊖┐      ┌⊖┐      ┌⊖┐⍞000D ↓0│      ↓0│      ↓0│      ↓0│⍞000D └~┘      └~┘      └~┘      └~┘⍞000D ┌→┐      ┌→┐      ┌→┐      ┌→┐⍞000D ⌽0│      ↓1│      ↓1│      ↓1│⍞000D └~┘      └~┘      │2│      │2│⍞000D                   └~┘      │3│⍞000D                            └~┘⍞000D ┌→──┐    ┌→──┐    ┌→──┐    ┌→──┐⍞000D ⌽0 0│    ⌽0 0│    ↓1 2│    ↓1 2│⍞000D └~──┘    └~──┘    └~──┘    │1 3│⍞000D                            │2 3│⍞000D                            └~──┘⍞000D ┌→────┐  ┌→────┐  ┌→────┐  ┌→────┐⍞000D ⌽0 0 0│  ⌽0 0 0│  ⌽0 0 0│  ↓1 2 3│⍞000D └~────┘  └~────┘  └~────┘  └~────┘⍞000D⍞000D      ⎕io←0 ⋄ 2 cmat 4                          ⍝ Code is "origin sensitive".⍞000D0 1⍞000D0 2⍞000D0 3⍞000D1 2⍞000D1 3⍞000D2 3⍞000D⍞000D      ⍉ ∘.{⍬⍴⍴⍺ cmat ⍵}⍨ 0 to 12                ⍝ Pascal''s triangle.⍞000D1  0  0   0   0   0   0   0   0   0  0  0 0⍞000D1  1  0   0   0   0   0   0   0   0  0  0 0⍞000D1  2  1   0   0   0   0   0   0   0  0  0 0⍞000D1  3  3   1   0   0   0   0   0   0  0  0 0⍞000D1  4  6   4   1   0   0   0   0   0  0  0 0⍞000D1  5 10  10   5   1   0   0   0   0  0  0 0⍞000D1  6 15  20  15   6   1   0   0   0  0  0 0⍞000D1  7 21  35  35  21   7   1   0   0  0  0 0⍞000D1  8 28  56  70  56  28   8   1   0  0  0 0⍞000D1  9 36  84 126 126  84  36   9   1  0  0 0⍞000D1 10 45 120 210 252 210 120  45  10  1  0 0⍞000D1 11 55 165 330 462 462 330 165  55 11  1 0⍞000D1 12 66 220 495 792 924 792 495 220 66 12 1⍞000D⍞000DSee also: pmat fibonacci rr⍞000D⍞000DIndex:combination|expression transformation|Pascal''s triangle|fibonacci number⍞000DIndex:⎕ML⍞000DIndex;Hansen J.N.|Hui R.K.W.|Gradney K.|Jantunen V-M.' 
