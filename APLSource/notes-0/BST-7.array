'Binary Search Trees⍞000D-------------------⍞000DBinary search trees provide a way to store ordered information so that access is⍞000Dreasonably fast. An example of an application might be the storing of name=value⍞000Dpairs in a symbol table.⍞000D⍞000D    ┌───────────────────────────────────────────────────────────────────┐⍞000D    │ Binary Search Trees have an elegant structure and are interesting │⍞000D    │ to study. They are _almost_never_ the best way to store key=value │⍞000D    │ pairs in APL. For a more practical APL alternative, see →alists←. │⍞000D    └───────────────────────────────────────────────────────────────────┘⍞000D⍞000DThese  notes cannot do justice to the vast technical literature dealing with the⍞000Dproperties of binary trees, see below for some links.⍞000D⍞000D(⍞000D    NB: A previous coding of these operators used character vector tags as oper-⍞000D    ands (''put'' ''rem'' ''get'' ''fmt'' ''vec'' ''chk'')  to distinguish the cases.  Using⍞000D    primitive functions as operands is (arguably) more suggestive  about  what''s⍞000D    going on and reduces the need for parentheses to prevent the  binding of the⍞000D    operand with a left argument.  Note that the operand function is interpreted⍞000D    only as a label and is never applied as a function.⍞000D)⍞000D⍞000DDefn:  A Binary Tree  is  either Null or is a Node, containing some information,⍞000Dtogether with a left and a right subtree.⍞000D⍞000D    Tree ::= Null | Node info (Tree lft) (Tree rgt)⍞000D⍞000DDefn: A Binary Search Tree (BST) is a binary tree whose node information includ-⍞000Des a search key.  Each node in the tree has the property that its key is greater⍞000Dthan any of those in its left subtree and less than any of those  in  its  right⍞000Dsubtree.⍞000D⍞000DIn  addition,  the  node typically carries a "value" associated with the key. In⍞000Dother words, the nodes contain key=value pairs.⍞000D⍞000D        B=2                 key=val pairs stored in a BST⍞000D        / \⍞000D       /   \                Note that for each key K,⍞000D     A=1   E=5              Lft subtree keys < K,⍞000D           / \              Rgt subtree keys > K.⍞000D          /   \⍞000D        D=4   F=6⍞000D        /⍞000D       /⍞000D     C=3⍞000D⍞000DIf  we  are interested only in the structure and beauty of BSTs, the value for a⍞000Dnode  may  be  of  little  interest. For this reason, operators →sbst←, →splay←,⍞000D→avl← and →redblack← take either a key=value pair or just a scalar (character or⍞000Dnumeric) key. In the latter case, only the key is stored and is returned as val-⍞000Due by derived function [get]. This frees us to type simple expressions such as:⍞000D⍞000D    0 put foldl ⍳7      ⍝ tree with 1=1, 2=2, 3=3, ...⍞000D⍞000DSome terminology⍞000D----------------⍞000D                    This tree has a "height" of 4 (a null tree has height 0).⍞000D       B=2          This tree has a "size" of 6 (a null tree has size 0).⍞000D       / \          B is the "root".⍞000D      /   \         Nodes A B and C are at "depth" 1 0 and 3, respectively.⍞000D    A=1   E=5       A is B''s "left child".⍞000D          / \       E is B''s "right child".⍞000D         /   \      D is E''s "inner" (parent-side) child.⍞000D       D=4   F=6    F is E''s "outer" child.⍞000D       /            E is D''s (and F''s) "parent".⍞000D      /             B is D''s (and F''s) "grandparent".⍞000D    C=3             A is D''s (and F''s) "uncle". *⍞000D                    D is F''s "sibling".⍞000D                    D and F are A''s (inner and outer) "nephews". *⍞000D                    The size-2 tree D-C is E''s left or inner "subtree".⍞000D⍞000D                  * Most  treatments of trees appear to favour male relatives on⍞000D                    the parent''s sibling''s side. Of course, trees populated with⍞000D                    aunts and nieces would work just as well :-)⍞000DNulls⍞000D-----⍞000DWhen drawing BSTs, although it uses a little more space, it is sometimes conven-⍞000Dient to show nulls explicitly. Using ''∘'' as null, the above example becomes:⍞000D⍞000D          B=2⍞000D          / \⍞000D         /   \⍞000D        /     \⍞000D      A=1     E=5           BST showing Nulls (∘)⍞000D      / \     / \⍞000D     ∘   ∘   /   \⍞000D            /     \⍞000D          D=4     F=6⍞000D          / \     / \⍞000D         /   ∘   ∘   ∘⍞000D        /⍞000D      C=3⍞000D      / \⍞000D     ∘   ∘⍞000D⍞000DRotation⍞000D--------⍞000DBSTs  are transformed using left or right "rotation" of the edge that connects a⍞000Dnode to one of its subtrees. Rotation is an elementary operation, which preserv-⍞000Des the search-order of nodes.⍞000D⍞000DBy convention, this rotation of an edge is more usually termed a rotation of its⍞000Dupper node (vertex). For example, in the following diagram, upper node A is said⍞000Dto be rotated leftwards or counter-clockwise.⍞000D⍞000DNotice  how  the  rising  node''s inner subtree (q) is reconnected as the falling⍞000Dnode''s inner subtree.⍞000D⍞000DLeft Rotation of Node A (rotation of edge A-+-B):⍞000D⍞000D     ↓A                                                        B⍞000D     / ⍀                                                      ⌿ \⍞000D    p   B              A-+-B              A-+-B↑             A   r⍞000D       / \     =>     /  ←/ \     =>     / \   \     =>     / \⍞000D      q   r          p   q   r          p   q   r          p   q⍞000D⍞000DRight Rotation of Node B (rotation of edge A-+-B):⍞000D⍞000D        B↓                                                   A⍞000D       ⌿ \                                                  ⌿ \⍞000D      A   r            A-+-B             ↑A-+-B            p   B⍞000D     / \       =>     / \→  \     =>     /   / \     =>       / \⍞000D    p   q            p   q   r          p   q   r            q   r⍞000D⍞000DBalance⍞000D-------⍞000DUsing  rotation,  we  can see that a given set of search keys may be stored in a⍞000Dnumber  of different tree configurations. This number increases rapidly with the⍞000Dsize of the tree. Taking just 4 keys:⍞000D⍞000D        A           A           A           A           A⍞000D         \           \           \           \           \⍞000D          B           B           C           D           D⍞000D           \           \         / \         /           /⍞000D            C           D       B   D       B           C⍞000D             \         /                     \         /⍞000D              D       C                       C       B⍞000D⍞000D        B           B           C           C⍞000D       / \         / \         / \         / \          All possible BSTs⍞000D      A   C       A   D       A   D       B   D         for keys A B C D.⍞000D           \         /         \         /⍞000D            D       C           B       A⍞000D⍞000D        D           D           D           D           D⍞000D       /           /           /           /           /⍞000D      A           A           B           C           C⍞000D       \           \         / \         /           /⍞000D        B           C       A   C       A           B⍞000D         \         /                     \         /⍞000D          C       B                       B       A⍞000D⍞000DThe  number  of distinct ⍵-node binary trees is the Catalan number, which can be⍞000Dgenerated by:⍞000D⍞000D    catalan ← {(⍵!2×⍵)÷⍵+1}             ⍝ ⍵th Catalan number.⍞000D⍞000D    catalan¨ 0 to 15⍞000D1 1 2 5 14 42 132 429 1430 4862 16796 58786 208012 742900 2674440 9694845⍞000D⍞000Dor with this equivalent fork:⍞000D⍞000D    catalan ← 1∘+ ÷⍨ ⊢ ! +⍨⍞000D⍞000DJay Foad suggests this coding of Segner''s Recurrence Formula: Cn = C2×Cn-1 + C3×⍞000DCn-2 + ... + Cn-1×C2⍞000D⍞000D    {⍵,+/⍵×⌽⍵}⍣9⊢1                      ⍝ first 10 Catalan numbers⍞000D1 1 2 5 14 42 132 429 1430 4862⍞000D⍞000DSee: http://mathworld.wolfram.com/CatalanNumber.html⍞000D⍞000DThe  "height"  of the tree is defined to be the number of edges in the path from⍞000Dthe  root to the furthest Null.  In the diagrams above (which don''t show nulls),⍞000Dthe first and second trees have height 4 and the third, height 3.⍞000D⍞000DCommon Operations⍞000D=================⍞000DSearch, Insert/Replace and Remove operations, common to all of the BST operators⍞000Dare as follows.⍞000D⍞000DWe can express the methods simply in a pseudo-code using "A ∇ B → ..." as short-⍞000Dhand for "{A B←⍺ ⍵ ⋄ ...}" and "∘" as shorthand for Null.⍞000D⍞000DIn addition, ";", pronounced "where",  introduces a definition, which is _local_⍞000Dto the first preceding line that contains  fewer  semicolons.  This idea, dating⍞000Dfrom 1966 [ref 3], is known as "the off-side rule".⍞000D⍞000DFinally, ''·'' is used as a white-space character, to make it easier to keep track⍞000Dof indentation levels.⍞000D⍞000DIn  the following example, notice how the commentary corresponds very closely to⍞000Dthe function tokens.  This means that this "language" is sufficiently high-level⍞000Dto render commentary at this level of detail  superfluous, leaving  the  comment⍞000Dfield free for more abstract (higher-level) commentary.⍞000D⍞000D    avg ← ∇ vec →           ⍝ "avg ia a function which maps vec to⍞000D    ·   tot ÷ num           ⍝  tot divided by num,⍞000D    ·   ;   tot ← sum/vec   ⍝    where tot is the sum reduction of vec,⍞000D    ·   ;   ;   sum ← +     ⍝      where sum is plus⍞000D    ·   ;   num ← ⍴vec      ⍝    and where num is the shape of vec."⍞000D⍞000DSearch⍞000D------⍞000DWe  compare the sought key at each node, going left or right until we find it or⍞000Dreach a null, in which case, the key is not in the tree:⍞000D⍞000D    T ∇ K →                         ⍝ value associated with key K in tree T:⍞000D    ·   T ≡ ∘:   error!             ⍝ null T: K not in tree => error.⍞000D    ·   (Key Val)(Lft Rgt) ← T      ⍝ naming of parts of node.⍞000D    ·   K = Key: Val                ⍝ match:  value from this node.⍞000D    ·   K < Key: Lft ∇ K            ⍝ lower:  value from left subtree,⍞000D    ·   K > Key: Rgt ∇ K            ⍝ higher: value from right subtree.⍞000D⍞000DInsertion-Replacement⍞000D---------------------⍞000DAs  with  searching, we compare the key at each node, going left or right. If we⍞000Dfind  the key, we replace an existing value. Otherwise, we reach a null and ins-⍞000Dert the key=value pair as a new leaf of the tree.⍞000D⍞000D    T ∇ K V →                           ⍝ tree T with key(K)=value(V):⍞000D    ·   T ≡ ∘:   (K V)(∘ ∘)             ⍝ null T: new leaf node.⍞000D    ·   (Key Val)(Lft Rgt) ← T          ⍝ naming of parts of node.⍞000D    ·   K = Key: (K V)(Lft Rgt)         ⍝ match:  node with new value.⍞000D    ·   K < Key: (Key Val)(Lft∆ Rgt)    ⍝ lower:  put in left subtree, where⍞000D    ·   ;   Lft∆ ← Lft ∇ K V            ⍝ Lft∆ is left subtree with K=V⍞000D    ·   K > Key: (Key Val)(Lft Rgt∆)    ⍝ higher: put in right subtree, where⍞000D    ·   ;   Rgt∆ ← Rgt ∇ K V            ⍝ Rgt∆ is right subtree with K=V⍞000D⍞000DRemoval⍞000D-------⍞000DAgain,  we  search  left or right for the key to be removed. If we reach a null,⍞000Dthen  the key wasn''t in the tree and we have finished. Otherwise, if we find the⍞000Dnode  and  it  has  0  or  1 non-null children, we replace it with its child (or⍞000Dnull). Otherwise, if the  node has two non-null children, we have two options:⍞000D⍞000DOption-s (simpler): Push the node to be removed deeper down the tree by repeated⍞000Drotation  until  it has only 1 or 0 children, then proceed as above. It would be⍞000Dbetter to rotate towards the nearest node with fewer than 2 children but, as the⍞000Dlocation  of  such a node is generally unknown, either direction will do. →sbst←⍞000Dand →splay← use the simpler option.⍞000D⍞000DOption-q (quicker):  Replace  the  (Key Val) pair of the node with the (Key Val)⍞000Dpair  that sorts immediately after (or before) it. Then, remove this "successor"⍞000Dnode, which must have at most 1 child. →avl← and →redblack← use the quicker opt-⍞000Dion.⍞000D⍞000D    T ∇ K →                                 ⍝ tree T without key K:⍞000D    ·   T ≡ ∘:   T                          ⍝ null T: key not in tree.⍞000D    ·   (Key Val)(Lft Rgt) ← T              ⍝ naming parts of node.⍞000D    ·   K < Key: (Key Val)(Lft∆ Rgt)        ⍝ lower: node with K ...⍞000D    ·   ;   Lft∆ ← Lft ∇ K                  ⍝ ... removed from left subtree.⍞000D    ·   K > Key: (Key Val)(Lft Rgt∆)        ⍝ higher: node with K ...⍞000D    ·   ;   Rgt∆ ← Rgt ∇ K                  ⍝ ... removed from right subtree.⍞000D    ·   Rgt ≡ ∘: Lft                        ⍝ match: null right: left⍞000D    ·   Lft ≡ ∘: Rgt                        ⍝ match: null left: right.⍞000D⍞000D⍝ then either the simpler but slower option-s:⍞000D⍞000D    ·   (KeyValA (LftA ((Key Val)(RgtA Rgt))) ∇ K   ⍝ rgt-rotated Lft without K.⍞000D    ·   ;   KeyValA (LftA RgtA) ← Lft               ⍝ naming parts of K''s Lft.⍞000D⍞000D⍝   ┌────────────┬─────────┬────────────┬────⍞000D⍝   │    [K] ~ K →   A ~ K →   A        │⍞000D⍝   │    / \     │  / \    │  / \       │⍞000D⍝   │   A   B    │ p  [K]  │ p  [K] ~ K → ...⍞000D⍝   │  / \       │    / \  │    / \     │⍞000D⍝   │ p   q      │   q   B │   q   B    │⍞000D⍝   └────────────┴─────────┴────────────┴────⍞000D⍞000D⍝ or the quicker but more complex option-q:⍞000D⍞000D    ·   (KeyS ValS) ← Left Rgt              ⍝ successor key=value pair.⍞000D    ·   ;   Left ← ∇ KeyVal(Lft Rgt) →      ⍝ leftmost key=value pair.⍞000D    ·   ·   ·   Lft ≡ ∘: KeyVal             ⍝ left child null: successor.⍞000D    ·   ·   ·   Lft ≢ ∘: ∇ Lft              ⍝ otherwise: left of left subtree.⍞000D    ·   (KeyS ValS)(Lft Rgt∆)               ⍝ successor key and value.⍞000D    ·   ;   Rgt∆ ← Rgt ∇ KeyS               ⍝ right sub with successor removed.⍞000D⍞000D⍝   ┌───────────────┬──────────────┐⍞000D⍝   │     [K] ~ K   │     [S]      │⍞000D⍝   │     / \       │     / \      │⍞000D⍝   │    p   A      →    p   A ~ S │⍞000D⍝   │       / \     │       / \    │⍞000D⍝   │     ...  t    │     ...  t   │⍞000D⍝   │     /         │     /        │⍞000D⍝   │    q          │    q         │⍞000D⍝   │   / \         │   / \        │⍞000D⍝   │ [S]  s        │ [S]  s       │⍞000D⍝   │   \           │   \          │⍞000D⍝   │    r          │    r         │⍞000D⍝   └───────────────┴──────────────┘⍞000D⍞000DFor  no  particular reason, other than to explore both methods, operators →sbst←⍞000Dand →splay← use option-s, whereas operators →avl← and →redblack← use option-q.⍞000D⍞000DTechnical notes⍞000D---------------⍞000DOperators:  →sbst←,  →splay←,  →avl←  and  →redblack←  are used to derive access⍞000Dfunctions  for  their  particular  type of BST, depending on the operator''s left⍞000Doperand:⍞000D⍞000D    ∪ op    ⍝ tree ⍺ with key=val ⍵.⍞000D    ~ op    ⍝ tree ⍺ without key ⍵.⍞000D    ⍎ op    ⍝ value for key ⍺ from tree ⍵.⍞000D    ⍕ op    ⍝ format of tree ⍵.⍞000D    ∊ op    ⍝ enlist of tree ⍵.⍞000D    ? op    ⍝ stats for tree ⍵: ok size mean_depth height.⍞000D    ≡ op    ⍝ depth of key ⍵ in tree ⍺ (only for →splay←).⍞000D    = op    ⍝ balance of tree ⍵ (only for →sbst←).⍞000D⍞000DType⍞000D----⍞000DTo help illuminate the code, closing braces of inner subfunctions in each of the⍞000Doperators show their "type", using the following notation:⍞000D⍞000D   :: "is of type"⍞000D    ∇ function place marker⍞000D   ∇∇ operator place marker⍞000D    → returns⍞000D- ~ # primitive types for char, numb, ref, à la →display←⍞000D⊤ ⍺ ⍵ type variables⍞000D  [⊤] vector of type ⊤⍞000D [⊤;] matrix of type ⊤, etc⍞000D    t tree⍞000D    k key⍞000D    v value⍞000D    i subtree height increment: ¯1 0 1⍞000D    b node balance moment:      ¯1 0 1⍞000D    r direction of rotation:    ¯1   1⍞000D    e which edge (left right):  ¯1   1⍞000D    d depth from root.⍞000D    h height of (sub)tree.⍞000D    s size of (sub)tree (number of nodes).⍞000D    a arbitrary accumulated value.⍞000D    y boolean value no/yes → 0/1.⍞000D⍞000DFor example, the type of avl''s inner function [search] shows:⍞000D⍞000D    search :: t (t ∇ k v → t i) ∇∇ k v → t i⍞000D⍞000Dmay be read as follows:⍞000D⍞000D    search :: t (t ∇ k v → t i) ∇∇ k v → t i    ⍝ search is an operator⍞000D    ¯¯¯¯¯¯                      ¯¯⍞000D    search :: t (t ∇ k v → t i) ∇∇ k v → t i    ⍝ that takes an operand⍞000D                ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯⍞000D    search :: t (t ∇ k v → t i) ∇∇ k v → t i    ⍝ which is a function⍞000D                   ¯⍞000D    search :: t (t ∇ k v → t i) ∇∇ k v → t i    ⍝ that returns a tree-incr⍞000D                         ¯¯¯¯¯⍞000D    search :: t (t ∇ k v → t i) ∇∇ k v → t i    ⍝ from a tree and a key=val⍞000D                 ¯   ¯¯¯⍞000D    search :: t (t ∇ k v → t i) ∇∇ k v → t i    ⍝ and derives a function⍞000D                ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯⍞000D    search :: t (t ∇ k v → t i) ∇∇ k v → t i    ⍝ that returns a tree-incr⍞000D                                       ¯¯¯¯¯⍞000D    search :: t (t ∇ k v → t i) ∇∇ k v → t i    ⍝ from a tree and a key=val.⍞000D              ¯                          ¯¯¯⍞000DUsing this notation, types of functions derivable from the operators are:⍞000D⍞000D    put ← ∪ avl :: t ∇ k v → t          ⍝ tree ⍺ with key=value pair ⍵.⍞000D    get ← ⍎ avl :: k ∇ t   → v          ⍝ value for key ⍺ in tree ⍵.⍞000D    rem ← ~ avl :: t ∇ k   → t          ⍝ tree ⍺ without key.⍞000D    fmt ← ⍕ avl ::   ∇ t   → [-;]       ⍝ char matrix format of tree ⍵.⍞000D    chk ← ? avl ::   ∇ t   → y s d h    ⍝ statistics for tree ⍵.⍞000D    vec ← ∊ avl ::   ∇ t   → [k v]      ⍝ key=value vector from tree ⍵.⍞000D⍞000DWhich is best?⍞000D--------------⍞000D·⍞000D    redblack ────────────────────┐⍞000D    avl ─────────────────────┐   │⍞000D    splay ───────────────┐   │   │⍞000D    sbst ────────────┐   │   │   │⍞000D                     │   │   │   │⍞000D                     BST SPL AVL R-B⍞000D                    ┌───┬───┬───┬───┐⍞000D    Ordered puts    │ 1 │ 1 │ 4 │ 4 │       0 N/A⍞000D                    ├───┼───┼───┼───┤       1 Poor⍞000D    Random puts     │ 3 │ 3 │ 5 │ 5 │       2 So-so⍞000D                    ├───┼───┼───┼───┤       3 Good⍞000D    Adaptive gets   │ 0 │ 5 │ 0 │ 0 │       4 Very Good⍞000D                    ├───┼───┼───┼───┤       5 Excellent⍞000D    Simple code     │ 4 │ 3 │ 2 │ 2 │⍞000D                    ├───┼───┼───┼───┤⍞000D    Key removal     │ 1 │ 1 │ 4 │ 4 │⍞000D                    └───┴───┴───┴───┘⍞000D⍞000D    va ← ⍳1023                  ⍝ ascending sequence of keys (worst case).⍞000D    vb ← ⍋⌽⍉(10/2)⊤⍳1023        ⍝ binary-alternating order keys (best case).⍞000D⍞000D    puts ← ∪avl foldl           ⍝ insert keys ⍵ into tree ⍺.⍞000D⍞000D    ta ← 0 puts va              ⍝ tree from ascending inserts.⍞000D    tb ← 0 puts vb              ⍝ tree from binary-alternating inserts.⍞000D⍞000D    rems ← ~avl foldl           ⍝ remove keys ⍵ from tree ⍺.⍞000D⍞000D    ┌───────────────┬───────────┬───────────┬───────────┬───────────┐⍞000D    │           time│           │           │           │           │⍞000D    │rotations      │       sbst│      splay│        avl│   redblack│⍞000D    ├───────────────┼───────────┼───────────┼───────────┼───────────┤⍞000D    │      0 puts va│       1970│       2129│         63│         93│⍞000D    │               │           │           │1013       │1005       │⍞000D    ├───────────────┼───────────┼───────────┼───────────┼───────────┤⍞000D    │      0 puts vb│         29│         32│         34│         41│⍞000D    │               │           │           │0          │0          │⍞000D    ├───────────────┼───────────┼───────────┼───────────┼───────────┤⍞000D    │     ta rems va│          3│          3│         31│         47│⍞000D    │               │           │           │502        │503        │⍞000D    ├───────────────┼───────────┼───────────┼───────────┼───────────┤⍞000D    │     ta rems vb│        929│        946│         35│         47│⍞000D    │               │           │           │0          │8          │⍞000D    ├───────────────┼───────────┼───────────┼───────────┼───────────┤⍞000D    │     ta rems⌽va│       1947│       1982│         30│         49│⍞000D    │               │           │           │502        │494        │⍞000D    ├───────────────┼───────────┼───────────┼───────────┼───────────┤⍞000D    │     tb rems va│         18│         17│         31│         37│⍞000D    │               │           │           │502        │502        │⍞000D    ├───────────────┼───────────┼───────────┼───────────┼───────────┤⍞000D    │     tb rems vb│         26│         26│         36│         39│⍞000D    │               │           │           │0          │0          │⍞000D    ├───────────────┼───────────┼───────────┼───────────┼───────────┤⍞000D    │     tb rems⌽va│         18│         17│         30│         36│⍞000D    │               │           │           │502        │502        │⍞000D    ├───────────────┼───────────┼───────────┼───────────┼───────────┤⍞000D    │       2↓chk va│   511 1023│   511 1023│      8  10│      9  18│ *⍞000D    ├───────────────┼───────────┼───────────┼───────────┼───────────┤⍞000D    │       2↓chk vb│     8   10│     8   10│      8  10│      9  10│⍞000D    └───────────────┴───────────┴───────────┴───────────┴───────────┘⍞000D    * Worst-case  red-black  trees are deeper than worst-case AVL⍞000D      trees  but  mean  nodes depths, which indicate access times,⍞000D      are not too different.⍞000D⍞000DKey  insertion and removal timings used operator →time← with the following sequ-⍞000Dence. For example, the avl timing tests looked like this:⍞000D⍞000D    ┌avl─────────────────────┐⍞000D    │    puts ← ∪ avl foldl  │⍞000D    │    ta ← 0 puts time va │⍞000D    │00.63                   │⍞000D    │    tb ← 0 puts time vb │⍞000D    │00.34                   │⍞000D    │    rems ← ~ avl foldl  │⍞000D    │    ta rems time va     │⍞000D    │00.31                   │⍞000D    │    ta rems time vb     │⍞000D    │00.35                   │⍞000D    │    ta rems time ⌽va    │⍞000D    │00.30                   │⍞000D    │    tb rems time va     │⍞000D    │00.31                   │⍞000D    │    tb rems time vb     │⍞000D    │00.36                   │⍞000D    │    tb rems time ⌽va    │⍞000D    │00.30                   │⍞000D    └────────────────────────┘⍞000D⍞000DRotations were counted by injecting a line r+←1 at the start of each inner [rot]⍞000Dsubfunction:⍞000D⍞000D    rot←{       ⍝ single ⍵-rotation of tree ⍺.⍞000D        r+←1    ⍝ count rotations.⍞000D        ...⍞000D⍞000Dand then, for example:⍞000D⍞000D    r←0 ⋄ {}tb rems va ⋄ r      ⍝ number of removal rotations.⍞000D502⍞000D⍞000DReferences:⍞000D⍞000D[1] http://en.wikipedia.org/wiki/Binary_Search_Tree⍞000D⍞000D[2] Knuth: Computer Musings: The Associative Law, or The Anatomy of Rotations in⍞000D    Binary Trees (video). Stanford University Distinguished Lecture Series VII.⍞000D    University Video Communications (415) 813-0506.⍞000D⍞000D[3] P.J.Landin The Next 700 Programming Languages. CACM 9(3):157⍞000065, March 1966.⍞000D⍞000DSee also: sbst splay avl redblack alists display time⍞000D⍞000DIndex:binary search tree|type notation|enlist|Catalan number⍞000DIndex;Knuth D.E.|Foad J.|Segner J.A.' 
