'precedes ← this ##.le that          ⍝ Total array ordering (TAO) comparison.⍞000D⍞000DInspired by Roger Hui,  [le]  "less than or equal"  defines a Total Order on APL⍞000Darrays. For any arrays A, B and C:⍞000D⍞000D    (A le B) ∧ (B le A) : A eq B    ⍝ antisymmetry⍞000D    (A le B) ∧ (B le C) : A le C    ⍝ transitivity⍞000D    (A le B) ∨ (B le A)             ⍝ totality.⍞000D⍞000DSee: http://en.wikipedia.org/wiki/Total_order⍞000DSee: http://www.jsoftware.com/jwiki/Essays/The_TAO_of_J⍞000D⍞000DGiven any two arrays, [le]  tells  us which "precedes or is equal to" the other.⍞000DIn particular it may be used to compare arrays of:⍞000D⍞000D    differing type:     ''6'' le 6⍞000D    differing rank:     3 le ,3⍞000D    differing shape:    5 4 le 5 4 3⍞000D    differing depth:    (⊂⍳2)le ⊂⊂⍳2⍞000D    complex numbers:    7j8 le 8j7⍞000D    namespaces:         # le ⎕SE⍞000D    objects:            le/{⎕new''Form''(⊂''Caption''⍵)}¨''Hello'' ''World''⍞000D⍞000DThe comparison proceeds in the following order:⍞000D⍞000D- If the ranks differ, the lesser array is extended with leading 1-axes.⍞000D  If the resulting arrays match, the original ranks are used as a tie-breaker.⍞000D⍞000D- If the shapes differ, the arrays are extended to conform with fill items.⍞000D  If the resulting arrays match, the original shapes are used as a tie-breaker.⍞000D⍞000D- Non-atomic arrays are compared item-wise, pervasively, in ravel order.⍞000D⍞000D- Atomic items are compared by category: <char> le <number> le <ref> le <⎕OR>.⍞000D⍞000D- Otherwise, if the categories match:⍞000D⍞000D    Characters are compared using ⍋,⍞000D    Numbers are compared on their real part, followed by their imaginary part,⍞000D    Namespaces are compared recursively in order of their:⍞000D        Type property,⍞000D        Symbol table (name class value) triples,⍞000D            Functions and operators are compared on their ⎕NR values,⍞000D            ⎕ORs are compared using their fixed functions or namepaces.⍞000D        The values of namespace-scope system variables,⍞000D        Property names and values.⍞000D⍞000DRegarding the antisymmetry condition:⍞000D⍞000D    (A le B) ∧ (B le A) : A eq B    ⍝ antisymmetry⍞000D⍞000DWhen comparing refs, "eq" is not the  same as primitive function match (≡):  two⍞000Drefs match _only_ if they reference the _same_ namespace, while [le] would judge⍞000Dthem equal if their contents and properties match:⍞000D⍞000D    A B ← ⎕ns¨ '''' ''''        ⍝ two namespaces.⍞000D⍞000D    (A le B) ∧ (B le A)     ⍝ A eq B⍞000D1⍞000D    A ≡ B                   ⍝ A ≢ B⍞000D0⍞000D⍞000DRationale:⍞000D⍞000DThe order that [le] imposes on arrays is to some extent arbitrary but is intend-⍞000Ded to be intuitive. Here are the choices implicit in the coding:⍞000D⍞000D[1] Item value is more significant than shape. For example:⍞000D    ''abc   '' le ''xyz''       ⍝ even though (⍴⍺)>⍴⍵⍞000D    ''abc'' le ''z''            ⍝ even though (⍴⍴⍺)>⍴⍴⍵⍞000D    (1 3⍴''abc'') le ''xyz''    ⍝   ..      ..      ..⍞000D⍞000D[2] Characters sort before⍞000D    numbers, which sort before⍞000D    refs, which sort before⍞000D    ⎕ORs.⍞000D⍞000D[3] When comparing complex numbers, real part is more significant than imaginary⍞000D    part.⍞000D⍞000D[4] Within a namespace,⍞000D        user-specified names and values are more significant than⍞000D        system variable values, which are more significant than⍞000D        property values.⍞000D⍞000D[5] Within a namespace, (name class value) triples are compared with each other,⍞000D    rather than having names, classes and values compared consecutively:⍞000D⍞000D        x.a←8                   ⍝ x.a←8 ⋄ y.a←3⍞000D        y.(a b)←3 4             ⍝         y.b←4⍞000D⍞000D        x le y                  ⍝ because (a:8) >> (a:3)⍞000D    0⍞000D        x.(⎕nl 2) le y.(⎕nl 2)  ⍝ notwithstanding the order of namelists.⍞000D    1⍞000D⍞000DNamespace Reference Cycles⍞000D--------------------------⍞000DNamespaces structures may contain reference cycles as in x.p←x or (x y).q←(y x).⍞000DApart from avoiding infinite recursion problems when processing such structures,⍞000Dwe need to bestow a relative order upon them. What is (x le y) in the second ex-⍞000Dample above? The approach taken in [le] comes from a suggestion by Nick Nikolov.⍞000D⍞000DThe depth-first search [acmp] of left and right argument graphs keeps a note (in⍞000D⍺⍺) of namespaces already visited. The search continues to follow any cycles un-⍞000Dtil [a], a "regular"  difference is discovered between the two arguments or [b],⍞000Dpreviously visited vertices are encountered in both graphs.  In the latter case,⍞000Dthe one with the shorter cycle (∇ ⍺⍺⍳¨⍺⍺) is deemed the lesser.⍞000D⍞000D                                                ⍝ ┌x────┐←┐⍞000D    (x←⎕ns ⍬).(x←⎕ns ⍬).(x←##)                  ⍝ │┌x──┐│ │⍞000D                                                ⍝ ││ x→───┘⍞000D                                                ⍝ │└───┘│⍞000D                                                ⍝ └─────┘⍞000D⍞000D                                                ⍝ ┌y──────┐←┐⍞000D    (y←⎕ns ⍬).(y←⎕ns ⍬).(y←⎕ns ⍬).(y←##.##)     ⍝ │┌y────┐│ │⍞000D                                                ⍝ ││┌y──┐││ │⍞000D                                                ⍝ │││ y→────┘⍞000D                                                ⍝ ││└───┘││⍞000D                                                ⍝ │└─────┘│⍞000D                                                ⍝ └───────┘⍞000D⍞000D    x y ≡ x.x.x  y.y.y.y                        ⍝ 3- and 4-cycles⍞000D1⍞000D    ∘.le⍨ x y                                   ⍝ Total ordering⍞000D1 1⍞000D0 1⍞000D⍞000DExamples:⍞000D⍞000D    4 le 5                  ⍝ simple scalar comparison: 4≤5.⍞000D1⍞000D    3 le ,2                 ⍝ differing rank: compare items.⍞000D0⍞000D    (,3) le 3               ⍝ matching items: compare rank.⍞000D0⍞000D    ''3'' le 3                ⍝ chars precede numbers.⍞000D1⍞000D    3j4 le 4j3              ⍝ real-part trumps imaginary-part⍞000D1⍞000D    # le ⎕se                ⍝ #.Type ≤ ⎕se.Type⍞000D1⍞000D    ''xy''⎕ns¨⊂''''             ⍝ two namespaces.⍞000D⍞000D    x.(a c)←1 3             ⍝ with names a c⍞000D    y.(a b)←1 4             ⍝ ... and a b⍞000D    x le y                  ⍝ (a c ...) supersedes (a b ...)⍞000D0⍞000D    x.b←2                   ⍝ new name b in x⍞000D    x le y                  ⍝ (a:1 b:2 ...) precedes (a:1 b:4 ...)⍞000D1⍞000D    qsort←{                             ⍝ quicksort.⍞000D        1≥⍴⍵:⍵                          ⍝ single item or null: done.⍞000D        head tail←(1↑⍵)(1↓⍵)            ⍝ first and remaining items.⍞000D        le gt←1 0=⊂tail ⍺⍺¨head         ⍝ comparison with first item.⍞000D        (∇ le/tail),head,∇ gt/tail      ⍝ sorted vector.⍞000D    }⍞000D⍞000D    display le qsort 3(,3)''3''(,''3'')     ⍝ char << num; scalar << vector⍞000D┌→────────────┐⍞000D│   ┌→┐   ┌→┐ │⍞000D│ 3 │3│ 3 │3│ │⍞000D│ - └─┘   └~┘ │⍞000D└∊────────────┘⍞000D⍞000D    ip←+.×                                      ⍝ named function.⍞000D⍞000D    stuff ← ⎕SE ⍬ # (⎕or''ip'') '''' ⍬              ⍝ assorted stuff.⍞000D⍞000D    display le qsort stuff                      ⍝   sorted stuff.⍞000D┌→────────────────────────┐⍞000D│ ┌⊖┐ ┌⊖┐ ┌⊖┐       ┌───┐ │⍞000D│ │ │ │0│ │0│ # ⎕SE │+.×│ │⍞000D│ └─┘ └~┘ └~┘       └∇──┘ │⍞000D└∊────────────────────────┘⍞000D⍞000D⍝ Other relationships can be derived from le:⍞000D⍞000D    cmp ← {⍺⍺/le/¨1 0⌽¨⊂⍺ ⍵}                    ⍝ comparison⍞000D⍞000D    ge ← ≥cmp                                   ⍝ greater or equal⍞000D    eq ← =cmp                                   ⍝ equal⍞000D    ne ← ≠cmp                                   ⍝ not equal⍞000D    lt ← <cmp                                   ⍝ less than⍞000D    gt ← >cmp                                   ⍝ greater than⍞000D⍞000D    (⎕ns'''')  ≡ ⎕ns''''                            ⍝ distinct spaces don''t match.⍞000D0⍞000D    (⎕ns'''') eq ⎕ns''''                            ⍝ distinct spaces deemed equal.⍞000D1⍞000D    ∘.ge⍨ 0 1                                   ⍝ truth-table for ge.⍞000D1 0⍞000D1 1⍞000D    grade←{| ⊢/↑ ⍺⍺ qsort ⍵ {⍺ ⍵}¨ ⍵⍵ ⍳⍴⍵}      ⍝ grade up/down.⍞000D⍞000D    gu ← le grade +                             ⍝ grade-up   ⍋⍞000D    gd ← ge grade -                             ⍝ grade-down ⍒⍞000D⍞000D    gu 3 1 4 1 5                                ⍝ grade-up of numeric vector.⍞000D2 4 1 3 5⍞000D⍞000D    gd 3 1 4 1 5                                ⍝ grade-down of numeric vector.⍞000D5 3 1 2 4⍞000D⍞000D    gu 3j5 3j4 4j3 3j4                          ⍝ complex number grade-up.⍞000D2 4 1 3⍞000D⍞000D    display stuff                               ⍝ assorted stuff.⍞000D┌→────────────────────────┐⍞000D│     ┌⊖┐   ┌───┐ ┌⊖┐ ┌⊖┐ │⍞000D│ ⎕SE │0│ # │+.×│ │ │ │0│ │⍞000D│     └~┘   └∇──┘ └─┘ └~┘ │⍞000D└∊────────────────────────┘⍞000D⍞000D    gu stuff                                    ⍝ grade-up of stuff.⍞000D5 2 6 3 1 4⍞000D⍞000D    gd stuff                                    ⍝ grade-down of stuff.⍞000D4 1 3 2 6 5⍞000D⍞000D    q ← ''to'' ''be'' ''or'' ''not'' ''to'' ''be''          ⍝ that is the question.⍞000D⍞000D    gu q                                        ⍝ grade-up of char vectors ...⍞000D2 6 4 3 1 5⍞000D⍞000D    ⍋∘↑ q                                       ⍝ ... concurs with ⍋∘↑⍞000D2 6 4 3 1 5⍞000D⍞000D    nvs ← (1 1) (2 3 4) (1 1) (3 1) (1 2)       ⍝ numeric vectors.⍞000D⍞000D    gd  nvs                                     ⍝ grade-down ...⍞000D4 2 5 1 3⍞000D⍞000D    ⍒∘↑ nvs                                     ⍝ ... concurs with ⍒∘↑⍞000D4 2 5 1 3⍞000D⍞000DSee also: refmatch logic truth_tables lex⍞000D⍞000DIndex:sort|quicksort|Total array ordering|order (of arrays)|compare arrays⍞000DIndex:grade|stuff|depth-first search⍞000DIndex;Hui R.K.W.|Nikolov N.' 
