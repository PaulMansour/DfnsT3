'nvec ← ##.fibonacci num                     ⍝ Tail-recursive Fibonacci.⍞000D                                            ⍝ Leonardo Fibonacci 1170-1250.⍞000D⍞000DAn illustration of tail recursion with a left argument accumulator:⍞000D⍞000D    fibonacci←{     ⍝ Tail-recursive Fibonacci.⍞000D        ⍺←0 1⍞000D        ⍵=0:⍬⍴⍺⍞000D        (1↓⍺,+/⍺)∇ ⍵-1⍞000D    }⍞000D⍞000DCompare this coding with the naïve stack-recursive version:⍞000D⍞000D    fib←{⍞000D        ⍵∊0 1:⍵⍞000D        +/∇¨⍵-1 2⍞000D    }⍞000D⍞000DSome alternatives:⍞000D⍞000DNick Nickolov and Jay Foad suggest:⍞000D⍞000D    fib ← {⊃(+/,⊃)⍣⍵⊢1}⍞000Dand:⍞000D    fib ← {+/!∘⌽⍨⍳⍵}⍞000D⍞000DJohn R. Clark suggests these non-recursive functions:⍞000D⍞000D    fib ← {+/{⍵!⌽⍵}(⍳⍵)-⎕io}            ⍝ JRC[1]⍞000Dand⍞000D    fib ← {1↓⍎((3×⍵)⍴''⌽+\''),''1 0''}      ⍝ JRC[2]⍞000D⍞000DJRC[1] may be cast as a derived function, using monadic commute:⍞000D⍞000D    fib ← +/∘(!∘⌽⍨)∘(-∘⎕io)∘⍳           ⍝ see →derive←⍞000D⍞000Dand JRC[2] may be converted to use the primitive power operator:⍞000D⍞000D    fib ← {⍬⍴⌽∘(+\)⍣⍵,0 1}              ⍝ ⍣ is primitive power operator.⍞000D⍞000Dor the equivalent derived function, using reduction for power (see →pow←):⍞000D⍞000D    fib ← ⍬∘⍴∘⊃∘(⊢∘⌽∘(+\)/)∘(,∘(⊂0 1))∘⍳⍞000D⍞000DIn a similar way, power can be applied on the following matrix multiplication:⍞000D⍞000D    |1 1|   |A B|   |A+C B+D|⍞000D    |1 0| × |C D| = | A   B |⍞000D⍞000Dto obtain a terse but costly fib function:⍞000D⍞000D    fib ← {⊃(+.×⍣⍵)⍨2 2⍴1 1 1 0}⍞000D⍞000DAnother simple way is to perform a "hidden scan" with a reduction (see →scan←):⍞000D⍞000D    fib ← {⊃{⍵,+/¯2↑⍵}/⍵⍴1}⍞000D⍞000DThe following function illustrates the relationship between the  Fibonacci sequ-⍞000Dence and rational approximations to the "golden mean" (Phi). See →phinary←.⍞000D⍞000D    fib←{1∧+∘÷/0,⍵/1}⍞000D         │ │   └───── continued fraction: 0 1 1 1 ...⍞000D         │ └───────── approximation to Phi-1: 0 1 0.5 0.666 ...⍞000D         └─────────── numerator of rational: 0 1 1 2 3 5 8 13 21 34 ...⍞000D⍞000DDick Bowman reminds us of Binet''s formula, which also uses Phi:⍞000D⍞000D    fib ← {((phi*⍵)-(1-phi←.5×1+5*.5)*⍵)÷5*.5}⍞000D⍞000DPeter-Michael Hager suggests this pleasantly symmetrical coding of Binet''s form-⍞000Dula:⍞000D⍞000D    fib←{⍞000D        p←0.5×1+5*0.5⍞000D        q←0.5×1-5*0.5⍞000D        ((p*⍵)-q*⍵)÷p-q⍞000D    }⍞000D⍞000DIn the above, constants p and q could be pre-evaluated and bound as the left and⍞000Dright operands of a dyadic operator:⍞000D⍞000D    fib ← (0.5×1+5*0.5) {((⍺⍺*⍵)-⍵⍵*⍵)÷⍺⍺-⍵⍵} (0.5×1-5*0.5)⍞000D⍞000Dor:⍞000D⍞000D    fib ← (0.5×1+1 ¯1×5*0.5)∘{(-⌿⍺∘.*⍵)÷-/⍺}⍞000D⍞000DAs  Binet''s formula employs only scalar functions, it may be applied to an array⍞000Dargument. Using the above definition:⍞000D⍞000D    fib (0 1 2)(2 2⍴2+⍳4)⍞000D 0 1 1  2 3⍞000D        5 8⍞000D⍞000DJane Sullivan extends Binet''s formula to the real and complex domains.  A D-cod-⍞000Dind of Jane''s real-valued function might look like this:⍞000D⍞000D    fib←{                                           ⍝ Sullivan⍞000D        z←0.5×1+s←5*0.5⍞000D        ((z*⍵)-(2○○⍵)×z*-⍵)÷s⍞000D    }⍞000D⍞000DRef: Sullivan J. "Functional Extensions to the Fibonacci Sequence", Vector 15.4.⍞000D⍞000DNote that Jane''s function is defined for negative arguments:⍞000D⍞000D    ⎕pp←3 ⋄ fib ¯5 ¯4.5 to 5                        ⍝ fib ¯5 ¯4.5 .. 5⍞000D5 0.0513 ¯3 0.083 2 0.134 ¯1 0.217 1 0.352 0 0.569 1 0.92 1 1.49 2 2.41 3 3.9 5⍞000D⍞000DVeli-Matti Jantunen suggests this coding for large Fibonacci numbers, eg >10000.⍞000D⍞000D    fib←{⎕ml←3⍞000D        ⍵≤2:1⍞000D⍞000D        {(+/∧\⍵=''0'')↓⍵⍞000D        },''ZI9''⎕fmt(⍵-2){⍞000D            ⍺>0:(⍺-1)∇(↑⌽⍵)({⍞000D                ∧/⍵<1e9:⍵ ⋄ (1e9|⍵)+1⌽⍵≥1e9⍞000D            }(↑⍵)+↑⌽⍵) ⋄ ↑⌽⍵⍞000D        }2⍴⊂(-⌈⍵÷40)↑1⍞000D    }⍞000D⍞000DPaul Mansour offers this function, which uses OO techniques:⍞000D⍞000D    Fibonacci←{⎕io ⎕ml←0 1  ⍝ First ⍵ fibonacci numbers.⍞000D        s←⎕NS''''             ⍝ Class⍞000D        s.(f←{⍺←⎕THIS ⋄ ⍺.i<2:⍺.n ⋄ ⊢⍺.n←+/⍺.a[⍺.i-1+⍳2].n}) ⍝ Method⍞000D        v←⎕NS¨⍵⍴s           ⍝ Collection⍞000D        v.i←⍳⍵              ⍝ Item number⍞000D        v.n←⍵↑0 1           ⍝ Initialize⍞000D        v.a←⊂v              ⍝ Each knows all⍞000D        v.b←(1+⍳⍵)⍴¨⊂v      ⍝ Each knows self and previous?⍞000D        v.f 0               ⍝ Compute⍞000D    }⍞000D⍞000DLucas numbers⍞000D-------------⍞000DInitialising the recursion with 2 1, instead of 0 1, returns the Lucas sequence:⍞000D⍞000D    2 1∘fibonacci¨ 0 to 20          ⍝ François Lucas 1842-1891.⍞000D2 1 3 4 7 11 18 29 47 76 123 199 322 521 843 1364 2207 3571 5778 9349 15127⍞000D⍞000Dhttp://en.wikipedia.org/wiki/Lucas_number⍞000D⍞000DFibonacci-based number system⍞000D-----------------------------⍞000DThe Fibonacci sequence may be used as the base of a number system:⍞000D⍞000D    fibcode←{               ⍝ fibonacci-coding of number ⍵.⍞000D⍞000D        pair←{              ⍝ fib-pair⍞000D            n←+/⍵           ⍝ next term.⍞000D            ⍺<n:⍵           ⍝ term large enough: finished.⍞000D            ⍺ ∇ 1↓⍵,n       ⍝ next pair⍞000D        }                   ⍝ :: i j ← n ∇ i j⍞000D⍞000D        vec←{               ⍝ ⍺ is accumulator.⍞000D            n(i j)←⍵        ⍝ remaining number and current fib pair.⍞000D            i=0:⍺,1         ⍝ exhausted radix list: accumulator, sentinel.⍞000D            f←(j-i),i       ⍝ next fib pair.⍞000D            t←n≥j           ⍝ next term and⍞000D            r←n-t×j         ⍝   remainder.⍞000D            (t,⍺)∇ r f      ⍝ accumulated fib-coding.⍞000D        }                   ⍝ :: [b] ← [b] ∇ n(i j)⍞000D⍞000D        ⍬ vec ⍵,⊂⍵ pair 0 1 ⍝ fi⍞000D    }⍞000D⍞000D    ↑⍕∘fibcode¨0 to 10      ⍝ fibonacci coding of 0..10⍞000D1⍞000D1 1⍞000D0 1 1⍞000D0 0 1 1⍞000D1 0 1 1⍞000D0 0 0 1 1⍞000D1 0 0 1 1⍞000D0 1 0 1 1⍞000D0 0 0 0 1 1⍞000D1 0 0 0 1 1⍞000D0 1 0 0 1 1⍞000D⍞000DSee: http://en.wikipedia.org/wiki/Fibonacci_coding⍞000D⍞000DExample:⍞000D⍞000D      fibonacci¨⍳10                 ⍝ ⎕io=1: F1 .. F10⍞000D1 1 2 3 5 8 13 21 34 55⍞000D⍞000D      fibonacci¨ 0 to 9             ⍝ first 10 Fibonacci numbers: F0 ..F9.⍞000D0 1 1 2 3 5 8 13 21 34⍞000D⍞000D⍝ compare monitor of tail-recursive version:⍞000D⍞000D      fibonacci mdf 20⍞000D 0 fibonacci←{     ⍝ Tail-recursive Fibonacci.⍞000D21     ⍺←0 1⍞000D21     ⍵=0:⍬⍴⍺⍞000D20     (1↓⍺,+/⍺)∇ ⍵-1⍞000D 0 }⍞000D⍞000D⍝ ... with monitor of stack-recursive version:⍞000D⍞000D      fib mdf 20⍞000D    0 fib←{⍞000D21891     ⍵∊0 1:⍵⍞000D10945     +/∇¨⍵-1 2⍞000D    0 }⍞000D⍞000DSee also: factorial mdf pow to cfract derive nats⍞000DSee also: phinary ratrep ratsum⍞000D⍞000DIndex:tail recursion|accumulator|fibonacci number|golden mean|continued fraction⍞000DIndex:fibonacci coding|coding, fibonacci|Lucas numbers⍞000DIndex;Fibonacci L.|Binet J.|Lucas F.|Nickolov N.|Foad J.⍞000DIndex;Jantunen V-M.|Mansour P.|Clark J.R.|Bowman D.|Hager P-M.|Sullivan J.' 
