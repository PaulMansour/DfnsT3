'hits ← patn {w←''*''} ##.match array          ⍝ find with wildcards.⍞000D⍞000DA generalisation of ⍷, which takes account of "wildcard" items in its left argu-⍞000Dment pattern vector.  The result is a boolean array, the same shape as the right⍞000Dargument, showing where each occurrence of [patn] is found.⍞000D⍞000DBy default,  the wildcard is character ''*'' but an alternative scalar may be sup-⍞000Dplied as a second item of a left argument pair. See example below.⍞000D⍞000DIn common with primitive function find (⍷), overlapping strings are matched.⍞000D⍞000DNB: From Dyalog v13.0, this functionality is provided by system operator ⎕S.⍞000D⍞000DTechnical notes:⍞000D⍞000DNotice in the following that the subject array ⍵ may be of higher rank.⍞000D⍞000DThe first two lines:⍞000D⍞000D        p x←{⍵''*''}⍣(1=≡,⍺),⍺        ⍝ pattern and wildcard.⍞000D        v←1↓¨{(x≡¨⍵)⊂⍵}x,p          ⍝ wildcard-separated segments.⍞000D⍞000Destablish the pattern and wildcard items before splitting the pattern into wild-⍞000Dcard-separated vectors. For example:⍞000D⍞000D        ''red*green*blue'' match ''credit green bored blues''       ⍝ tracing ...⍞000D        ...⍞000D        v⍞000D    ┌───┬─────┬────┐⍞000D    │red│green│blue│⍞000D    └───┴─────┴────┘⍞000D⍞000DThe third line:⍞000D⍞000D        h←↑v⍷¨⊂⍵                ⍝ hits, one row (leading subarray) per segment.⍞000D⍞000Dproduces a simple boolean "hits array" of rank one more than the subject array ⍵⍞000Dwhere subarrays along the leading axis are hits per pattern segment.⍞000D⍞000D        ⍵⍪h⍞000D    c r e d i t   g r e e n   b o r e d   b l u e s⍞000D    0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0  ← hits for ''red''⍞000D    0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  ←  ..  ..  ''green''⍞000D    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0  ←  ..  ..  ''blue''⍞000D⍞000DUsing reduction along the vector of trailing axes, the hits arrays  are  refined⍞000Dright-to-left so that at each step of the reduction,  the right argument repres-⍞000Dents hits of trailing pattern segments. For example,⍞000D⍞000D    c r e d i t   g r e e n   b o r e d   b l u e s⍞000D    0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0⍞000D    0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D    1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0  ← mask for ''blue''⍞000D⍞000D    c r e d i t   g r e e n   b o r e d   b l u e s⍞000D    0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0⍞000D    0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  ← hits for green*blue⍞000D    1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0⍞000D⍞000D    c r e d i t   g r e e n   b o r e d   b l u e s⍞000D    0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0⍞000D    0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  ← hits for green*blue⍞000D    · · · · · · · · · · · · · · · · · · · · · · · ·⍞000D⍞000D    c r e d i t   g r e e n   b o r e d   b l u e s⍞000D    0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0  ← second occurrence ignored⍞000D    1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  ← mask for green*blue⍞000D    · · · · · · · · · · · · · · · · · · · · · · · ·⍞000D⍞000D    c r e d i t   g r e e n   b o r e d   b l u e s⍞000D    0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  ← hits for red*green*blue⍞000D    1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D    · · · · · · · · · · · · · · · · · · · · · · · ·⍞000D⍞000DA slight complication arises with overlapping patterns:⍞000D⍞000D        ''ban*and'' match ''abandon''       ⍝ tracing ...⍞000D        ...⍞000D        v                               ⍝ pattern segments.⍞000D    ┌───┬───┐⍞000D    │ban│and│⍞000D    └───┴───┘⍞000D        ...⍞000D        ⍵⍪h                             ⍝ pattern segment hits.⍞000D    a b a n d o n⍞000D    0 1 0 0 0 0 0⍞000D    0 0 1 0 0 0 0⍞000D⍞000DIn this case, the string ''ban*and'' does not occur within  ''abandon''.  The  upper⍞000Drow of the hits matrix should really be shifted, so that the start of the second⍞000Dhit coincides with the end of the first:⍞000D⍞000D    a b a n d o n⍞000D    0 0 0 0 1 0 0   ← shifted hit after ''ban''⍞000D    0 0 1 0 0 0 0   ← ''and'' does not follow ''ban''⍞000D⍞000DWe could do this inside the reduction  by shifting the left argument right;  ap-⍞000Dplying the mask; and then shifting the result back again for the next step. How-⍞000Dever, a more efficient way is to shift the right argument  left,  which  doesn''t⍞000Drequire a second shift back again.⍞000D⍞000D    a b a n d o n⍞000D    0 1 0 0 0 0 0   ← hit for ''ban''⍞000D    0 0 0 0 0 0 0   ← hit for ''and'' shifted off left-hand side.⍞000D⍞000DWe can''t just use Dyalog''s primitive rotatation function ⌽ for  the  shifting as⍞000D1s rotated off the left hand side would reappear on the right. To avoid this, we⍞000Dappend a sufficient number of columns of zeros to the right of the array; rotate⍞000Dand then drop the same number of colums from the  right.  This means that any 1s⍞000Dshifted beyond the left edge of the array are lost, as required:⍞000D⍞000D    sl←{                    ⍝ array shifted left.⍞000D        a←¯1↓⍴⍵             ⍝ leading axes.⍞000D        x←⌈/⍺               ⍝ maximum shift.⍞000D        p←⍵,(a,x)⍴0         ⍝ 0-padded on right.⍞000D        s←⍉a⍴⍺              ⍝ subarray of vector rotations.⍞000D        (-(0×a),x)↓s⌽p      ⍝ shifted array.⍞000D    }                       ⍝ :: a ← r ∇ a⍞000D⍞000DNote that this shifting and the following propogation of 1s to the left, to form⍞000Dthe mask, may be done outside the reduction.⍞000D⍞000D    m←⌽∨\⌽r sl h            ⍝ shifted mask 1 .. 1 0 .. 0⍞000D⍞000DThen hit/mask pairs form the items of the vector to be reduced:⍞000D⍞000D    }/↓⍉↑vec¨h m            ⍝ hits and masks.⍞000D⍞000DExamples:⍞000D⍞000D    botter ← 3 13⍴''betty botter bought a bit better butter''⍞000Dbetty botter⍞000Dbought a bit⍞000Dbetter butter⍞000D⍞000D    ''b*t'' match botter⍞000D1 0 0 0 0 0 1 0 0 0 0 0 0⍞000D1 0 0 0 0 0 0 0 0 1 0 0 0⍞000D1 0 0 0 0 0 0 1 0 0 0 0 0⍞000D⍞000D    (2 ¯1 1 8)¯1 match 2 7 1 8 2 8 1 8 2 8      ⍝ ¯1 is wildcard⍞000D1 0 0 0 1 0 0 0 0 0⍞000D⍞000D    ''12*56*9''match ⎕D                           ⍝ multiple wildcards⍞000D0 1 0 0 0 0 0 0 0 0⍞000D⍞000D    (2⍴¨¨ ''12*56*9'' ''*'') match 2⍴¨⎕D            ⍝ nested arguments.⍞000D0 1 0 0 0 0 0 0 0 0⍞000D⍞000D    display A ← 2 2 20⍴''<<aa>> <<bbb>>''         ⍝ Higher rank argument ...⍞000D┌┌→───────────────────┐⍞000D↓↓<<aa>> <<bbb>><<aa>>│⍞000D││ <<bbb>><<aa>> <<bbb│⍞000D││                    │⍞000D││>><<aa>> <<bbb>><<aa│⍞000D││>> <<bbb>><<aa>> <<b│⍞000D└└────────────────────┘⍞000D⍞000D    display ''<<*>>''match A                      ⍝ ... higher rank result.⍞000D┌┌→──────────────────────────────────────┐⍞000D↓↓1 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0│⍞000D││0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0│⍞000D││                                       │⍞000D││0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0│⍞000D││0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0│⍞000D└└~──────────────────────────────────────┘⍞000D⍞000D    ''a*b*d''match''aaaabbbccd''                    ⍝ overlapping patterns⍞000D1 1 1 1 0 0 0 0 0 0⍞000D⍞000DSee also: find' 
