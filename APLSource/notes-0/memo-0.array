'rslt ← {larg} (⍺⍺ ##.memo cache) rarg       ⍝ Function memoization.⍞000Dsref ← ##.cache ivec                        ⍝ Ref to space with initial cache.⍞000D⍞000D[memo]  binds an ambi-valent function left operand with a cache right operand to⍞000Dproduce  a  derived  function. On application to arguments, the derived function⍞000Dretrieves  previously-calculated  values  from  the cache, which it extends when⍞000Dnecessary with newly-calculated ones.⍞000D⍞000D    fast_fn ← slow_fn memo cache   ⍝ bind slow_fn with cache to produce fast_fn.⍞000D⍞000D[cache]  is a reference to a namespace containing two vectors [keys] and [vals],⍞000Dwhose items are previously encountered arguments together with their correspond-⍞000Ding  results.  The  cache  is  initialised  using the auxiliary function [cache]⍞000Dwhich pre-populates it with any number of expected result-argument pairs.⍞000D⍞000DThe  technique,  proposed by Donald Michie in 1968 ["Memo" functions and machine⍞000Dlearning,  Nature,  218,  19-22],  was  published as an APL2 operator by Andréas⍞000DGeyer-Schultz.  This more self-contained version was suggested by Stefano Lanza-⍞000Dvecchia and Phil Last.⍞000D⍞000DAs  with  any caching system, care must be taken to remove from the cache, items⍞000Dthat  become "stale" when the cached result no longer reflects external reality.⍞000DAn  example  might  be a cached file read when the "real" file component is sub-⍞000Dsequently updated.⍞000D⍞000DAccess  to  the cache for maintenance purposes (a kind of inspection hatch), can⍞000Dbe achieved by retaining an explicit reference to its namespace.⍞000D⍞000D        ∆foo ← cache''''              ⍝ initialise cache for slow function foo.⍞000D⍞000D        qfoo ← foo memo ∆foo        ⍝ derive "quick" version of foo.⍞000D⍞000D        rslt ← qfoo args ···        ⍝ using qfoo extends its cache.⍞000D⍞000D        ∆foo.(···)                  ⍝ maintain cache using space-reference.⍞000D⍞000DExpunging  the  explicit  reference  leaves  the cache intact within the derived⍞000Dfunction  but  effectively  seals  off  external access to it. Access can be re-⍞000Dcovered  by  stopping  inside  memo,  tabbing to the session and assigning a new⍞000Dexternal reference.⍞000D⍞000D      ⎕ex''∆foo''                     ⍝ expunge handle to foo''s cache.⍞000D⍞000D      rslt ← qfoo args ···          ⍝ qfoo continues to function normally.⍞000D⍞000D      qfoo arg [Ctrl-Enter]         ⍝ trace into derived function,⍞000D      [Ctrl-Tab]                    ⍝ ... tab to session and⍞000D      ∆foo←⍵⍵                       ⍝ ... take new external ref.⍞000D⍞000DRelated  ancillary  functions  [show] and [zap], included in the examples below,⍞000Dmay  be  of  some use but are considered "hors d''oeuvre" and so not fixed in the⍞000Dworkspace.⍞000D⍞000DTechnical notes:⍞000D⍞000DWhen  called,  the derived function: (slow_fn memo cache) examines its cache for⍞000Dthe  supplied argument(s) and if found, returns the corresponding result. Other-⍞000Dwise, it returns a freshly-calculated result, updating the cache en passant.⍞000D⍞000D    memo←{                                        ⍝ Function memoization.⍞000D        ⍺←⊢                                       ⍝ ambi-valent.⍞000D        (⊂⍺ ⍵ ⍵)∊⍵⍵.keys:⍵⍵.((keys⍳⊂⍺ ⍵ ⍵)⊃vals)  ⍝ arg(s) known: fetch result.⍞000D        ⎕IO⊃⍵⍵.(vals keys),∘⊂←(⍺ ⍺⍺ ⍵)(⍺ ⍵ ⍵)     ⍝ else: calc & extend cache.⍞000D    }⍞000D⍞000DNotice  that  the  "look-up key" is (⍺ ⍵ ⍵). This is so that a monadic call with⍞000Dsay, a 2-item right argument is distinct from a dyadic call with 1-item left and⍞000Dright argument:⍞000D⍞000D                call        key⍞000D                ----        ---⍞000D    monadic:    ∇ 3 4       (3 4)(3 4)⍞000D                ∇ 2         2 2⍞000D    dyadic:     3 ∇ 4       3 4 4⍞000D                2 ∇ 2       2 2 2⍞000D⍞000DAuxiliary  function  [cache]  returns a reference to an unnamed space containing⍞000Dtwo  vectors  "vals"  and "keys". The cache is populated by calling the function⍞000Dwith  a  vector  of 2 or 3 item "tuples" denoting monadic: (rslt rarg) pairs, or⍞000Ddyadic: (rslt larg rarg) triples.⍞000D⍞000D    cache←{⎕ML←0                ⍝ Ref to space containing initialised cache.⍞000D        vals keys←↓⍉↑{          ⍝ result values and keys.⍞000D            (⊃⍵)(1↓⍵,¯1↑⍵)      ⍝ rslt - {larg} rarg rarg.⍞000D        }¨1↓(⊂0 0),⍵            ⍝ initial values of cache.⍞000D        ⎕NS''vals'' ''keys''        ⍝ unnamed ref containing cache variables.⍞000D    }⍞000D⍞000DIn  the penultimate line above, the phrase 1↓(⊂0 0),⍵ ensures that cache''s argu-⍞000Dment  vector  has a viable prototypical item. This means that to create an empty⍞000Dcache we may merely: (cache''''), rather than (cache 0⍴⊂0 0).⍞000D⍞000DTo initialise the cache with values for:⍞000D⍞000D      ÷ 1 2     ⍝ monadic ÷⍞000D1 0.5⍞000D      1 ÷ 2     ⍝ dyadic ÷⍞000D0.5⍞000D⍞000DWe would call cache thus:⍞000D⍞000D      cache ((1 0.5)(1 2)) (0.5 1 2)⍞000D             │              │⍞000D             │              └────── triple => rslt larg rarg (dyadic case)⍞000D             └───────────────────── pair => rslt rarg (monadic case)⍞000D⍞000DPersistent Local Variables⍞000D--------------------------⍞000DThe  technique of binding a space reference to a function may be used in general⍞000Dto  implement persistent local variables. That is, variables that are local to a⍞000Dfunction  but  whose  values  are retained between calls. The following function⍞000Dcan be used to generate a stream of integers on successive calls:⍞000D⍞000D      next←(⎕ns'''')∘{                    ⍝ space bound as left arg.⍞000D          0=⍵:⍺.n←0                     ⍝ next 0: reset number stream.⍞000D          (⍳⍺.n+←⍵)+⍺.n                 ⍝ next ⍵: return next ⍵ numbers.⍞000D      }⍞000D⍞000D      next 0                            ⍝ reset count.⍞000D⍞000D      next 1                            ⍝ next number.⍞000D1⍞000D      next 1                            ⍝ next number.⍞000D2⍞000D      next 2                            ⍝ next two numbers.⍞000D3 4⍞000D      next 1                            ⍝ next number.⍞000D5⍞000D      next 0                            ⍝ reset count.⍞000D⍞000D      next 3                            ⍝ next three numbers,⍞000D1 2 3⍞000D⍞000DAs  Ray  Cannon  observes,  the technique may even be used to _share_ persistent⍞000Ddata among several functions with no additional workspace footprint; participat-⍞000Ding  functions enjoy a strictly private communication. In the following example,⍞000D[brak],  [join], [bkts] and [sepr] share the same space to access communal local⍞000Dvariables: [lft], [rgt] and [sep].⍞000D⍞000D                    ┌∇brak─┐                 ┌∇bkts─┐⍞000D                    │      │   ┌─────────┐   │      │⍞000D                    │      ├─←─┼─┐     ┌─┼─←─┤      │⍞000D                    └──────┘   │ ├─lft─┤ │   └──────┘⍞000D                               │ └─rgt─┘ │⍞000D                    ┌∇join─┐   │ ┌─sep─┐ │   ┌∇sepr─┐⍞000D                    │      ├─←─┼─┘     └─┼─←─┤      │⍞000D                    │      │   └─────────┘   │      │⍞000D                    └──────┘                 └──────┘⍞000D⍞000D      ''tmp''⎕ns''''                    ⍝ temporary external reference to space.⍞000D⍞000D      brak←tmp{⍺⍺.(lft,⍵,rgt)}      ⍝ function to "bracket" its argument.⍞000D      join←tmp{↑,∘(⍺⍺.sep∘,)/⍵}     ⍝ function to join items with separators.⍞000D⍞000D      bkts←tmp{⍺⍺.(lft rgt)←⍵}      ⍝ function to set bracket characters.⍞000D      sepr←tmp{⍺⍺.sep←⍵}            ⍝ function to set separator string.⍞000D⍞000D      ⎕ex''tmp''                      ⍝ remove external reference to space.⍞000D⍞000D      bkts''[]'' ⋄ sepr''-''            ⍝ set bracket and separator strings.⍞000D⍞000D      join brak¨''tic'' ''tac'' ''toe''   ⍝ join bracketed char vectors.⍞000D[tic]-[tac]-[toe]⍞000D⍞000D      sepr''''                        ⍝ change separator string.⍞000D⍞000D      join brak¨''tic'' ''tac'' ''toe''   ⍝ join bracketed char vectors.⍞000D[tic][tac][toe]⍞000D⍞000D      bkts'''''''' ⋄ sepr'', ''           ⍝ change bracket and separator strings.⍞000D⍞000D      join brak¨''tic'' ''tac'' ''toe''   ⍝ join bracketed char vectors.⍞000D''tic'', ''tac'', ''toe''⍞000D⍞000D      brak join''tic'' ''tac'' ''toe''    ⍝ bracket joined char vectors.⍞000D''tic, tac, toe''⍞000D⍞000DCaveat:  Techniques  such as these, should be used with caution, if at all. They⍞000Dare included here in the spirit of exploration, rather than as a suggestion that⍞000Dthey form the basis for any operational software. While interesting in their own⍞000Dright,  they may prove difficult to maintain as the structures will almost cert-⍞000Dainly  be unfamiliar to the maintenance programmer and impenetrable to workspace⍞000Dadministration tools such as those for name cross-referencing and documentation.⍞000D⍞000DThis  operator  could be coded in a more elegant way if APL provided "closures".⍞000DClosures  are  explored further in an experimental "Function Results Edition" of⍞000DDyalog. See: http://dfns.dyalog.com/downloads/fre.pdf⍞000D⍞000DExamples:⍞000D⍞000D      fread←⎕fread memo(cache ⍬)    ⍝ Cached file read.⍞000D⍞000D      fread 1 19                    ⍝ Read ''n cache file component.⍞000D      ···⍞000D      fread 1 19                    ⍝ Subsequent reads satisfied from cache.⍞000D⍞000D      afib←{⎕IO←0                   ⍝ Naïve coding of ⍺-fibonacci number.⍞000D          ⍵∊⍳⍺:⍵                    ⍝ small number: done,⍞000D          +/⍺ afib¨⍵-1+⍳⍺           ⍝ otherwise: sum of preceding ⍺ fib numbers.⍞000D      }⍞000D⍞000D      2 afib¨⍳20                    ⍝ Fibonacci sequence.⍞000D1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765⍞000D⍞000D      time←{                        ⍝ Coarse function timer.⍞000D          ⍺←⊢                       ⍝ accept monadic operand.⍞000D          ai←⎕AI                    ⍝ start the clock.⍞000D          rslt←⍺ ⍺⍺ ⍵               ⍝ apply function.⍞000D          secs←⍕0.001×1↑2↓⎕AI-ai    ⍝ seconds elapsed.⍞000D          ↑,/⍕¨rslt'': ''secs'' Secs''  ⍝ timed result.⍞000D      }⍞000D⍞000D      2 afib¨time⍳20                ⍝ *slow* ⍺-fibonacci sequence.⍞000D1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765: 1.262 Secs⍞000D⍞000D      afib←afib memo(cache ⍬)       ⍝ Memoize afib.⍞000D⍞000D      2 afib¨time⍳20                ⍝ *fast* ⍺-fibonacci sequence.⍞000D1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765: 0.1 Secs⍞000D⍞000D⍝ Notice that afib is coded to use its own name explicitly, rather than ''∇''⍞000D⍝ for the recursion. This is so that the recursive call references the newly-⍞000D⍝ assigned derived function, whereas ''∇'' would have referenced the original⍞000D⍝ function and circumvented the memoization.⍞000D⍞000D⍝ Perhaps surprisingly, the cache can be relied upon to supply the "base values"⍞000D⍝ of the recursion, thus simplifying the initial function coding.⍞000D⍞000D      fib←{                         ⍝ Naïve coding of regular fibonacci number.⍞000D          +/fib¨⍵-1 2               ⍝ sum of preceding 2 fib numbers.⍞000D      }⍞000D⍞000D      fib←fib memo(cache 2/¨0 1)    ⍝ Cache pre-populated with base values.⍞000D⍞000D      fib¨time⍳20                   ⍝ Fast fibonacci sequence.⍞000D1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765: 0.1 Secs⍞000D⍞000D      div←÷ memo (cache ⍬)          ⍝ Ambivalent operand function⍞000D⍞000D      2 div 7                       ⍝ Dyadic use distinct from ...⍞000D0.2857142857⍞000D⍞000D      div 2 7                       ⍝ ... monadic use.⍞000D0.5 0.1428571429⍞000D⍞000D      osc←{                         ⍝ Oscillate - probably returns 1.⍞000D          2|⍵:osc 1+3×⍵             ⍝ odd:  triple ''n add-one,⍞000D              osc ⍵÷2               ⍝ even: halve.⍞000D      }⍞000D⍞000D      ∆osc←cache⊂1 1                ⍝ Initialise cache for osc.⍞000D⍞000D      osc←osc memo ∆osc             ⍝ derive "fast" osc function.⍞000D⍞000D      ∆osc.⎕nl 2                    ⍝ cache-space contents.⍞000Dkeys⍞000Dvals⍞000D⍞000D      show←{⎕ML←0                       ⍝ Show cache [rslts ← args]⍞000D          ↑⍵.(vals{⍺''←'',⊂¯1↓⍵}¨keys)    ⍝ (dropping extra rarg).⍞000D      }⍞000D⍞000D      show ∆osc                     ⍝ Show initial cache.⍞000D1 ← 1⍞000D⍞000D      osc 2                         ⍝ Apply derived function, extending cache.⍞000D1⍞000D      show ∆osc                     ⍝ Show extended cache.⍞000D1 ← 1⍞000D1 ← 2⍞000D⍞000D      osc 3                         ⍝ Apply function again.⍞000D1⍞000D⍞000D      show ∆osc                     ⍝ Show extended cache.⍞000D1 ← 1⍞000D1 ← 2⍞000D1 ← 4⍞000D1 ← 8⍞000D1 ← 16⍞000D1 ← 5⍞000D1 ← 10⍞000D1 ← 3⍞000D⍞000D      zap←{⎕ML←0                        ⍝ Remove value ⍵ from cache ⍺.⍞000D          ⍺.{                           ⍝ within cache:⍞000D              mask←⍵∘≡¨↓⍉↑vals keys     ⍝ mask of matches.⍞000D              vals keys/⍨←⊂~mask        ⍝ retain non-matches.⍞000D          }(⊃⍵)(1↓⍵,¯1↑⍵)               ⍝ target value and key.⍞000D      }⍞000D⍞000D      ∆osc∘zap¨(1 16)(1 10)(1 3)    ⍝ Zap selected cache entries.⍞000D⍞000D      show ∆osc                     ⍝ Show compacted cache.⍞000D1 ← 1⍞000D1 ← 2⍞000D1 ← 4⍞000D1 ← 8⍞000D1 ← 5⍞000D⍞000D      osc 3                         ⍝ Re-run function.⍞000D1⍞000D⍞000D      show ∆osc                     ⍝ Partially restored cache.⍞000D1 ← 1⍞000D1 ← 2⍞000D1 ← 4⍞000D1 ← 8⍞000D1 ← 5⍞000D1 ← 10⍞000D1 ← 3⍞000D⍞000D      ⎕ex''∆osc''                     ⍝ Seal access to osc''s cache.⍞000D⍞000D      osc¨⍳10                       ⍝ Derived function still operates normally.⍞000D1 1 1 1 1 1 1 1 1 1⍞000D⍞000D⍞000D⍝ And finally ...⍞000D⍞000D      delay←⎕dl memo (cache ⍬)      ⍝ Cached delay.⍞000D⍞000D      delay time 10                 ⍝ Delay 10 seconds.⍞000D10.024: 10.034 Secs⍞000D⍞000D      delay time 10                 ⍝ Side-effect-free delay :-)⍞000D10.024: 0 Secs⍞000D⍞000DSee also: UndoRedo fibonacci osc⍞000D⍞000DIndex:memoization|cache|persistent local variable|fibonacci number⍞000DIndex:Function Results Edition|closure⍞000DIndex;Michie D.|Last P.|Geyer-Schultz A.|Cannon R.|Lanzavecchia S.' 
