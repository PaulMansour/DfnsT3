'rslt ← {larg} {''''} ##.lof F lof G lof H ... rarg    ⍝ List of functions.⍞000D⍞000DFrom Phil Last:⍞000D⍞000D[lof] simulates the distribution of the argument(s) to a "list of functions".⍞000D⍞000D         F lof G lof H ··· rarg  ←→  (F rarg)(G rarg)(H rarg) ···⍞000D    larg F lof G lof H ··· rarg  ←→  (larg F rarg)(larg G rarg)(larg H rarg) ···⍞000D⍞000DTechnical notes:⍞000D⍞000D    lof←{                   ⍝ List of functions.⍞000D        ⍺←⊢                 ⍝ ambivalent.⍞000D        (⍺ ⍺⍺ ⍵),⊂⍺ ⍵⍵ ⍵    ⍝ one at a time.⍞000D    }⍞000D⍞000DOne  obstacle  is that the result from the leftmost function application must be⍞000D_enclosed_  prior to concatenation with the vector of results to its right. How-⍞000Dever,  it is not easy for the operator to determine when its left operand is the⍞000Dleftmost.  One  way  to overcome it takes several lines of additional code to be⍞000Dinterpreted  at  each  iteration (level) and involves the analysis of the ⎕CR of⍞000Dthe derived function of itself by itself (not very nice really) so here we do it⍞000Dby an additional, apparently redundant call to the operator with a constant null⍞000Dfunction {''''}. Using the example above we write:⍞000D⍞000D    {''''} lof F lof G lof H lof J array⍞000D⍞000DAs  we  go  down  the  tree,  each function in turn (J H G & F) is run as ⍵⍵ and⍞000Denclosed  while  ⍺⍺  gets  progressively  shallower  until it is just {''''} whose⍞000Dresult is ineffectively catenated to the left of the combined result.⍞000D⍞000DThe null call is only strictly necessary when the result of what would otherwise⍞000Dbe the leftmost function is other than a simple scalar, a real possibility! This⍞000Dis because the result of ⍺⍺ cannot be enclosed as it is the entire left spine of⍞000Dthe tree.⍞000D⍞000DAn alternative would be to provide a slightly different "special" coding for the⍞000Dleftmost operator:⍞000D⍞000D    _lof←{                  ⍝ Close list of functions.⍞000D        ⍺←⊢                 ⍝ ambivalent.⍞000D        (⍺ ⍺⍺ ⍵)(⍺ ⍵⍵ ⍵)    ⍝ one at a time.⍞000D    }⍞000D⍞000DExamples:⍞000D⍞000D    ⊃÷/ +/lof⍴ 1 2 3 4                              ⍝ arithmetic mean.⍞000D2.5⍞000D    cvex←''will'' ''you'' ''nill''                        ⍝ vector of vectors.⍞000D⍞000D    {2↑⍵} lof {2↑⌽⍵} lof {⌽2↑⍵} cvex                ⍝ without left closure.⍞000D┌────┬───┬──────────┬──────────┐⍞000D│will│you│┌────┬───┐│┌───┬────┐│⍞000D│    │   ││nill│you│││you│will││⍞000D│    │   │└────┴───┘│└───┴────┘│⍞000D└────┴───┴──────────┴──────────┘⍞000D⍞000D    {''''} lof {2↑⍵} lof {2↑⌽⍵} lof {⌽2↑⍵} cvex       ⍝ explicit closure.⍞000D┌──────────┬──────────┬──────────┐⍞000D│┌────┬───┐│┌────┬───┐│┌───┬────┐│⍞000D││will│you│││nill│you│││you│will││⍞000D│└────┴───┘│└────┴───┘│└───┴────┘│⍞000D└──────────┴──────────┴──────────┘⍞000D⍞000D    {2↑⍵} _lof {2↑⌽⍵} lof {⌽2↑⍵} cvex               ⍝ closure using [_lof].⍞000D┌──────────┬──────────┬──────────┐⍞000D│┌────┬───┐│┌────┬───┐│┌───┬────┐│⍞000D││will│you│││nill│you│││you│will││⍞000D│└────┴───┘│└────┴───┘│└───┴────┘│⍞000D└──────────┴──────────┴──────────┘⍞000D⍞000DSee also: vof Function_arrays truth_tables co_ops⍞000D⍞000DIndex:conditional operator|functions, list of|co-operator⍞000DIndex;Last P.' 
