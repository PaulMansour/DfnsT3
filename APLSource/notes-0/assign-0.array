'bmat ← ##.assign costs                      ⍝ Hungarian method cost assignment.⍞000D⍞000D[assign] is a classic algorithm  implemented in the D style.  H.W.Kuhn published⍞000Da  pencil  and paper version in 1955, which was followed by J.R.Munkres'' execut-⍞000Dable  version  in 1957. The algorithm is sometimes referred to as the "Hungarian⍞000Dmethod".⍞000D⍞000DThe  method  indicates  an  optimal assignment of a set of resources to a set of⍞000Drequirements,  given  a  "cost"  of  each potential match. Examples might be the⍞000Dallocation  of workers to tasks; the supply of goods by factories to warehouses;⍞000Dor the matching of brides with grooms. The function takes a cost matrix as argu-⍞000Dment and returns a boolean assignment matrix result.⍞000D⍞000DThe  following  table  shows an optimal assignment of factories F, G, H to ware-⍞000Dhouses W, X, Y, given that the cost of transportation from F to W is 72 units, F⍞000Dto X is 99 units, ···, G to W is 23 units, ··· and so on.⍞000D⍞000D      W    X    Y⍞000D    ┌────┬────┬────┐⍞000D  F │[72]│ 99 │ 88 │       Minimum-cost assignment marked [.]:⍞000D    ├────┼────┼────┤⍞000D  G │ 23 │ 30 │[35]│       Factory F supplies warehouse W,⍞000D    ├────┼────┼────┤          ··   G   ··  ··  ··  ··   Y,⍞000D  H │ 51 │[59]│ 84 │          ··   H   ··  ··  ··  ··   X.⍞000D    └────┴────┴────┘⍞000D⍞000DNotice that if the problem requires maximizing a benefit, rather than minimizing⍞000Da cost, then a negative cost matrix is used. See below for an example.⍞000D⍞000DTechnical notes:⍞000D⍞000DMunkres'' algorith may be described in words as follows:⍞000D⍞000DStep 0:⍞000DEnsure the costs matrix has at least as many rows as columns, by appending extra⍞000D0-item rows if necessary. Go to Step 1.⍞000D⍞000DStep 1:⍞000DSubtract the smallest item in each row from the row. Go to Step 2.⍞000D⍞000DStep 2:⍞000DSelect a set of "independent" zeros in the matrix and mark them with a star (*).⍞000DTo do this, star leading zeros in each row and column, ignoring rows and columns⍞000Dalready  containing stars; repeat this process until apart from ignored rows and⍞000Dcolumns, no more zeros remain. Go to Step 3.⍞000D⍞000DStep 3:⍞000DDraw  a  line through (cover) each column containing a starred zero. If all col-⍞000Dumns  are  covered,  the  starred zeros represent an optimal assignment. In this⍞000Dcase, return a boolean matrix with the positions of the stars, as result. Other-⍞000Dwise, go to Step 4.⍞000D⍞000DStep 4:⍞000DFind  an uncovered zero. If there is none, go to Step 6 passing the smallest un-⍞000Dcovered value as a parameter. Otherwise, mark the zero with a prime ('') and call⍞000Dit  P0. If there is a starred zero (S1) in the row containing P0, cover this row⍞000Dand  uncover  the column containing S1, then repeat Step 4. Otherwise, (if there⍞000Dis no starred zero in P0''s row) go to Step 5.⍞000D⍞000DStep 5:⍞000DFind  a  path  through alternating primes and stars. Starting with the uncovered⍞000Dprime  (P0) found in Step 4, find a star S1 (if  any) in its column. Then find a⍞000Dprime  P2  (there  must be one) in S1''s row, followed by  a  star S3 (if any) in⍞000DP2''s  column,  ··· and so on until a prime (Pn) is found that has no star in its⍞000Dcolumn.  In  the  series P0, S1, P2, S3, ··· Pn, unstar each starred zero Si and⍞000Dstar  each  primed zero Pj. Finally, unprime all primed zeros in the matrix, un-⍞000Dcover all rows and columns. Go to Step 3.⍞000D⍞000DStep 6:⍞000DAdd  the  minimum  cost  value passed from Step 4 to each twice-covered (row and⍞000Dcolumn  covered)  item, and subtract it from each uncovered item. Preserving all⍞000Dstars, primes and covering lines, go to Step 4.⍞000D⍞000DThe approach uses a rather convoluted "stepping algorithm", which can be repres-⍞000Dented as a flowchart:⍞000D⍞000D        step0       after step:0, go to step:1.⍞000D          ↓⍞000D          │⍞000D        step1       after step:1, go to step:2.⍞000D          ↓⍞000D          │⍞000D        step2       after step:2, go to step:3.⍞000D          ↓⍞000D          │⍞000D      ┌→step3───→   after step:3, go to step:4 or exit.⍞000D      │   │⍞000D    ┌─│─→─↓─←───┐⍞000D    │ │   │     ↑⍞000D    │ │ step4─→─┤   after step:4, go to step:4 or step:5 or step:6.⍞000D    ↑ ↑   │     ↓⍞000D    │ │   ↓─←─┐ │⍞000D    │ │   │   │ │⍞000D    │ └─step5─┘ │   after step:5, go to step:5 or step:3.⍞000D    ↑     ┌─←───┘⍞000D    │     ↓⍞000D    │   step6       after step:6, go to step:4.⍞000D    │     ↓⍞000D    └──←──┘⍞000D⍞000DThe algorithm is implemented by coding each step as a separate sub-function, and⍞000Dtail-calling from one step to the next. This is as close as we come to branching⍞000Din D!⍞000D⍞000DNotice  that  nearly  all  of the primitive and defined functions in [##.assign]⍞000Ddeal in matrices - a tribute to APL''s native array-handling.⍞000D⍞000DThe state is represented by 3 matrices at each step:⍞000D⍞000D    costs:  the current cost matrix.⍞000D⍞000D    zeros:  marked zeros: 0-not a zero, 1-unmarked zero, 2-starred, 3-primed.⍞000D⍞000D    covers: 0-uncovered  item, 1-item covered by horizontal (row covering) line,⍞000D            2-item covered by vertical (column covering) line, 3-item covered by⍞000D            both horizontal and vertical lines.⍞000D⍞000DIn  addition, step 5 takes a boolean matrix left argument, indicating the posit-⍞000Dion of the first primed zero.⍞000D⍞000DUsing the example cost matrix from above, the following trace shows the state of⍞000Dplay between each step ─[n]─.⍞000D⍞000D  ┌──────────┐   ┌──────────┐   ┌──────────┐   ┌──────────┐   ┌──────────┐⍞000D  │72  99  88│   │ 0  27  16│   │*0  27  16│   │*0│ 27  16│   │*0│ 27  16│⍞000D  │23  30  35├[1]┤ 0   7  12├[2]┤ 0   7  12├[3]┤ 0│  7  12├[4]┤ 0│  7  12├[6]─··⍞000D  │51  59  84│   │ 0   8  33│   │ 0   8  33│   │ 0│  8  33│   │ 0│  8  33│(7)⍞000D  └──────────┘   └──────────┘   └──────────┘   └──────────┘   └──────────┘⍞000D  ┌──────────┐   ┌──────────┐   ┌──────────┐   ┌──────────┐   ┌──────────┐⍞000D  │*0│ 20   9│   │*0│ 20   9│   │*0  20   9│   │*0│ 20│  9│   │*0│ 20│  9│⍞000D··┤ 0│  0   5├[4]┤ 0│[''0]  5├[5]┤ 0  *0   5├[3]┤ 0│ *0│  5├[4]┤ 0│ *0│  5├[6]─··⍞000D  │ 0│  1  26│   │ 0│  1  26│   │ 0   1  26│   │ 0│  1│ 26│   │ 0│  1│ 26│(5)⍞000D  └──────────┘   └──────────┘   └──────────┘   └──────────┘   └──────────┘⍞000D  ┌──────────┐   ┌──────────┐   ┌──────────┐   ┌──────────┐   ┌──────────┐⍞000D  │*0│ 20│  4│   │*0│ 20   4│   │*0│ 19   3│   │*0│ 19   3│   │*0  19   3│⍞000D··┤ 0│ *0│  0├[4]┤ 0┼─*0──''0├[6]┤─1┼─*0──''0├[4]┤─1┼[*0][''0├[5]┤ 1   0  *0├[3]─··⍞000D  │ 0│  1│ 21│   │ 0│  1  21│(1)│ 0│  0  20│   │ 0│[''0] 20│   │ 0  *0  20│⍞000D  └──────────┘   └──────────┘   └──────────┘   └──────────┘   └──────────┘⍞000D  ┌──────────┐⍞000D  │ 1   0   0│⍞000D··┤ 0   0   1│⍞000D  │ 0   1   0│⍞000D  └──────────┘⍞000D⍞000DReferences:⍞000D⍞000D    H.W.Kuhn, The Hungarian method for the assignment problem, Naval Research⍞000D    Logistics Quarterly, 2 (1955), pp. 83-97.⍞000D⍞000D    J.R.Munkres, Algorithms for the assignment and transportation problems,⍞000D    J. SIAM 5 (1957) 32-38.⍞000D⍞000DExamples:⍞000D⍞000D      costs                         ⍝ example cost matrix.⍞000D72 99 88⍞000D23 30 35⍞000D51 59 84⍞000D⍞000D      assign costs                  ⍝ minimum cost assignment.⍞000D1 0 0⍞000D0 0 1⍞000D0 1 0⍞000D⍞000D      assign -costs                 ⍝ maximum benefit assignment.⍞000D0 1 0⍞000D1 0 0⍞000D0 0 1⍞000D⍞000D      {+/+/⍵×assign ⍵} costs        ⍝ total minimum cost.⍞000D166⍞000D⍞000D      {+/+/-⍵×assign ⍵} -costs      ⍝ total maximum benefit.⍞000D206⍞000D⍞000D      costs←?6 10⍴50                ⍝ new 6×10 cost matrix.⍞000D⍞000D      costs⍞000D 7 38 23 27 11  3 34 34 47 20⍞000D26 42  2  3 27 34  1 20  4 21⍞000D35 30 47 43 27  5 33 21 36 46⍞000D39 14  3 37 17 32 38 50 19 13⍞000D50 37 38 33  4 32 45 14 22 39⍞000D24 12 14 18  9 25 45 46  4 46⍞000D⍞000D      assign costs                  ⍝ minimum cost assignment.⍞000D1 0 0 0 0 0 0 0 0 0⍞000D0 0 0 0 0 0 1 0 0 0⍞000D0 0 0 0 0 1 0 0 0 0⍞000D0 0 1 0 0 0 0 0 0 0⍞000D0 0 0 0 1 0 0 0 0 0⍞000D0 0 0 0 0 0 0 0 1 0⍞000D⍞000D      {⍵×assign ⍵} costs            ⍝ cost per assignment.⍞000D7 0 0 0 0 0 0 0 0 0⍞000D0 0 0 0 0 0 1 0 0 0⍞000D0 0 0 0 0 5 0 0 0 0⍞000D0 0 3 0 0 0 0 0 0 0⍞000D0 0 0 0 4 0 0 0 0 0⍞000D0 0 0 0 0 0 0 0 4 0⍞000D⍞000D      {+/+/⍵×assign ⍵} costs        ⍝ total minimum cost.⍞000D24⍞000D⍞000D      assign -costs                 ⍝ maximum benefit assignment.⍞000D0 0 0 0 0 0 0 0 1 0⍞000D0 1 0 0 0 0 0 0 0 0⍞000D0 0 1 0 0 0 0 0 0 0⍞000D0 0 0 0 0 0 0 1 0 0⍞000D1 0 0 0 0 0 0 0 0 0⍞000D0 0 0 0 0 0 0 0 0 1⍞000D⍞000D      {-⍵×assign ⍵} -costs          ⍝ cost per assignment.⍞000D 0  0  0 0 0 0 0  0 47  0⍞000D 0 42  0 0 0 0 0  0  0  0⍞000D 0  0 47 0 0 0 0  0  0  0⍞000D 0  0  0 0 0 0 0 50  0  0⍞000D50  0  0 0 0 0 0  0  0  0⍞000D 0  0  0 0 0 0 0  0  0 46⍞000D⍞000D      {+/+/-⍵×assign ⍵} -costs      ⍝ total maximum benefit.⍞000D282⍞000D⍞000D      costs←?10 6⍴50                ⍝ new 10×6 cost matrix⍞000D⍞000D      costs⍞000D14  1 21  2 36 47⍞000D12 10 16 45 33  8⍞000D35 20 20 25  8 30⍞000D43 30 48 28  8 50⍞000D21  8 29 13 25 24⍞000D49  7 10 16 32  7⍞000D33 32 41 13 24 20⍞000D11  2 46 22  8 48⍞000D21  7 45  5  9  4⍞000D19 13  7 40 23 18⍞000D⍞000D      assign costs                  ⍝ minimum cost assignment.⍞000D0 1 0 0 0 0⍞000D1 0 0 0 0 0⍞000D0 0 0 0 1 0⍞000D0 0 0 0 0 0⍞000D0 0 0 0 0 0⍞000D0 0 0 0 0 1⍞000D0 0 0 1 0 0⍞000D0 0 0 0 0 0⍞000D0 0 0 0 0 0⍞000D0 0 1 0 0 0⍞000D⍞000DSee also: Graphs X apportion⍞000D⍞000DIndex:assignment|Hungarian method|maximise|optimise|graph|independent zeros⍞000DIndex;Kuhn H.W.|Munkres J.R.' 
