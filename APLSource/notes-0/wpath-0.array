'path ← wgraph ##.wpath (from to) ⍝ Quickest path from/to ⍵ in weighted graph ⍺.⍞000D⍞000D[wgraph] is a 2-row matrix representing a weighted graph. The result [path] is a⍞000Dvector  that  represents  a  lowest-cost path between the given vertices. Notice⍞000Dthat the return path (to from) may not be the reverse of the forward path.⍞000D⍞000DNB:  All  of the weights in the 2nd row of [wgraph] must be non-negative, other-⍞000Dwise the result is unpredictable.⍞000D⍞000DTechnical notes:⍞000D⍞000DShortest  paths  through  _unweighted_  graphs, result immediately from a simple⍞000Dbreadth-first  search:  the  target  vertex is discovered in the fewest possible⍞000Dsteps, as the search radiates outwards from the starting vertex.⍞000D⍞000DHowever,  with  a _weighted_ graph, the search can''t stop on finding the target,⍞000Das  there may yet be lower-cost paths. The technique used here, is to maintain a⍞000Dcost-to-reach  value  (which  is initialised to: ⌊/⍳0), for each vertex. At each⍞000Dpoint  in  the  search,  vertices  are pursued only if the cost of reaching them⍞000Dwould be less than their current cost-to-reach value. In this case, the cost-to-⍞000Dreach value for the vertices is adjusted accordingly and the search continued.⍞000D⍞000DAs  the  "wave" front of visited vertices radiates from the starting vertex, the⍞000Dcode uses a destructive partial assignment to update tree and cost vectors:⍞000D⍞000D        tree[wave]← ...         ⍝ link tree nodes to parent.⍞000D        cost[wave]← ...         ⍝ update cost vector.⍞000D⍞000DA  problem arises if the wave converges on the same vertex from two or more dir-⍞000Dections.  The  following  diagram  shows the wave propogating left-to-right from⍞000Dvertices A, B and C with cost-to-reach values of 8 9 and 7, respectively.⍞000D⍞000D        A[8]───4──→─┐⍞000D                    │⍞000D        B[9]───2──→─D[?]⍞000D                    │⍞000D        C[7]───6──→─┘⍞000D⍞000DThe  edge  costs  A→D, B→D and C→D are 4 2 and 6, so the cost-to-reach D must be⍞000Dset to:⍞000D            ⌊8 9 7+4 2 6⍞000D        11⍞000D⍞000DThe  partial  assignment can be made "just to work" if we assign links and costs⍞000Din _decreasing_ cost order:⍞000D⍞000D        tree[··D··D··D··] ←  ··  C  A  B ·· ⍝ link tree nodes to parent.⍞000D        cost[··D··D··D··] ←  ·· 13 12 11 ·· ⍝ update cost vector.⍞000D⍞000DAPL''s  indexed assignment is defined to process its subscripts left-to-right, so⍞000Dthat the right-most assignment to D is the only effective one. Here is the code:⍞000D⍞000D        ...⍞000D        cvec←↑,/mask/¨totl          ⍝ cost vector.⍞000D        decr←⍒cvec                  ⍝ decreasing cost order.⍞000D        wave←decr⊃¨⊂↑,/next         ⍝ vertex wave front.⍞000D        tree[wave]←decr⊃¨⊂back      ⍝ link tree nodes to parent.⍞000D        cost[wave]←decr⊃¨⊂cvec      ⍝ update cost vector.⍞000D        ...⍞000D(⍞000D    ⍺⊃¨⊂⍵  is recognised as an idiom and is marginally quicker than the equival-⍞000D    ent ⍵[⍺].⍞000D)⍞000D⍞000DThanks to Mike Day for suggesting a fix to the original coding.⍞000D⍞000DA small but important refinement, is to keep track of the cost-to-reach value of⍞000Dthe _target_ node. Any path that would be more expensive than this is ignored:⍞000D⍞000D        best←(vals¨adjv)⌊to⊃cost    ⍝ costs to beat.⍞000D⍞000DSee also →bfs← for notes on parallel breadth-first search.⍞000D⍞000DExamples:⍞000D⍞000D    aa                      ⍝ weighted graph "aa"⍞000D┌───┬─┬───┬───┬─┐⍞000D│2 3│3│2 4│1 5│3│⍞000D├───┼─┼───┼───┼─┤⍞000D│1 3│1│4 1│1 1│1│⍞000D└───┴─┴───┴───┴─┘⍞000D⍞000D    aa wpath 3 2            ⍝ best path 3→2.⍞000D3 4 1 2⍞000D⍞000D    aa[1;] path 3 2         ⍝ compare: best path 3→2 _ignoring_ weights.⍞000D3 2⍞000D⍞000DSee also: wGraphs Graphs bfs wspan wcost path⍞000D⍞000DIndex:graph, weighted|path|assignment, destructive|assignment, indexed⍞000DIndex;Day M.' 
