'bfobj ← (##.mac) src                        ⍝ Simple macro processor for bf.⍞000D⍞000D[mac] is a simple macro processor intended for use with →bf←.⍞000D⍞000DOnly  single  characters may be used as names for definitions.  For example,  we⍞000Dcould define '';'' to generate the BF code to input a single character ''0''-''9'' and⍞000Dto subtract ''0'', leaving a number 0-9 in the current cell. This version uses its⍞000Dright neighbour as a temporary loop counter.⍞000D⍞000D    ;=,>------[+<-------->]<⍞000D⍞000DThe body of a macro definition extends from the ''='' character to the first white⍞000Dspace character (blank or newline).⍞000D⍞000DA macro body may be parenthesised in order to include white space or inner local⍞000Ddefinitions.⍞000D⍞000D\ Backslash prevents expansion of the immediately following character.⍞000D⍞000D        mac ''?=x  ?? \??\? ??''              ⍝ suppressed expansion of some ?s.⍞000D     xx ?x? xx⍞000D⍞000D/ Forward slash within a macro body replicates its immediately  following  char-⍞000D  acter by the number immediately to the left of the  macro  name in the calling⍞000D  context. If no number precedes the macro name, a replication of 0 is assumed:⍞000D⍞000D⍞000D        mac'' ∆=/+ <1∆> <2∆> <3 ∆> <4∆>''     ⍝ 1, 2, 0 and 4 +s.⍞000D     <+> <++> <3 > <++++>⍞000D⍞000DCombining  all of these techniques, here is a macro, which outputs a single num-⍞000Deric digit. It contains a local macro definition ∆:⍞000D⍞000D    :=(∆=/+ >6∆[-<8∆>]< .)⍞000D⍞000DTechnical note:⍞000D⍞000DMac''s  principal  function [mexp]''s use of sub-functions [defn] and [dref] illu-⍞000Dstrate a technique called "continuation-passing style" or CPS.⍞000D⍞000D[mexp]  uses  [defn]  and  [dref] respectively, to define and dereference names.⍞000DConceptually,  the  subfunctions each _return_ two lists of already- and yet-to-⍞000Dbe- processed tokens, with which [mexp] dyadically, and tail-recursively,  calls⍞000Ditself.⍞000D⍞000DWe can arrange that the calls on [defn] and [dref] are themselves tail-calls, if⍞000Dwe have them _call_ [mexp] rather than _return_ to it.  In other words, [mexp]''s⍞000Dtail-recursive call, following evaluation of its subfunctions is devolved to the⍞000Dsubfunctions.  We do this by passing [mexp] as operand (∇) to the  subfunctions,⍞000Dwhich then become suboperators:⍞000D⍞000D        b≡''='':⍺ ∇ defn ⍵            ⍝ = defn: accumulate.⍞000D                ¯⍞000D        a∊⊃⍺:⍺ ∇ dref ⍵             ⍝ ⍺ name: expand.⍞000D               ¯⍞000DNow [defn] and [dref] can tail-call [mexp], as ⍺⍺, rather than to return to it:⍞000D⍞000D        (⍺,⍨∘⊂¨name val)⍺⍺ dd uuu   ⍝ extended association vectors.⍞000D                        ¯¯⍞000D        ⍺ ⍺⍺ ddd(val(n copy)uu)     ⍝ expanded macro insert.⍞000D          ¯¯⍞000DThough used explicitly in this example, CPS is more frequently  employed  behind⍞000Dthe scenes by compiler-optimisers to transform stack-calls into tail-calls.⍞000D⍞000DSee: http://en.wikipedia.org/wiki/Continuation-passing_style⍞000D⍞000DExamples:⍞000D⍞000D    movl←''l=[-/<+/>] ''      ⍝ move left ⍺ cell positions ("/" replicates.).⍞000D⍞000D    mac movl, ''2l 1l 0l''    ⍝ move left 2 1 0 (the last of which will hang BF).⍞000D[-<<+>>] [-<+>] [-+]⍞000D⍞000D    mac''a=KO a=OK a''        ⍝ subsequent defns replace previous ones.⍞000DOK⍞000D    mac''a=K (a=O a)a''       ⍝ inner block defns shadow outer ones.⍞000DOK⍞000D    mac''a=OK b=a a=KO b''    ⍝ a expanded at b defn time.⍞000DOK⍞000D    mac''a=KO b=\a a=OK b''   ⍝ a expanded at b dref time.⍞000DOK⍞000D    mac''O=? b=\\\OK b''      ⍝ O not expanded.⍞000DOK⍞000D    mac''a=K b=(a=O a) ba''   ⍝ inner defn is local to block.⍞000DOK⍞000D⍞000D⍝ See →bfack← and →balm← for some more substantial examples.⍞000D⍞000DSee also: bfack balm bf⍞000D⍞000DIndex:Brainfuck|macro|continuation-passing style' 
