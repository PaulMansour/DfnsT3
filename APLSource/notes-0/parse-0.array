'tree ←  {trace←0} defn ##.parse expr    ⍝ Bunda-Gerth parse of expression ⍵.⍞000Dmatr ← {format←1} defn ##.parse ''''      ⍝ Bunda-Gerth binding matrix.⍞000D⍞000DJ.D.Bunda  and J.A.Gerth  describe an elegant parser for an infix notation, such⍞000Das APL:⍞000D⍞000D    "APL Two by Two - Syntax Analysis by Pairwise Reduction"⍞000D     J.D.Bunda, J.A.Gerth,⍞000D     ACM Sigapl Apl Quote Quad, vol. 14, no. 4, pp. 85-94, 1984.⍞000D⍞000DBunda-Gerth assigns binding-strength numbers between pairs of token  categories.⍞000DFor example,  an operator binds tighter to its operand,  than does a function to⍞000Dits argument.  Array-array binding (stranding) may bind tighter still, depending⍞000Don the dialect of APL.⍞000D⍞000DThese relative bindings can be expressed in  a  table  whose  entries  show  the⍞000Dstrength and resulting category of each bond.  Notice that some categories  (for⍞000Dexample operator with operator) do not bind:⍞000D⍞000D       ┌───┬────┬──┬───┬─┐⍞000D       │A  │F   │AF│M  │D│  Categories:⍞000D    ┌──┼───┼────┼──┼───┼─┤      A: Array⍞000D    │A │4 A│2 AF│  │3 F│ │      F: Ambi-valent function⍞000D    ├──┼───┼────┼──┼───┼─┤      M: Monadic operator⍞000D    │F │1 A│    │  │3 F│ │      D: Dyadic operator⍞000D    ├──┼───┼────┼──┼───┼─┤⍞000D    │AF│1 A│    │  │   │ │  For example, in the table to the left:⍞000D    ├──┼───┼────┼──┼───┼─┤      4 A: Array-Array binds with strength 4, to pro-⍞000D    │M │   │    │  │   │ │           duce an Array (strand).⍞000D    ├──┼───┼────┼──┼───┼─┤      3 F: Operand (array or function) binds with⍞000D    │D │3 M│3 M │  │   │ │           strength 3 to a monadic operator to produce⍞000D    └──┴───┴────┴──┴───┴─┘           a (derived) function.⍞000D⍞000DFor the purposes of parsing, the table may need some categories that do not  ap-⍞000Dpear explicitly in the language.  In the above,  AF represents the  binding of a⍞000Ddyadic function to its left argument array, to form a monadic function:⍞000D⍞000D    2+3 → (2+)3     ⍝ A:F:A→AF:A    "left-argument currying".⍞000D⍞000DSimilarly, a dyadic  operator  binds with a right operand  function or array  to⍞000Dproduce a monadic operator:⍞000D⍞000D    +.× → +(.×)     ⍝ F:D:F→F:M      right-operand currying.⍞000D⍞000D(muse:⍞000D⍞000D    Whether such constructs appear explicitly is an  aesthetic  choice  for  the⍞000D    language designer. The following would seem pretty handy:⍞000D⍞000D          limit ← ⍣≡        ⍝ D:F→M right-operand currying⍞000D        inverse ← ⍣¯1       ⍝ D:F→M   ..      ..      ..⍞000D⍞000D    There is less pressure to provide explicit left-argument currying:⍞000D⍞000D        next ← 1+           ⍝ A:F→AF left-argument currying.⍞000D⍞000D    as we can already do this with the primitive compose operator:⍞000D⍞000D        next ← 1∘+          ⍝ though not quite as prettily.⍞000D)⍞000D⍞000DGiven a binding table and an expression to be parsed, Bunda-Gerth identifies the⍞000Dbinding strengths between each pair of tokens.⍞000D⍞000DFor example, using the above table and the expression (+.×/2⍴⊂4 5⍴6), the col-⍞000Dumns below represent the inter-token bindings.  Notice that some categories do⍞000Dnot bind (for example F:F) and so have a notional binding strength of 0:⍞000D⍞000D                   ⎕        ┐⍞000D       ⎕ ⎕         ⎕        │ token-to-token binding strengths.⍞000D       ⎕ ⎕   ⎕     ⎕ ⎕      │⍞000D       ⎕ ⎕   ⎕   ⎕ ⎕ ⎕ ⎕    ┘⍞000D    ┌┴┬┴┬┴┬┴┬┴┬┴┬┴┬┴┬┴┬┴┐⍞000D    F D F M A F F A A F A   ⍝ token categories⍞000D    + . × / 2 ⍴ ⊂ 4 5 ⍴ 6   ⍝ subject expression⍞000D⍞000DWorking right-to-left, the algorithm identifies  the  rightmost  "peak"  in  the⍞000Dabove diagram.  The  tokens on either side of the peak are bound and the process⍞000Drepeated until either: a single token remains, the result of a successful parse;⍞000Dor no adjacent tokens bind, which indicates a syntax error. For a plateau of ad-⍞000Djacent columns of equal height, the leftmost column is chosen.⍞000D⍞000DHere  is  a worked example in which the rightmost (next to be bound) peak is id-⍞000Dentified by a column of ''⌹'' characters.⍞000D⍞000D                   ⌹        ← rightmost peak (⌹)⍞000D       ⎕ ⎕         ⌹⍞000D       ⎕ ⎕   ⎕     ⌹ ⎕⍞000D       ⎕ ⎕   ⎕   ⎕ ⌹ ⎕ ⎕⍞000D    ┌┴┬┴┬┴┬┴┬┴┬┴┬┴┬┴┬┴┬┴┐⍞000D    F D F M A F F A A F A   ← categories⍞000D    + . × / 2 ⍴ ⊂ 4 5 ⍴ 6   ← expression tokens⍞000D                  └┬┘       ← binding⍞000D                  A:A→A     ← binding rule from table.⍞000D       ⎕ ⎕⍞000D       ⎕ ⎕   ⎕       ⌹⍞000D       ⎕ ⎕   ⎕   ⎕   ⌹ ⎕⍞000D    ┌┴┬┴┬┴┬┴┬┴┬┴┬┴─┬─┴┬┴┐⍞000D    F D F M A F F  A  F A⍞000D    + . × / 2 ⍴ ⊂ ┌┴┐ ⍴ 6   ← bound tokens⍞000D                  4 5 │⍞000D                   └┬─┘     ← next binding⍞000D                   A:F→AF⍞000D       ⎕ ⎕⍞000D       ⎕ ⎕   ⎕⍞000D       ⎕ ⎕   ⎕        ⌹⍞000D    ┌┴┬┴┬┴┬┴┬┴┬┴┬─┴─┬─┴─┐⍞000D    F D F M A F F   AF  A⍞000D    + . × / 2 ⍴ ⊂  ┌┴─┐ 6⍞000D                  ┌┴┐ ⍴ │⍞000D                  4 5   │⍞000D                    └─┬─┘⍞000D                    AF:A→A⍞000D       ⎕ ⎕⍞000D       ⎕ ⎕   ⎕⍞000D       ⎕ ⎕   ⎕     ⌹⍞000D    ┌┴┬┴┬┴┬┴┬┴┬┴┬──┴──┐⍞000D    F D F M A F F     A⍞000D    + . × / 2 ⍴ ⊂   ┌─┴─┐⍞000D                │  ┌┴─┐ 6⍞000D                │ ┌┴┐ ⍴⍞000D                │ 4 5⍞000D                └──┬──┘⍞000D                  F:A→A⍞000D       ⎕ ⎕⍞000D       ⎕ ⎕   ⌹⍞000D       ⎕ ⎕   ⌹  ⎕⍞000D    ┌┴┬┴┬┴┬┴┬┴┬─┴──┐⍞000D    F D F M A F    A⍞000D    + . × / 2 ⍴ ┌──┴──┐⍞000D            └┬┘ ⊂   ┌─┴─┐⍞000D            A:F→AF ┌┴─┐ 6⍞000D                  ┌┴┐ ⍴⍞000D                  4 5⍞000D       ⎕ ⎕⍞000D       ⎕ ⎕⍞000D       ⎕ ⎕      ⌹⍞000D    ┌┴┬┴┬┴┬┴─┬──┴──┐⍞000D    F D F M  AF    A⍞000D    + . × / ┌┴┐ ┌──┴──┐⍞000D            2 ⍴ ⊂   ┌─┴─┐⍞000D             │     ┌┴─┐ 6⍞000D             │    ┌┴┐ ⍴⍞000D             │    4 5⍞000D             └──┬──┘⍞000D              AF:A→A⍞000D       ⌹ ⎕⍞000D       ⌹ ⎕⍞000D       ⌹ ⎕⍞000D    ┌┴┬┴┬┴┬──┴──┐⍞000D    F D F M     A⍞000D    + . × /  ┌──┴──┐⍞000D      └┬┘   ┌┴┐ ┌──┴──┐⍞000D       │    2 ⍴ ⊂   ┌─┴─┐⍞000D      D:F→M        ┌┴─┐ 6⍞000D                  ┌┴┐ ⍴⍞000D                  4 5⍞000D     ⌹⍞000D     ⌹⍞000D     ⌹⍞000D    ┌┴─┬┴─┬──┴──┐⍞000D    F  M  M     A⍞000D    + ┌┴┐ /  ┌──┴──┐⍞000D    │ . ×   ┌┴┐ ┌──┴──┐⍞000D    └┬─┘    2 ⍴ ⊂   ┌─┴─┐⍞000D    F:M→F          ┌┴─┐ 6⍞000D                  ┌┴┐ ⍴⍞000D                  4 5⍞000D        ⌹⍞000D        ⌹⍞000D        ⌹⍞000D     ┌──┴─┬──┴──┐⍞000D     F    M     A⍞000D    ┌┴─┐  /  ┌──┴──┐⍞000D    + ┌┴┐ │ ┌┴┐ ┌──┴──┐⍞000D      . × │ 2 ⍴ ⊂   ┌─┴─┐⍞000D     └─┬──┘        ┌┴─┐ 6⍞000D      F:M→F       ┌┴┐ ⍴⍞000D                  4 5⍞000D            ⌹⍞000D       ┌────┴───┐⍞000D       F        A⍞000D     ┌─┴──┐  ┌──┴──┐⍞000D    ┌┴─┐  / ┌┴┐ ┌──┴──┐⍞000D    + ┌┴┐   2 ⍴ ⊂   ┌─┴─┐⍞000D      . -          ┌┴─┐ 6⍞000D       │        │ ┌┴┐ ⍴⍞000D       │        │ 4 5⍞000D       └────┬───┘⍞000D           F:A→A⍞000D⍞000D           A⍞000D       ┌───┴────┐⍞000D     ┌─┴──┐  ┌──┴──┐⍞000D    ┌┴─┐  / ┌┴┐ ┌──┴──┐⍞000D    + ┌┴┐   2 ⍴ ⊂   ┌─┴─┐⍞000D      . ×          ┌┴─┐ 6⍞000D                  ┌┴┐ ⍴⍞000D                  4 5⍞000D⍞000D[parse] implements a general Bunda-Gerth parser, which takes its language defin-⍞000Dition  as  left  argument  and  returns either a (formatted) binding matrix or a⍞000Dparse tree for right argument character vector [expr].⍞000D⍞000DLeft argument [defn] defines the relative binding  strengths  of  categories  of⍞000Dtokens for an APL-like infix language. The definition may be a character matrix;⍞000Dvector (with embedded newlines); or a vector of character vectors.⍞000D⍞000DIf right argument [expr] is null, [parse] returns the binding matrix.⍞000D⍞000DA two-item left argument [opt defn], where opt is 0 or 1, specifies whether:⍞000D⍞000D- The binding table should be formatted, in the case of a null [expr]⍞000D- The parsing should be traced, in the case of a non-null [expr]⍞000D⍞000DOtherwise, if [expr] is non-null, it is assumed to be an expression  of  tokens,⍞000Dspecified as representatives of each category, in the first section of the  def-⍞000Dinition.⍞000D⍞000DNote that an unformatted binding table  may  be  re-input  as a left argument to⍞000Dsave the cost of compiling the definitions on subsequent calls.  See the example⍞000Dbelow.⍞000D⍞000DBinding Definition⍞000D------------------⍞000DThe definition is split into blank-line-separated sections. The first section is⍞000Dspecial and defines token categories and representative tokens in each category.⍞000DFor example:⍞000D⍞000DA 1 2 3 4   ⍝ Category ''A'' with representatives ''1'' ''2'' ''3'' and ''4''.⍞000DF + - × ÷   ⍝ Category ''F''  ..      ..      ..  ''+'' ''-'' ''×'' and ''÷''.⍞000DAF          ⍝ Category ''AF'' with no explicit representatives.⍞000D⍞000DIn addition, the first section may contain a line that defines any bracket-pairs⍞000Dused in an expression, over and above primitive parentheses (). This line is id-⍞000Dentified by a starting pair () and followed by any number of pairs of characters⍞000Dthat are to be interpreted as expression-enclosing brackets. For example:⍞000D⍞000D() [INDX] {DFN}     ⍝ recognise square brackets and curly braces.⍞000D⍞000DBrackets are defined, rather than being hard-coded in the parser because:⍞000D⍞000D- In some infix notations, such as J, [, ], { and } do not constitute brackets.⍞000D- It allows the introduction of additional bracket pairs such as: < > ┌ ┐ ...⍞000D⍞000DEach of the subsequent sections defines bonds between pairs  of  categories, to-⍞000Dgether with the category of the resulting bound pair:⍞000D⍞000D    A:B→C       ⍝ A binds with B to produce C.⍞000D⍞000DWithin a section, the bonds all have the same binding-strength; bonds in earlier⍞000Dsections are stronger than those in later sections. For example:⍞000D⍞000D    A 1 2 3 4   ⍝ 0th section: category ''A''; reps ''1'' ''2'' ''3'' ''4''⍞000D    F + - × ÷   ⍝ 0th section: category ''F''; reps ''+'' ''-'' ''×'' ''÷''⍞000D    AF          ⍝ 0th section: category ''AF; no representatives.⍞000D⍞000D    A:F→AF      ⍝ 1st section:  A binds (strength 2) to F to produce AF⍞000D⍞000D    AF:A→A      ⍝ 2nd section: AF binds (strength 1) to A to produce A⍞000D    F:A→A       ⍝ 2nd section:  F binds (strength 1) to A to produce A⍞000D⍞000DDistributions⍞000D-------------⍞000DRows and columns in the binding table often contain repeated items. For example,⍞000Dthe left operand of an operator could be an array or a function, so the definit-⍞000Dion might contain the line:⍞000D⍞000D    A:MOP→F F:MOP→F⍞000D⍞000DIn  such  cases,  categories may be grouped with a ''.'' character. and the common⍞000Dcategory "factored out":⍞000D⍞000D    A:MOP→F F:MOP→F  <=>  A.F:MOP→F⍞000D⍞000DIn general:⍞000D⍞000D    A.B:Y→Z  <=>  A:Y→Z B:Y→Z⍞000D    A:X.Y→Z  <=>  A:Z→Z A:Y→Z⍞000D⍞000DOn expansion, the outer product of the items on the left is  matched against the⍞000Dlist of items on the right. A single result item on the  right  is  extended  to⍞000Dconform:⍞000D⍞000D    A.B:C.D→Z  <=>  A:C→Z A:D→Z⍞000D                    B:C→Z B:D→Z⍞000D⍞000D    A.B:C→X.Y  <=>  A:C→X B:C→Y⍞000D⍞000D    A:B.C→X.Y  <=>  A:B→X A.C→Y⍞000D⍞000DMacros⍞000D------⍞000DLines starting: word=... define a macro, whose body  is  substituted  throughout⍞000Dthe definition script. For example, using the previous example, we could code:⍞000D⍞000D    rand=A.F        ⍝ macro: operand can be function or array:⍞000D⍞000D    rand:MOP→F      ⍝ operand bound with monadic operator to derive function.⍞000D⍞000Dwhich expands:⍞000D⍞000D    rand:MOP→F⍞000D=>  A.F:MOP→F           ⍝ (macro expansion of "rand")⍞000D=>  A:MOP→F F:MOP→F     ⍝ (distribution of MOP)⍞000D⍞000DBugs:⍞000D⍞000D[0] Tokens (category representatives) may be only single characters.⍞000D[1] There is no way to identify a D-operator, as opposed to a D-function.⍞000D[2] Bunda-Gerth unconditionally left-associates adjacent tokens of the same cat-⍞000D    egory.  This  is  fine for classic APL, where only array-sequences (strands)⍞000D    occur but if we were to extend the language with, say, operator and function⍞000D    "trains" we might want operator trains to associate left and function trains⍞000D    to associate right.  A  solution might be to add associativity indication to⍞000D    the category definitions and to right-accumulate  speculatively  instead  of⍞000D    just skipping left along the token stream. This speculative right-associated⍞000D    tree would then be emitted if a weaker binding is encountered,  or  consumed⍞000D    piecewise by a stronger binding.⍞000D⍞000DRequires: →segs← →disp← →subs←⍞000D⍞000D(muse:⍞000D⍞000D    At first glance conventional "BIDMAS" (Brackets, Indexing (power), Division/⍞000D    Multiplication, Addition/Subtraction) arithmetic appears ideally suited to a⍞000D    two-by-two treatment. But there''s a problem.  Monadic minus binds tightly to⍞000D    the number on its right if there''s a function to its left but  less  tightly⍞000D    if there''s a number to its left.⍞000D⍞000D        2+-3×4 → 2+((-3)×4)     ⍝ -:3 >> 3:×⍞000D        2 -3×4 → 2-(3×4)        ⍝ -:3 << 3:×⍞000D⍞000D    In the presence of monadic minus, BIDMAS appears not to be two-by-two.⍞000D)⍞000D⍞000DTechnical note:⍞000D⍞000D[parse] uses a 3-window "Turing tape" to represent the token stream. See section⍞000D"Turing''s Tape" in: →bf←. For an approach closer to the Bunda-Gerth paper, which⍞000Duses repeated pair-wise reduction  2{...}/  see sub-function "parse" within →kk←⍞000Dat http://dfns.dyalog.com/c_kk.htm.⍞000D⍞000DIn particular:⍞000D⍞000D    ∆_ Aa Bb Cc _∆ ← ⍵      ⍝ exposes three adjacent tokens in mid-stream.⍞000D⍞000D    lft←{                   ⍝ move left one token in stream ⍵.⍞000D        (∆_ L)A B C _∆ ← ⍵⍞000D         ∆_ L A B(C _∆)⍞000D    }⍞000D⍞000D    rgt←{                   ⍝ move right one token in stream ⍵.⍞000D        ∆_ A B C(R _∆) ← ⍵⍞000D       (∆_ A)B C R _∆⍞000D    }⍞000D⍞000D    rewind ← rgt⍣{eos≡⊃⍺}   ⍝ >>| rewind to right end of tape.⍞000D⍞000DNotice that the token reducer itself is quite simple;  the bulk of [parse] being⍞000Dconcerned with compiling and formatting the tables and trees:⍞000D⍞000D    reduce←{                                    ⍝ 2-by-2 parsing.⍞000D        (∆_ L)Aa Bb Cc(R _∆)←⍵                  ⍝ 3-token window on stream.⍞000D        Aa Cc∧.≡eos:Bb                          ⍝ single node: done.⍞000D        Aa Bb∧.≡eos:⍵                           ⍝ error: partial parse.⍞000D        (A a)(B b)(C c)←Aa Bb Cc                ⍝ cats and toks.⍞000D        (⊂b c)∊1↓bkts:∇ rgt(∆_ L)Aa(ebk b)R _∆  ⍝ empty brackets [].⍞000D        (⊂a c)∊bkts:∇ rgt ∆_ L(a bkt Bb)R _∆    ⍝ bracketed single value Bb.⍞000D        (⊂a)∊rbs:∇ lft lft ⍵                    ⍝ right bracket: skip left.⍞000D        bonds←xmat[(A B)(B C)+1]                ⍝ A:B B:C bonds.⍞000D        ≥/bonds:∇ lft ⍵                         ⍝ A:B ≥ B:C → skip left.⍞000D        BbCc←zmat[B;C],⊂b c                     ⍝ B bound with C.⍞000D        ∇ show(∆_ L)Aa BbCc R _∆                ⍝ binds with token to the right?⍞000D    }                                           ⍝ :: stream ← ∇ stream⍞000D⍞000DExamples:⍞000D⍞000D⍝ Simple definition with Arrays and (ambi-valent) Functions.⍞000D⍝ Parentheses () need not be defined explicitly:⍞000D⍞000D    display af              ⍝ Arrays, Functions.⍞000D┌→──────────────────────────────────────┐⍞000D│A 1 2 3 4   ⍝ Arrays                   │⍞000D│F + - × ÷   ⍝ Functions                │⍞000D│AF          ⍝ bound left argument      │⍞000D│                                       │⍞000D│A:F→AF      ⍝ left argument to function│⍞000D│                                       │⍞000D│AF:A→A      ⍝ dyadic function          │⍞000D│ F:A→A      ⍝ monadic function         │⍞000D└───────────────────────────────────────┘⍞000D⍞000D    af parse''''              ⍝ Bunda-Gerth binding matrix.⍞000D   ┌───┬────┐⍞000D   │A  │F   │⍞000D┌──┼───┼────┤⍞000D│A │   │2 AF│⍞000D├──┼───┼────┤⍞000D│F │1 A│    │⍞000D├──┼───┼────┤⍞000D│AF│1 A│    │⍞000D└──┴───┴────┘⍞000D⍞000D    af parse''2×3+4''         ⍝ parse of simple expression.⍞000D   A⍞000D ┌─┴──┐⍞000D┌┴┐  ┌┴─┐⍞000D2 × ┌┴┐ 4⍞000D    3 +⍞000D⍞000D    af parse''(1+2)-3×÷4''    ⍝ parentheses are retained in the parse-tree.⍞000D         A⍞000D     ┌───┴───┐⍞000D  ┌──┴──┐  ┌─┴─┐⍞000D┌─┴─┐   - ┌┴┐ ┌┴┐⍞000D(  ┌┴─┐   3 × ÷ 4⍞000D  ┌┴┐ 2⍞000D  1 +⍞000D⍞000D    af parse ''(((2)))''      ⍝ redundant parentheses retained.⍞000D A⍞000D┌┴─┐⍞000D( ┌┴─┐⍞000D  ( ┌┴┐⍞000D    ( 2⍞000D⍞000D⍝ Definition extended with Array strands and operators.⍞000D⍝ Notice the use of macro "rand" for Array or Function operand:⍞000D⍞000D    display afo             ⍝ Arrays, Functions, Operators.⍞000D┌→─────────────────────────────────────────────────────┐⍞000D│ A   0 1 2 3 4      ⍝ Arrays                          │⍞000D│ F   + - × ÷        ⍝ Functions                       │⍞000D│ AF                 ⍝ bound left argument             │⍞000D│ MOP ¨              ⍝ Monadic operator                │⍞000D│ DOP . ∘ ⍣          ⍝ Dyadic operators                │⍞000D│                                                      │⍞000D│ rand=A.F           ⍝ macro: operand is A or F        │⍞000D│                                                      │⍞000D│ A:A→A              ⍝ strand binding, tightest of all │⍞000D│                                                      │⍞000D│ DOP:rand→MOP       ⍝ dyadic and                      │⍞000D│ rand:MOP→F         ⍝ ... monadic operators           │⍞000D│                                                      │⍞000D│ A:F→AF             ⍝ left argument to its function   │⍞000D│                                                      │⍞000D│ AF:A→A F:A→A       ⍝ function to its right argument. │⍞000D└──────────────────────────────────────────────────────┘⍞000D⍞000D    afo parse''''             ⍝ Bunda-Gerth binding matrix.⍞000D    ┌─────┬─────┬───┐⍞000D    │A    │F    │MOP│⍞000D┌───┼─────┼─────┼───┤⍞000D│A  │4 A  │2 AF │3 F│⍞000D├───┼─────┼─────┼───┤⍞000D│F  │1 A  │     │3 F│⍞000D├───┼─────┼─────┼───┤⍞000D│AF │1 A  │     │   │⍞000D├───┼─────┼─────┼───┤⍞000D│DOP│3 MOP│3 MOP│   │⍞000D└───┴─────┴─────┴───┘⍞000D⍞000D    afo parse ''0 1+.×¨3÷4''  ⍝ parse tree for operator-function-array binding.⍞000D         A⍞000D    ┌────┴────┐⍞000D ┌──┴──┐     ┌┴─┐⍞000D┌┴┐  ┌─┴──┐ ┌┴┐ 4⍞000D0 1 ┌┴─┐  ¨ 3 ÷⍞000D    + ┌┴┐⍞000D      . ×⍞000D⍞000D    afo parse ''0+1-2×3÷4''   ⍝ array-function sequences associate right.⍞000D    A⍞000D ┌──┴───┐⍞000D┌┴┐  ┌──┴──┐⍞000D0 + ┌┴┐  ┌─┴──┐⍞000D    1 - ┌┴┐  ┌┴─┐⍞000D        2 × ┌┴┐ 4⍞000D            3 ÷⍞000D⍞000D    afo parse ''+∘-∘×∘÷''     ⍝ operator-operand sequences associate left.⍞000D       F⍞000D    ┌──┴───┐⍞000D ┌──┴──┐  ┌┴┐⍞000D┌┴─┐  ┌┴┐ ∘ ÷⍞000D+ ┌┴┐ ∘ ×⍞000D  ∘ -⍞000D⍞000D    afo parse''+∘2 3''        ⍝ strand binds tighter than operator.⍞000D F⍞000D┌┴─┐⍞000D+ ┌┴─┐⍞000D  ∘ ┌┴┐⍞000D    2 3⍞000D⍞000D⍝ Finally, the definition is extended with: Dfn braces {F} and "hybrid" tokens:⍞000D⍝ / ⌿ \ ⍀ ←, each of which can act as either function or operator, depending on⍞000D⍝ whether the token to its left is an array or function. Note the use of⍞000D⍝ distributions.⍞000D⍞000D    display afho            ⍝ afo extended with hybrids: H / ⌿ \ ⍀ ←⍞000D┌→───────────────────────────────────────────────────┐⍞000D│A   0 1 2 3 4 a ⍺ ⍵     ⍝ Arrays                    │⍞000D│F   + - × ÷             ⍝ Functions                 │⍞000D│H   / ⌿ \ ⍀ ←           ⍝ Hybrid function/operators │⍞000D│AF                      ⍝ bound left argument       │⍞000D│MOP ¨ &                 ⍝ Monadic operators         │⍞000D│DOP . ∘ ⍣               ⍝ Dyadic operators          │⍞000D│() {F}                  ⍝ Dfn                       │⍞000D│                                                    │⍞000D│rand=A.F.H              ⍝ alias: operand            │⍞000D│                                                    │⍞000D│A:A→A                   ⍝ strand binding, tightest  │⍞000D│                                                    │⍞000D│DOP:rand→MOP            ⍝ dyadic and                │⍞000D│rand:MOP→F              ⍝ ... monadic operators     │⍞000D│F:H→F                   ⍝ hybrid as operator        │⍞000D│                                                    │⍞000D│A:F.H→AF                ⍝ left arg to its function  │⍞000D│                                                    │⍞000D│AF.F:A→A                ⍝ function to its right arg.│⍞000D└────────────────────────────────────────────────────┘⍞000D⍞000D    afho parse''''                    ⍝ Bunda-Gerth binding table.⍞000D    ┌─────┬─────┬─────┬───┐⍞000D    │A    │F    │H    │MOP│⍞000D┌───┼─────┼─────┼─────┼───┤⍞000D│A  │4 A  │2 AF │2 AF │3 F│⍞000D├───┼─────┼─────┼─────┼───┤⍞000D│F  │1 A  │     │3 F  │3 F│⍞000D├───┼─────┼─────┼─────┼───┤⍞000D│H  │     │     │     │3 F│⍞000D├───┼─────┼─────┼─────┼───┤⍞000D│AF │1 A  │     │     │   │⍞000D├───┼─────┼─────┼─────┼───┤⍞000D│DOP│3 MOP│3 MOP│3 MOP│   │⍞000D└───┴─────┴─────┴─────┴───┘⍞000D⍞000D    afho∘parse¨ ''+/¨0'' ''1/¨0''       ⍝ hybrids: defining example.⍞000D     A       A⍞000D   ┌─┴─┐   ┌─┴──┐⍞000D  ┌┴─┐ 0  ┌┴─┐  0⍞000D ┌┴┐ ¨    1 ┌┴┐⍞000D + /        / ¨⍞000D⍞000D    afho∘parse¨ ''a←0'' ''a+←1''        ⍝ regular vs. modified assignment.⍞000D   A       A⍞000D  ┌┴─┐   ┌─┴──┐⍞000D ┌┴┐ 0  ┌┴─┐  1⍞000D a ←    a ┌┴┐⍞000D          + ←⍞000D⍞000D    afho parse''2{⍺+⍵}3''             ⍝ Dfn⍞000D      A⍞000D  ┌───┴───┐⍞000D┌─┴─┐     3⍞000D2 ┌─┴─┐⍞000D  {  ┌┴─┐⍞000D    ┌┴┐ ⍵⍞000D    ⍺ +⍞000D⍞000D    1 afho parse''+.×/3/⍵''           ⍝ 1 defn ... => traced evaluation.⍞000D┌─┬───┬─┬─┬─┬─┬─┐⍞000D│F│DOT│F│H│A│H│A│⍞000D│+│.  │×│/│3│/│⍵│⍞000D└─┴───┴─┴─┴─┴─┴─┘⍞000D┌─┬───┬─┬─┬───┬─┐⍞000D│F│DOT│F│H│ MF│A│⍞000D│+│.  │×│/│┌┴┐│⍵│⍞000D│ │   │ │ │3 /│ │⍞000D└─┴───┴─┴─┴───┴─┘⍞000D┌─┬───┬─┬─┬─────┐⍞000D│F│DOT│F│H│  A  │⍞000D│+│.  │×│/│ ┌┴─┐│⍞000D│ │   │ │ │┌┴┐ ⍵│⍞000D│ │   │ │ │3 /  │⍞000D└─┴───┴─┴─┴─────┘⍞000D┌─┬────┬─┬─────┐⍞000D│F│ MOP│H│  A  │⍞000D│+│┌┴┐ │/│ ┌┴─┐│⍞000D│ │. × │ │┌┴┐ ⍵│⍞000D│ │    │ │3 /  │⍞000D└─┴────┴─┴─────┘⍞000D┌─────┬─┬─────┐⍞000D│ F   │H│  A  │⍞000D│┌┴─┐ │/│ ┌┴─┐│⍞000D│+ ┌┴┐│ │┌┴┐ ⍵│⍞000D│  . ×│ │3 /  │⍞000D└─────┴─┴─────┘⍞000D┌───────┬─────┐⍞000D│   F   │  A  │⍞000D│ ┌─┴──┐│ ┌┴─┐│⍞000D│┌┴─┐  /│┌┴┐ ⍵│⍞000D│+ ┌┴┐  │3 /  │⍞000D│  . ×  │     │⍞000D└───────┴─────┘⍞000D┌─────────────┐⍞000D│      A      │⍞000D│   ┌──┴───┐  │⍞000D│ ┌─┴──┐  ┌┴─┐│⍞000D│┌┴─┐  / ┌┴┐ ⍵│⍞000D│+ ┌┴┐   3 /  │⍞000D│  . ×        │⍞000D└─────────────┘⍞000D      A⍞000D   ┌──┴───┐⍞000D ┌─┴──┐  ┌┴─┐⍞000D┌┴─┐  / ┌┴┐ ⍵⍞000D+ ┌┴┐   3 /⍞000D  . ×⍞000D⍞000D    ⍝ For more examples, see ##.scripts.parse and ##.scripts.Binding⍞000D⍞000DSee also: dft unify tokens bf repl lisp kk⍞000D⍞000DIndex:parsing|expression|currying|Bunda-Gerth parser|binding strength|BIDMAS⍞000DIndex:Turing tape|tape⍞000DIndex;Bunda J.D.|Gerth J.A.' 
