'rslt ← (func ##.acc) argt               ⍝ Accumulating reduction.⍞000D⍞000DPhil Last''s  operator applies its function operand cumulatively between pairs of⍞000Ditems in its vector argument.⍞000D⍞000DTechnical note:⍞000D⍞000DFor  a  side-effect-free  associative operand function, this operator _could_ be⍞000Dcoded  in  terms  of primitive scan. However, this scan would be evaluated using⍞000D(0.5××/0 ¯1+⍴⍵) reductions, resulting in an O(n*2) algorithm.⍞000D⍞000D    acc←{⌽⍺⍺⍨\⌽⍵}           ⍝ slow O(n*2) coding.⍞000D⍞000DGianluigi Quario adds this nice surprise:⍞000D⍞000D(⍞000D    A few months ago I received some helpful suggestions about polynomial evalu-⍞000D    ation when the polynomial P(Y) is represented (in ascending order) by a vec-⍞000D    tor "poly".⍞000D⍞000D        P(Y) :  poly[0] + Y×poly[1]  + Y×poly[2] + ..... +Y×poly[N]⍞000D⍞000D    I was impressed by this idiom:⍞000D⍞000D        value ← point {⍺+⍺⍺×⍵}/poly⍞000D⍞000D    which  calculates  the value of a real polynomial "poly" at point "point" by⍞000D    means of Ruffini''s rule and Horner''s  {⍺+⍺⍺×⍵}/  algorithm.⍞000D⍞000D    I  think  that  this idiom has a greater semantic clarity than the primitive⍞000D    "base value":⍞000D⍞000D        value ← point ⊥ ⌽poly⍞000D⍞000D    which internally uses <but externally hides> Horner''s algorithm.⍞000D⍞000D    Over  and  above it can easily be extended to rectangular arrays by means of⍞000D    the following D-fn:⍞000D⍞000D        PolyEval ← {⊃⍵{⍺+⍺⍺×⍵}/⍺}⍞000D⍞000D    In fact we can play:⍞000D⍞000D        values ← poly PolyEval points⍞000D⍞000D    even when "points" is an array .⍞000D⍞000D    But I had another surprise when I matched the Horner''s algorithm with [acc].⍞000D⍞000D    If we write:⍞000D⍞000D        point {⍺+⍺⍺×⍵} acc poly⍞000D⍞000D    instead of⍞000D⍞000D        point {⍺+⍺⍺×⍵} / poly⍞000D⍞000D    we  obtain  not  only the value of the polynomial at point "point", i.e. the⍞000D    remainder  of  division of poly with monomial "Y-point" , but also the quot-⍞000D    ient polynomial according to Ruffini''s rule, which we studied at school.⍞000D⍞000D    If  P(Y)  is  a  polynomial  and  "Y - point" a monomial,  then substituting⍞000D    "{⍺+⍺⍺×⍵}/" with "{⍺+⍺⍺×⍵} acc" returns the quotient polynomial Q(Y) and the⍞000D    remainder polynomial  R(Y) of the polynomial division.⍞000D⍞000D    By  means  of the simple idiom {⍺+⍺⍺×⍵} and operator "acc" it is possible to⍞000D    implement  the Ruffini simple_division_rule between a polynomial and a mono-⍞000D    mial with neither iterations nor recursions.⍞000D⍞000D    The use of operator "acc" is performing something similar to:⍞000D⍞000D        ⎕←poly[0] + point×⎕←poly[1]  +point×⎕←poly[2] + ..... + point×⎕←poly[N]⍞000D⍞000D    Now  we  are  the  masters of a holistic window on Ruffini''s rule for simple⍞000D    division.⍞000D⍞000D        "** APL is an actual tool for supporting the chains of reasoning and⍞000D         creating knowledge **" - Gianluigi Quario.⍞000D)⍞000D⍞000DExamples:⍞000D⍞000D    {⍺,''f'',⍵}acc''abcd''⍞000D┌───────┬─────┬───┬─┐⍞000D│afbfcfd│bfcfd│cfd│d│⍞000D└───────┴─────┴───┴─┘⍞000D⍞000D    ,acc ⍳4⍞000D┌───────┬─────┬───┬─┐⍞000D│1 2 3 4│2 3 4│3 4│4│⍞000D└───────┴─────┴───┴─┘⍞000D⍞000D    slow←{⌽⍺⍺⍨\⌽⍵}          ⍝ O(n*2) coding.⍞000D⍞000D    disp ,slow ⍳4           ⍝ slow coding concurs for associative operand fn.⍞000D┌───────┬─────┬───┬─┐⍞000D│1 2 3 4│2 3 4│3 4│4│⍞000D└───────┴─────┴───┴─┘⍞000D⍞000D    ⍲acc 1 0 0              ⍝ ⍲ is non-associative (although it is commutative).⍞000D0 1 0⍞000D⍞000D    ⍲slow 1 0 0             ⍝ slow coding differs for non-associative operand.⍞000D1 1 0⍞000D⍞000DSee also: pred scan traj while foldl trav⍞000D⍞000DIndex:reduction⍞000DIndex;Last P.|Quario G.' 
