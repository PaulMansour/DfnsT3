'rslt ← {eval←1} ##.lisp expr                ⍝ Evaluator for a subset of Scheme.⍞000D⍞000DFrom Nick Nickolov, this function evaluates character vector  [expr],  which  is⍞000Dan expression written in a subset of the Scheme language.⍞000D⍞000DSpecial forms:⍞000D⍞000D    lambda  (alias \)⍞000D    quote⍞000D    cond    else⍞000D⍞000DA small set of primitive functions is provided. This can be easily extended:⍞000D⍞000D    +   sum⍞000D    -   difference⍞000D    *   product⍞000D    =   equal⍞000Dwrite   display using ⎕←⍞000D⍞000DIf optional left argument [eval] is set to 0, [lisp] returns the parse tree⍞000Dprior to evaluation.⍞000D⍞000DTechnical note:⍞000D⍞000DRoughly,  it follows the structure of the metacircular evaluator from SICP.⍞000DSee Gerald Jay Sussman''s lecture: https://www.youtube.com/watch?v=0m6hoOelZH8⍞000D⍞000DLisp structures are represented as follows:⍞000D⍞000D    Lisp   APL⍞000D    ----   ---⍞000D    123    123⍞000D    atom   ''atom''⍞000D    (x y)  (x y)⍞000D    ''x     (''quote'' x)⍞000D⍞000DProcedures are represented as 4-vectors of:⍞000D⍞000D    ''closure'' environment parameters body⍞000D⍞000DEnvironments are two-column matrices of names and values.⍞000D⍞000DExamples:⍞000D⍞000D    lisp ''(+ 1 2 3)''                    ⍝ expression evaluation⍞000D6⍞000D    lisp ''((lambda(m n)(+ m n))3 4)''    ⍝ lambda application⍞000D7⍞000D    0 lisp ''((\(m n)(+ m n))3 4)''       ⍝ parse tree (AST)⍞000D┌─────────────────┬─┬─┐⍞000D│┌─┬─────┬───────┐│3│4│⍞000D││\│┌─┬─┐│┌─┬─┬─┐││ │ │⍞000D││ ││m│n│││+│m│n│││ │ │⍞000D││ │└─┴─┘│└─┴─┴─┘││ │ │⍞000D│└─┴─────┴───────┘│ │ │⍞000D└─────────────────┴─┴─┘⍞000D⍞000D      lisp repl ''→''                     ⍝ mini session using →repl← operator.⍞000D⍞000D    (* 2 3 4)⍞000D24⍞000D    ((\(m n)(* m n))3 4)                ⍝ using "\" shorthand for "lambda"⍞000D12⍞000D    (quote (+ 1 2))                     ⍝ quoted list⍞000D+ 1 2⍞000D    ''(* 4 5)                            ⍝ using "''" shorthand⍞000D* 4 5⍞000D    →⍞000D                                        ⍝ Nick''s example:⍞000D    s ← '' ((lambda (cons car cdr)                            ''⍞000D    s,← ''          (car  (cons 123 456)))                    ''⍞000D    s,← ''                                                    ''⍞000D    s,← ''  (lambda (x y) (lambda (i) (cond (i x) (else y)))) ''⍞000D    s,← ''  (lambda (xy) (xy 0))                              ''⍞000D    s,← ''  (lambda (xy) (xy 1)))                             ''⍞000D⍞000D    lisp s⍞000D456⍞000D      ⍝ Applicative-order Y combinator:⍞000D⍞000D      Y←''(\(f)((\(x)(x x))(\(x)(f(\(y)((x x)y))))))''⍞000D⍞000D      fac←''(\(f)(\(n)(cond((= n 0)1)(else(* n(f(- n 1)))))))''   ⍝ factorial⍞000D⍞000D      lisp ''(('',Y,fac,'')4)''             ⍝ !4⍞000D24⍞000D      ⍝ Fibonacci:⍞000D      fib ← ''(\(f)(\(n)(cond((= n 0)0)((= n 1)1)(else(+(f(- n 1))(f(- n 2)))))))''⍞000D⍞000D      lisp ''(('',Y,fib,'')8)''⍞000D21⍞000D      ⍝ Ackermann:⍞000D      ack  ← ''(\(a)(\(m)(\(n)(cond((= m 0)(+ n 1))''⍞000D      ack ,← ''                    ((= n 0)((a(- m 1))1))''⍞000D      ack ,← ''                    (else((a(- m 1))((a m)(- n 1))))))))''⍞000D      lisp''((('',Y,ack,'')3)3)''⍞000D61⍞000D      rec←Y{''(('',⍺⍺,⍺,'')'',⍵,'')''}        ⍝ Y applicator⍞000D⍞000D      lisp¨ fib∘rec¨ ⎕D                 ⍝ fib¨ 0..9⍞000D0 1 1 2 3 5 8 13 21 34⍞000D⍞000D      pchk←{0 ¯1↓1 0⌽'' '',⍕↑⍵(+\1 ¯1 0[''()''⍳⍵])}⍞000D⍞000D      pchk Y                            ⍝ handy parenthesis depth checker⍞000D( \ ( f ) ( ( \ ( x ) ( x   x ) ) ( \ ( x ) ( f ( \ ( y ) ( ( x   x ) y ) ) ) ) ) )⍞000D 1 1 2 2 1 2 3 3 4 4 3 4 4 4 4 3 2 3 3 4 4 3 4 4 5 5 6 6 5 6 7 7 7 7 6 6 5 4 3 2 1⍞000D⍞000DSee also: repl parse bf baby joy⍞000DSee https://github.com/ngn/only-tools-and-sources/tree/master/lib/lisp⍞000D⍞000DIndex:Lisp|Scheme|closure|Metacircular|SICP|lambda|evaluator|fibonacci number⍞000DIndex:factorial|Y combinator|Ackermann''s function⍞000DIndex;Abelson H.|Sussman G.J.|Nickolov N.' 
