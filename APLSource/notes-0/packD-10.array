'cmp ← {cmp←1} ##.packD data                 ⍝ Pack char array to boolean vector.⍞000D⍞000DSupplied  by  Veli-Matti Jantunen, this packer uses the same algorithm as packQ,⍞000Dbut the result is a simple boolean vector.⍞000D⍞000DThe  algorithm  is  based  on replacing the unique values with boolean sequences⍞000Dthat start with ones and end with zeros:⍞000D⍞000D    the most common element is replaced with 1 0⍞000D    the next two with 1 0 0 and 1 1 0⍞000D    the following with 1 0 0 0, 1 1 0 0 and 1 1 1 0⍞000D    and so on.⍞000D⍞000DThe  packing  is efficient, if the data contains few unique elements and some of⍞000Dthem are used widely; normal text documents and APL code seem to pack nicely.⍞000D⍞000DBecause it is a boolean vector, we may decrypt the result in several ways:⍞000D⍞000D        encrypt     decrypt⍞000D        {~⍵}        {~⍵}⍞000D        {⌽⍵}        {⌽⍵}⍞000D        {⍺⌽⍵}       {(-⍺)⌽⍵}⍞000D        {⍵≠(⍴⍵)⍴⍺}  {⍵≠(⍴⍵)⍴⍺}⍞000D⍞000DFor example, the following operator uses some of the methods:⍞000D⍞000D    crypt←{⍞000D    ⍝| ⍺:   character set (64 elements!)⍞000D    ⍝| ⍺⍺:  0 = decrypt, 1 = crypt⍞000D    ⍝| ⍵⍵:  key (positive integer)⍞000D    ⍝| ⍵:   text⍞000D⍞000D         ⍺←⎕D,⎕A,''+-'',lcase ⎕A               ⍝ default character set.⍞000D         ⎕IO←0 ⋄ set←⍺                       ⍝ works nicer in zero origin.⍞000D         key←{((⌊2⍟⍵+1)⍴2)⊤⍵}⍵⍵              ⍝ binarise key.⍞000D⍞000D         cry←{                               ⍝ encryption:⍞000D             b←{(6×⌈(⍴⍵)÷6)↑⍵,6⍴1}packD ⍵    ⍝  pack, pad with 1''s if needed.⍞000D             c←b≠(⍴b)⍴key                    ⍝  poor man''s xor encryption.⍞000D             set[2⊥(6,(⍴c)÷6)⍴c]             ⍝ result is gibberish.⍞000D         }⍞000D⍞000D         yrc←{                               ⍝ decryption:⍞000D             c←,(6⍴2)⊤set⍳⍵                  ⍝  encode indices.⍞000D             0 packD{(-+/∧\⌽⍵)↓⍵}c≠(⍴c)⍴key  ⍝  de-xor, unpack (n.b. remove last 1''s)⍞000D         }⍞000D⍞000D         0::⍵ ⋄ ⍺⍺=1:cry ⍵ ⋄ yrc ⍵⍞000D     }⍞000D⍞000D- This idea may be developed further, e.g. adding characters that are not used.⍞000D⍞000D- Decryption with a wrong key may crash crypt (because the result shape may be⍞000D  anything, say 723572108153 0 1783823 0 0 0 0 0).⍞000D⍞000DExamples:⍞000D⍞000D    packD ''mississippi''⍞000D0 0 0 1 0 0 1 0 0 1 0 1 1 0 0 0 0 0 0 1 1 0 0 0 1 1 0 0 1 0 0 1 0 0 0 1 1 0 0 1⍞000D    0 0 0 0 0 0 0 0 1 1 1 0 1 1 0 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 1 0⍞000D    1 1 0 1 0⍞000D⍞000D    {⍵≡0 packD 1 packD ⍵}''Full Circle''⍞000D1⍞000D⍞000D    ⎕←crypted←(1 crypt 313)''mississippi''⍞000D5Na1n4ia1qmLJK⍞000D⍞000D    ''mississippi''≡(0 crypt 313)crypted⍞000D1⍞000D⍞000DSee also: Data_compression⍞000D⍞000DIndex:packing|compression|encryption⍞000DIndex;Jantunen V-M.' 
