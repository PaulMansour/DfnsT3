'tree ← {slant←1}(fn ##.dft) spread          ⍝ Display of function tree.⍞000D⍞000DOperator [dft] returns a character matrix representation of its function operand⍞000D[fn].⍞000D⍞000DRight argument [spread] determines the horizontal width of tree branches:⍞000D⍞000D      ''<''∘,∘(,∘''>'') dft¨ 1 3    ⍝ narrow and wide tree display.⍞000D    ∘           ∘⍞000D  ┌─┴─┐     ┌───┴───┐⍞000D  ∘   ∘     ∘       ∘⍞000D ┌┴┐ ┌┴┐  ┌─┴─┐   ┌─┴─┐⍞000D < , , >  <   ,   ,   >⍞000D⍞000DOptional left argument {slant←1} determines whether a  monadic  operator  should⍞000Dsuspend its left operand by a vertical (0) or slanted (1) line:⍞000D⍞000D    1 0 +¨¨¨.× dft¨ 3       ⍝ compare slanted vs vertical left operand.⍞000D         .      .⍞000D       ┌─┴─┐  ┌─┴─┐⍞000D       ¨   ×  ¨   ×⍞000D     ┌─┘      │⍞000D     ¨        ¨⍞000D   ┌─┘        │⍞000D   ¨          ¨⍞000D ┌─┘          │⍞000D +            +⍞000D⍞000D[dft] subsumes and replaces operator "ddft" and is extended to be function-train⍞000Dready:⍞000D⍞000D    (+/÷⍴) dft 1        ⍝ display of fork.⍞000D ┌─┼─┐⍞000D / ÷ ⍴⍞000D┌┘⍞000D+⍞000D    ulam dft 1          ⍝ display of longer train:⍞000D ┌───┼────────┐⍞000D┌┴┐  ∘     ┌──┼─────────────┐⍞000D2 ⍴ ┌┴─┐   ⍨  ↑ ┌───────────┼─────┐⍞000D    ⍴ ┌┴┐ ┌┘ ┌──┼─────┐     , ┌───┼──────┐⍞000D      ⍒ \ × ┌┴┐ + ┌───┼───┐   /   ∘   ┌──┼───┐⍞000D       ┌┘   2 |  ┌┴┐  ∘   ∘  ┌┴┐ ┌┴┐ ┌┴┐ ⍴ ┌─┼───┐⍞000D       +         1 + ┌┴┐ ┌┴┐ 2 ⍳ / ⊢ 2 ×   1 , ┌─┼──┐⍞000D                     × ⌊ ÷ 2                   - , ┌┴─┐⍞000D                                                   ¯1 ,⍞000DTechnical notes:⍞000D⍞000DFor large trees, much space can be saved in the output by  meshing  subtrees  to⍞000Doverlap vertically.⍞000D⍞000D    Without vertical overlap                With vertical overlap⍞000D    ------------------------                ---------------------⍞000D                 ∘                                      ∘⍞000D              ┌──┴──────────┐                       ┌───┴───┐⍞000D              ∘             ∘                       ∘       ∘⍞000D           ┌──┴─┐        ┌──┴─┐                   ┌─┴─┐   ┌─┴─┐⍞000D           ∘    +        ∘    +                   ∘   +   ∘   +⍞000D        ┌──┴─┐        ┌──┴─┐                    ┌─┴─┐   ┌─┴─┐⍞000D        ∘    +        ∘    +                    ∘   +   ∘   +⍞000D      ┌─┴─┐         ┌─┴─┐                     ┌─┴─┐   ┌─┴─┐⍞000D      ∘   +         ∘   +                     ∘   +   ∘   +⍞000D    ┌─┴─┐         ┌─┴─┐                     ┌─┴─┐   ┌─┴─┐⍞000D    +   +         +   +                     +   +   +   +⍞000D⍞000DThis is achieved by inner function "mesh" using steps:⍞000D⍞000D1. Extend the shallower subtree so that both have the same number of rows.⍞000D2. Determine the minimum horizontal gap between the subtrees.⍞000D3. Distribute the number of characters to be dropped between the subtrees.⍞000D4. Drop separating blanks; join corresponding rows; mix rows to a matrix.⍞000D⍞000DExamples:⍞000D⍞000D    deco← +.×⍨∘(÷∘⌽∘(+\)∘⌽⍨)⍨               ⍝ derived function. See →derive←⍞000D⍞000D    ⎕cr''deco''                               ⍝ nested canonical representation.⍞000D┌────────────────────────────────┬─┐⍞000D│┌───────┬─┬────────────────────┐│⍨│⍞000D││┌───┬─┐│∘│┌────────────────┬─┐││ │⍞000D│││+.×│⍨││ ││┌──────────┬─┬─┐│⍨│││ │⍞000D││└───┴─┘│ │││┌───┬─┬──┐│∘│⌽││ │││ │⍞000D││       │ ││││÷∘⌽│∘│+\││ │ ││ │││ │⍞000D││       │ │││└───┴─┴──┘│ │ ││ │││ │⍞000D││       │ ││└──────────┴─┴─┘│ │││ │⍞000D││       │ │└────────────────┴─┘││ │⍞000D│└───────┴─┴────────────────────┘│ │⍞000D└────────────────────────────────┴─┘⍞000D⍞000D    deco dft 3                                  ⍝ 3-spread tree.⍞000D          ⍨⍞000D        ┌─┘⍞000D        ∘⍞000D    ┌───┴───┐⍞000D    ⍨       ⍨⍞000D  ┌─┘     ┌─┘⍞000D  .       ∘⍞000D┌─┴─┐   ┌─┴─┐⍞000D+   ×   ∘   ⌽⍞000D    ┌───┴───┐⍞000D    ∘       \⍞000D  ┌─┴─┐   ┌─┘⍞000D  ÷   ⌽   +⍞000D⍞000D    +{⍺⍺ ⍵}{⍺⍺ ⍵} dft 3                         ⍝ non-primitive operator.⍞000D    {⍺⍺·⍵}⍞000D  ┌─┘⍞000D  {⍺⍺·⍵}⍞000D┌─┘⍞000D+⍞000D⍞000D    ∧¨¨¨¨¨¨{⍺⍺∘⍺⍺{⍺⍺∘⍺⍺{⍺⍺∘⍺⍺ dft ⍵}⍵}⍵}3       ⍝ scary sea monster.⍞000D                                 ∘⍞000D                     ┌───────────┴───────────┐⍞000D                     ∘                       ∘⍞000D               ┌─────┴─────┐           ┌─────┴─────┐⍞000D               ∘           ∘           ∘           ∘⍞000D            ┌──┴──┐     ┌──┴──┐     ┌──┴──┐     ┌──┴──┐⍞000D            ¨     ¨     ¨     ¨     ¨     ¨     ¨     ¨⍞000D          ┌─┘   ┌─┘   ┌─┘   ┌─┘   ┌─┘   ┌─┘   ┌─┘   ┌─┘⍞000D          ¨     ¨     ¨     ¨     ¨     ¨     ¨     ¨⍞000D        ┌─┘   ┌─┘   ┌─┘   ┌─┘   ┌─┘   ┌─┘   ┌─┘   ┌─┘⍞000D        ¨     ¨     ¨     ¨     ¨     ¨     ¨     ¨⍞000D      ┌─┘   ┌─┘   ┌─┘   ┌─┘   ┌─┘   ┌─┘   ┌─┘   ┌─┘⍞000D      ¨     ¨     ¨     ¨     ¨     ¨     ¨     ¨⍞000D    ┌─┘   ┌─┘   ┌─┘   ┌─┘   ┌─┘   ┌─┘   ┌─┘   ┌─┘⍞000D    ¨     ¨     ¨     ¨     ¨     ¨     ¨     ¨⍞000D  ┌─┘   ┌─┘   ┌─┘   ┌─┘   ┌─┘   ┌─┘   ┌─┘   ┌─┘⍞000D  ¨     ¨     ¨     ¨     ¨     ¨     ¨     ¨⍞000D┌─┘   ┌─┘   ┌─┘   ┌─┘   ┌─┘   ┌─┘   ┌─┘   ┌─┘⍞000D∧     ∧     ∧     ∧     ∧     ∧     ∧     ∧⍞000D⍞000D⍝ In the absence of a more general mechansism in Dyalog,  we need to augment our⍞000D⍝ operator set in order to be able to translate expressions of ⍺ and ⍵ into der-⍞000D⍝ ived functions.  Combinators [in] and [on],  together with primitive operators⍞000D⍝ compose ∘ and commute ⍨ allow us to build long function-operator trains:⍞000D⍝                                                                           <V>⍞000D    in←{⊃⍺⍺/⍵}              ⍝ in (between):         f in x y → x f y⍞000D    on←{⍺⍺ ⍺ ⍵}             ⍝ and its counterpart:  x f on y → f x y⍞000D⍞000D⍝ J language''s hook and fork constructs may be translated into such⍞000D⍝ trains using:  ┌──────────┬──────────────────┬─────────────────────┐⍞000D⍝                │ J Syntax │ Equivalent D     │ Equivalent Train    │⍞000D⍝  ┌─────────────┼──────────┼──────────────────┼─────────────────────┤⍞000D⍝  │Monadic Hook │ (g h)    │ {⍵ g h ⍵}        │ g∘h⍨                │⍞000D⍝  ├─────────────┼──────────┼──────────────────┼─────────────────────┤⍞000D⍝  │Dyadic  Hook │ (g h)    │ {⍺ g h ⍵}        │ g∘h                 │⍞000D⍝  ├─────────────┼──────────┼──────────────────┼─────────────────────┤⍞000D⍝  │Monadic Fork │ (f g h)  │ {(f ⍵)g h ⍵}     │ g∘h⍨∘f⍨             │⍞000D⍝  ├─────────────┼──────────┼──────────────────┼─────────────────────┤⍞000D⍝  │Dyadic  Fork │ (f g h)  │ {(⍺ f ⍵)g ⍺ h ⍵} │ g∘(h in)⍨∘(f in)⍨on │⍞000D⍝  └─────────────┴──────────┴──────────────────┴─────────────────────┘⍞000D⍞000D⍝ NB: Dyalog V14 introduces the fork as a primitive construct and so many of the⍞000D⍝ following examples may be simplified.                                     <V>⍞000D⍞000D⍝ For example:⍞000D⍞000D    avg ← ÷∘⍴⍨∘(+/)⍨                    ⍝ equivalent of monadic fork (+/ ÷ ⍴)⍞000D⍞000D    avg 1 2 3 4                         ⍝ test function.⍞000D1 2 3 4⍞000D⍞000D    avg dft 3                           ⍝ display of function tree.⍞000D         ⍨⍞000D       ┌─┘⍞000D       ∘⍞000D    ┌──┴──┐⍞000D    ⍨     /⍞000D  ┌─┘   ┌─┘⍞000D  ∘     +⍞000D┌─┴─┐⍞000D÷   ⍴⍞000D⍞000D    leq ← ∨∘(=in)⍨∘(<in)⍨on             ⍝ equivalent of dyadic fork (< ∨ =)⍞000D⍞000D    0 0 1 1 leq 0 1 0 1                 ⍝ test function.⍞000D1 1 0 1⍞000D⍞000D    leq dft 3                           ⍝ display of function tree.⍞000D           on←{⍺⍺·⍺·⍵}⍞000D         ┌─┘⍞000D         ⍨⍞000D       ┌─┘⍞000D       ∘⍞000D    ┌──┴──┐⍞000D    ⍨     in←{⊃⍺⍺/⍵}⍞000D  ┌─┘   ┌─┘⍞000D  ∘     <⍞000D┌─┴─┐⍞000D∨   in←{⊃⍺⍺/⍵}⍞000D  ┌─┘⍞000D  =⍞000D⍞000D⍝ Historical note: Mechanisms for distributing arguments through trees of⍞000D⍝ functions originated in the field of combinatorial logic in the 1920s⍞000D⍝ and 30s. See min.dws/Background for more on combinators.⍞000D⍞000D⍝ More examples of function-operator trains:⍞000D⍞000D    fib ← +/∘(!∘⌽⍨)∘(-∘⎕io)∘⍳           ⍝ ⍵th fibonacci number.⍞000D⍞000D    fib¨⍳10⍞000D1 1 2 3 5 8 13 21 34 55⍞000D⍞000D    fib dft 3⍞000D           ∘⍞000D         ┌─┴─┐⍞000D         ∘   ⍳⍞000D     ┌───┴────┐⍞000D     ∘        ∘⍞000D  ┌──┴──┐   ┌─┴─┐⍞000D  /     ⍨   -   1⍞000D┌─┘   ┌─┘⍞000D+     ∘⍞000D    ┌─┴─┐⍞000D    !   ⌽⍞000D⍞000D        dinv ← ↑⍨∘-⍨∘⊃⍨∘(+⍨∘⊃⍨∘(×∘⍴⍨∘×⍨in)⍨on⍨in)⍨on⍨   ⍝ inverse for ⍺∘↓.⍞000D⍞000D    2 3 dinv 3 2⍴⍳6⍞000D0 0 0 0 0⍞000D0 0 0 0 0⍞000D0 0 0 1 2⍞000D0 0 0 3 4⍞000D0 0 0 5 6⍞000D⍞000D    dinv dft 3                          ⍝ display of function tree.⍞000D                    ⍨⍞000D                  ┌─┘⍞000D                  on←{⍺⍺·⍺·⍵}⍞000D                ┌─┘⍞000D                ⍨⍞000D              ┌─┘⍞000D              ∘⍞000D          ┌───┴───┐⍞000D          ⍨       in←{⊃⍺⍺/⍵}⍞000D        ┌─┘     ┌─┘⍞000D        ∘       ⍨⍞000D      ┌─┴─┐   ┌─┘⍞000D      ⍨   ⊃   on←{⍺⍺·⍺·⍵}⍞000D    ┌─┘     ┌─┘⍞000D    ∘       ⍨⍞000D  ┌─┴─┐   ┌─┘⍞000D  ⍨   -   ∘⍞000D┌─┘   ┌───┴───┐⍞000D↑     ⍨       in←{⊃⍺⍺/⍵}⍞000D    ┌─┘     ┌─┘⍞000D    ∘       ⍨⍞000D  ┌─┴─┐   ┌─┘⍞000D  ⍨   ⊃   ∘⍞000D┌─┘     ┌─┴─┐⍞000D+       ⍨   ×⍞000D      ┌─┘⍞000D      ∘⍞000D    ┌─┴─┐⍞000D    ×   ⍴⍞000D⍞000D    rinv ← ⌈/¨∘(-∘⊂∘⍳∘(⊃∘⌽)∘⍴∘⊃⍨)∘(⍳¨in)∘(↓¨)on     ⍝ inverse for ⌽∘⍵.⍞000D⍞000D    ''Mississippi'' rinv ''issippiMiss''⍞000D4⍞000D    rinv dft 3                          ⍝ display of function tree.⍞000D                            on←{⍺⍺·⍺·⍵}⍞000D                          ┌─┘⍞000D                          ∘⍞000D                ┌─────────┴──────────┐⍞000D                ∘                    ¨⍞000D           ┌────┴─────┐            ┌─┘⍞000D           ∘          in←{⊃⍺⍺/⍵}   ↓⍞000D        ┌──┴──┐     ┌─┘⍞000D        ¨     ⍨     ¨⍞000D      ┌─┘   ┌─┘   ┌─┘⍞000D      /     ∘     ⍳⍞000D    ┌─┘   ┌─┴─┐⍞000D    ⌈     ∘   ⊃⍞000D        ┌─┴─┐⍞000D        ∘   ⍴⍞000D    ┌───┴───┐⍞000D    ∘       ∘⍞000D  ┌─┴─┐   ┌─┴─┐⍞000D  ∘   ⍳   ⊃   ⌽⍞000D┌─┴─┐⍞000D-   ⊂⍞000D⍞000D⍝ Functions for 1st and 2nd items of a pair, used in these examples, might also⍞000D⍝ be considered combinators.  In the examples above, they have been implemented⍞000D⍝ (assuming ⎕ml<2) as ⊃ and ⊃∘⌽, respectively. A more satisfying, though slower,⍞000D⍝ alternative might be:⍞000D⍞000D    fst ← ⊣in     ⍝ 1st item of pair.⍞000D    snd ← ⊢in     ⍝ 2nd item of pair.⍞000D⍞000DSee also: tfmt fork derive parse⍞000D⍞000DIndex:tree|derived function|combinator|hook|fork|box-drawing characters⍞000DIndex:fibonacci number|sea monster, scary|trains|function trains' 
