'cmat ← {space←⎕this} ##.find string         ⍝ Lines containing string(s) ⍵.⍞000D⍞000DFind returns a charater matrix,  one row for each occurrence of [string] in each⍞000Dvariable, function or operator in [space].  If the left argument is omitted, the⍞000Dcurrent space is assumed.⍞000D⍞000DIf [string] is a nested vector, those lines containing each of the substrings in⍞000Dorder  are  reported.  For example: (find ''<<'' ''>>'') would find lines containing⍞000Dsequences such as <<this>> but not those containing >>that<<.⍞000D⍞000DEach row of the result  starts with the full name of the object in which a match⍞000Dwas found followed by the "line" containing the match.⍞000D⍞000DNotice  that  [find]  can be used in conjunction with →refs← to search an entire⍞000Dnamespace tree.⍞000D⍞000DVariables  are searched row-wise, so line numbers on variables correspond to the⍞000Ddisplay of the variable given by: {⎕←⍵}saw var.⍞000D⍞000D(A previous version of this function  returned a 2-column nested matrix but this⍞000Dbecame inconvenient with ]boxing on).⍞000D⍞000DExamples:⍞000D⍞000D      find''⍴⍴''⍞000D #.ambiv[8]     2>⍴⍴cr:shy←''''                   ⍝ derived or primitive: quit.⍞000D #.disp[60]     0=opt×⍴⍴⍵:hz                ⍝ undecorated or scalar ⍕⍵: char,⍞000D #.disp[68]     0=opt×⍴⍴⍵:vt hz                 ⍝ scalar or no decoration.⍞000D #.disp[71]     rows←(¯1+3⌊⍴⍴⍵)⊃vt rsig''⍒''      ⍝ high rank decorator overrides.⍞000D #.display[17]  axes←{(-2⌈⍴⍴⍵)↑1+×⍴⍵}                   ⍝ Array axis types.⍞000D #.subs[2]      0=⍴⍴⍵:⊃(⍵≡fm)⌽⍵(⊂to)                ⍝ special case scalar argt.⍞000D #.subs[5]      1<⍴⍴⍵:↑(↓⍺)∇¨↓⍵                 ⍝ high rank: split.⍞000D⍞000D      ⎕se.NumEd find''⎕IO''⍞000D ⎕SE.NumEd.numed[0]    {name}numed msg;SPACE;NAME;OVAL;IO;⎕IO;⎕ML  ⍝ Numeric Editor⍞000D ⎕SE.NumEd.numed[5]    IO←SPACE⍎''⎕IO''⍞000D ⎕SE.NumEd.numed[6]    ⎕ML ⎕IO←0 1⍞000D ⎕SE.NumEd.SelIndx[2]  rslt←(fm-⎕IO)∘+¨⍳to-fm-1⍞000D⍞000D      ↑⍪/{⍵ find''⎕DQ''}¨refs ⎕se⍞000D ⎕SE.cbtop.TB_POPUP[7]  ⎕DQ''popup''⍞000D ⎕SE.tools.ftse[14]     ''S0''⎕WC pps ⋄ ⎕DQ''S0''⍞000D ⎕SE.NumEd.mbox[6]      ''Mbox''⎕WC prps ⋄ ⎕DQ''Mbox''⍞000D ⎕SE.NumEd.numed[10]    ⎕DQ''''⍞000D ⎕SE.NumEd.SaveAs[4]    ⎕DQ obid⍞000D⍞000D    6↑ notes find'' →'' ''← ''    ⍝ lines with '' →'' followed by ''← ''⍞000D #.notes.ambiv[8]      conjunction with →refs← to ambivalize all functions and operators in a namespace⍞000D #.notes.avl[9]        See →BST←⍞000D #.notes.avl[92]       follows the →fibonacci← sequence and for an AVL tree of height ⍵ is:⍞000D #.notes.avl[281]      [avl]  uses  the standard →BST← methods for search, insertion, and node removal.⍞000D #.notes.contents[10]  │ ··· related function →goo← is a ···⍞000D #.notes.date[6]       Optional  left argument {g} specifies the day number of the →Gregorian_calendar←⍞000D⍞000DTechnical notes:⍞000D⍞000DFind  avoids  name clashes by having an operand function _outside_ the main body⍞000Dof code, from whence it executes ⎕NC, ⎕NL, ⎕CR, etc.⍞000D⍞000D    ⍺{                                  ⍝ Avoid name clashes by executing⍞000D        2::(⎕NS'''')⍎⍵                    ⍝ ref ⍺⍺ too weird: ignore.⍞000D        ⍺⍺⍎⍵                            ⍝ expression in target space out-⍞000D    }{                                  ⍝ side main code body.⍞000D        exec←⍺⍺                         ⍝ External execute.⍞000D        ···⍞000D        exec''⎕NL 2 3 4''                 ⍝ Names of vars, fns and ops.⍞000D⍞000DThe line in [find]:⍞000D⍞000D        tag←(exec''⍕⍺⍺''){⍺⍺,''.'',⍵}       ⍝ Space-tagging function.⍞000D⍞000Ddefines  a  function by binding a left operand to an operator in the same way as⍞000Dsum←+/.  The operand expression is evaluated only once at definition time rather⍞000Dthan each time the resulting function is called. This can have clear performance⍞000Dbenefits for non-trivial expressions. In the above cases, binding the operand in⍞000Dthis  way avoids having to name it or pass it as an additional argument to where⍞000Dthe  function will be called. An alternative coding would be to "glue" the value⍞000Dto the left of the function using composition and reference it as ''⍺'':⍞000D⍞000D        tag←(exec''⍕⍺⍺'')∘{⍺,''.'',⍵}       ⍝ Space-tagging function.⍞000D⍞000DThere  is  little  to choose between these alternatives,  except that the former⍞000Ddefines an ambi-valent function allowing a future extension to pass a left argu-⍞000Dment, whereas the latter defines a strictly monadic function.⍞000D⍞000DThe  same  technique  is  employed with subfunction "match", where both left and⍞000Dright operands are bound.⍞000D⍞000DSee also: refs saw filefind rows⍞000D⍞000DIndex:name-clash problem|string search' 
