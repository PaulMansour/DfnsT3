'kmap ← {xk←(⊂,⊂∘kind)⎕nl-⍳10} ##.kk fnop    ⍝ Kind Koloring of d-fnop named ⍵.⍞000D⍞000DResult [kmap] is a vector of character vectors of the "kinds" of names  in  each⍞000Dline of the ⎕NR of right argument function or  operator  [fnop].  Optional  left⍞000Dargument [xk] is a dictionary of the kinds of external names.⍞000D⍞000DBackground⍞000D----------⍞000DWe  can''t  parse the following line of APL until we know whether the names refer⍞000Dto variables, functions or operators:⍞000D⍞000D    report ← lines print title pages⍞000D⍞000DFor example, "print" could be a dyadic function (F), which takes the array-pair⍞000D(title pages) as right argument and array (lines) as left:⍞000D⍞000D    report ← lines print title pages        ⍝ print is a function⍞000D                   FFFFF⍞000D⍞000Dor title could also be a (monadic) function:⍞000D⍞000D    report ← lines print title pages        ⍝ print and title are functions⍞000D                   FFFFF FFFFF⍞000D⍞000Dor title could be a monadic operator (M), which takes function print as left⍞000Doperand:⍞000D⍞000D    report ← lines print title pages        ⍝ title is a monadic operator⍞000D                   FFFFF MMMMM⍞000D⍞000Dor print could be a dyadic operator (D), taking title as right operand:⍞000D⍞000D    report ← lines print title pages        ⍝ print is a dyadic operator⍞000D             FFFFF DDDDD FFFFF⍞000D⍞000DIf we acknowledge that the expression to the right of the assignment arrow might⍞000Dresolve  to  a function _train_, making "report" a function, there are many more⍞000Dpossibilites, including:⍞000D⍞000D    report ← lines print title pages        ⍝ (lines print title) "atop" pages⍞000D    FFFFFF   FFFFF DDDDD       FFFFF⍞000D⍞000DIn general, an APL expression can be parsed if and only if its names can be⍞000Dclassified into one of four "kinds", depending on their referent values:⍞000D⍞000D  N: array or niladic function⍞000D  F: function⍞000D  M: monadic operator⍞000D  D: dyadic operator⍞000D⍞000DHere are some more examples using N and F to "kind-colour" names (and brackets):⍞000D⍞000D    mean←{ sum←+⌿⍵ ⋄ num←≢⍵ ⋄ ( sum÷num ) }     ⍝ (sum÷num) nilad⍞000D    FFFF·F·NNN·······NNN······N·NNN·NNN·N·F⍞000D⍞000D    mean←{ sum←+⌿⍵ ⋄ num←≢  ⋄ ( sum÷num )⍵}     ⍝ (sum÷num) Agh train⍞000D    FFFF·F·NNN·······FFF······F·NNN·FFF·F·F⍞000D⍞000D    mean←{ sum←+⌿  ⋄ num←≢  ⋄ ( sum÷num )⍵}     ⍝ (sum÷num) fgh train⍞000D    FFFF·F·FFF·······FFF······F·FFF·FFF·F·F⍞000D⍞000DIn addition to names,  [kk]  colours parentheses and curly braces to reflect the⍞000Dkinds of their contained expressions.⍞000D⍞000D(muse:⍞000D⍞000D    How many valid parsings are there of ⍵ consecutive distinct names?  We can⍞000D    try permutations of representatives (0 + ¨ ⍤) from each of the four kinds,⍞000D    trapping syntax errors for invalid sequences.  Here are the numbers for seq-⍞000D    uences of lengths from one to twelve, showing an approximately exponential⍞000D    increase. For a dozen adjacent distinct names there are over a million sep-⍞000D    arate interpretations:⍞000D⍞000D        ⎕ ← kinds ← {+/,{2::0 ⋄ _←⍎''0+¨⍤''[⍵] ⋄ 1}¨⍳⍵/4}¨ 1 to 12⍞000D    3 7 19 60 200 669 2258 7644 25974 88475 302052 1033072⍞000D⍞000D        ⌊ 0.5+ ⍟kinds               ⍝ exponential ←→ log approximately linear⍞000D    1 2 3 4 5 7 8 9 10 11 13 14⍞000D⍞000D    Here are all 19 valid sequences of length 3:⍞000D⍞000D        {~∘0,{2::0 ⋄ _←⍎''0+¨⍤''[⍵] ⋄ ''NFMD''[⍵] }¨⍳⍵/4} 3⍞000D    ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐⍞000D    │NNN│NNM│NFN│NFF│NMF│NMM│NDN│NDF│FNN│FNM│FFN│FFF│FFM│FMN│FMF│FMM│FDN│FDF│DNN│⍞000D    └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘⍞000D)⍞000D⍞000DA Colouring Experiment⍞000D----------------------⍞000DAs an experiment [kk] has been used to colour the webpages for the code of the⍞000Dfunctions and operators from this workspace.  Click the ##.kk link in the header⍞000Dline above to see the effect.  As suggested by Morten Kromberg in his blog post,⍞000Dthe pages use _italics_ to distinguish array from function and operator values.⍞000D⍞000DAttempting to use a BOLD font-style for operators widened the characters, caus-⍞000Ding misalignment of the comment symbols and rendering the overall effect rather⍞000Duntidy.  To avoid this, monadic and dyadic operator names have been coloured in⍞000Dmedium and lighter blue, respectively:⍞000D⍞000D       Font     Colour          Kind⍞000D       ----     ------          ----⍞000D    N: normal   black           niladic (array)⍞000D    F: italic   black           function⍞000D    M: italic   medium blue     monadic operator⍞000D    D: italic   lighter blue    dyadic operator⍞000D⍞000DFor example, in the code at http://dfns.dyalog.com/c_kk.htm, notice that:⍞000D⍞000D1. In the second line, because ⊂∘kind is a function, the parenthesised express-⍞000D   ion as a whole is a _fork_ and so the parentheses are italicised. The ital-⍞000D   ics should help when reading the line, by indicating that the parenthesised⍞000D   expression consumes, rather than provides a left argument for, the result of⍞000D   the ⎕NL:⍞000D⍞000D   [1]   ⍺←(⊂,⊂∘kind)⎕NL-⍳10                ⍝ (...) is a function⍞000D           F    FFFFF⍞000D⍞000D   (muse: This identification of function trains may alone be sufficient reason⍞000D          for adopting kind-colouring.)⍞000D⍞000D2. Within the definition of sub-function [body], notice that [dq] and [expr] are⍞000D   both identified as functions. The colouring helps with reading the ⊃ and / to⍞000D   their right as "first" and "reduction" respectively:⍞000D⍞000D   [19]  K∆←1⊃dq⊃expr/(⌽⍺),⊂E∆ K ⍬          ⍝ dq is a fn, so ⊃ is "first"⍞000D              FF FFFF⍞000D⍞000D⍞000DThe code for →rats← at http://dfns.dyalog.com/c_rats.htm provides examples of⍞000Dseveral more cases:⍞000D⍞000D1. [rats] itself is a (medium-blue-coloured) monadic operator.  With colouring,⍞000D   we can determine this immediately from the colours of the name and opening⍞000D   curly brace, without having to scan the body of the code for the presence of⍞000D   an ⍺⍺ (and the absence of an ⍵⍵, which would make it a _dyadic_ operator).⍞000D⍞000D   [0]  rats←{⎕ML ⎕IO←1                     ⍝ rats is a monadic operator⍞000D        MMMM M⍞000D⍞000D2. Inner [arith] is also easily identified as a monadic operator:⍞000D⍞000D    [2]     arith←{                         ⍝ arith is a monadic operator⍞000D            MMMMM M⍞000D⍞000D3. Inferring the kind of rats'' operand ⍺⍺ is currently beyond kk''s ability and⍞000D   so name "aa" in line[3] is coloured (red) for "unknown".⍞000D⍞000D   [3]  fn←⍺⍺{aa←⍺⍺ ⋄ ⊃⎕CR''aa''}⍵            ⍝ aa is coloured "unknown"⍞000D             M??              M⍞000D⍞000D4. [norm] and [sum] reference a function and monadic operator, respectively:⍞000D⍞000D   [4]      ''+''≡fn:norm ⍺+sum ⍵             ⍝ sum is a monadic operator⍞000D                   FFFF   MMM⍞000D⍞000D5. Towards the end of the code some functions are derived from dyadic operators:⍞000D⍞000D   [59] else←{⍺⍺ ⍵:⍵ ⋄ err ⍵⍵}              ⍝ else is a dyadic operator⍞000D        DDDD D               D                ¯¯¯¯⍞000D   [60] echk←{⍵≡⌊⍵}else''irrational''         ⍝ ... deriving function echk⍞000D        FFFF F    FDDDD                                             ¯¯¯¯⍞000D   [63] err←⎕SIGNAL∘11                      ⍝ err is a derived function⍞000D        FFF                                   ¯¯¯⍞000D   [65] imin←∩mesh⌊                         ⍝ dyadic op mesh derives fn imin⍞000D        FFFF  DDDD                                      ¯¯¯¯            ¯¯¯¯⍞000D   [67] gcd←imin over umax                  ⍝ dyadic op over derives fn gcd⍞000D        FFF FFFF DDDD FFFF                              ¯¯¯¯            ¯¯¯⍞000D⍞000DThe code for →joy← at http://dfns.dyalog.com/c_joy.htm shows the binding of ⍺ as⍞000Dleft operand of a multi-line monadic operator to form a derived function "prt":⍞000D⍞000D   [208]    prt←⍺{                          ⍝ ⍺{...⍺⍺...} derives fn prt⍞000D            FFF  M                             ¯        ¯            ¯¯¯⍞000DWithout the colouring of both prt and the left brace, this snippet would be hard⍞000Dto parse  without noticing that nothing follows the matching brace fifteen lines⍞000Dfurther down the code.⍞000D⍞000DKind-polymorphism⍞000D-----------------⍞000DDepending on context, some expressions can resolve to more than one kind.  Exam-⍞000Dples include the four "hybrid" tokens: / ⌿ \ ⍀,  which can each be of kind F  or⍞000DM, depending  on what is to their left, and operand tokens, ⍺⍺ and ⍵⍵, which can⍞000Deach be either N or F. In isolation, the colours for names "slash" and "left" in⍞000Dslash←/ and left←⍺⍺ cannot be  determined.⍞000D⍞000DThis is not a shortcoming of the kind-inference process: given this property  of⍞000Dthe Dyalog language, drawing attention to such ambiguities with distinct colours⍞000Dcan be considered a virtue.⍞000D⍞000DFor example, the name "left" in this operator:⍞000D⍞000D    twice ← {left←⍺⍺ ⋄ left left ⍵}⍞000D⍞000Dhas kind F if the operator is called with a function operand,  and N if an array⍞000Doperand is used. In this case [kk] correctly infers a composite kind: N∨F.⍞000D⍞000D[kk] employs a total of 11 colours: N, F, M, D, f, r, h, o, ·, Z and ?:⍞000D⍞000D                        ┌────────── Example of referent value⍞000D                        │⍞000DN: niladic              ⍬           (name assigned to ⍬ is coloured N)⍞000DF: function             +           (name assigned to + is coloured F)⍞000DM: monadic operator     ⌸            etc⍞000DD: dyadic operator      ⍤⍞000D⍞000Dr: N∨F                  ⍺⍺ ⍵⍵       ("r" stands for opeRand)⍞000Dh: · F∨M                / ⌿ \ ⍀     ("h" stands for Hybrid)⍞000Do: · · M∨D              ∇∇          ("o" stands for Operator)⍞000D⍞000Df: monadic function     1+          (temporary kind used internally)⍞000D?: unresolved                       (kind could not be determined)⍞000D·: not coloured         ⍝...        (for tokens other than names and brackets)⍞000DZ: internal error                   (indicates a fault in the parse table)⍞000D⍞000DIn the web pages for the code at dfns.dyalog.com, colour _red_ is used for kinds⍞000Dother than the primary N, F, M and D.  See: http://dfns.dyalog.com/c_ratsum.htm,⍞000Dwhich contains several such expressions.⍞000D⍞000DKind-forcing⍞000D------------⍞000DWhen coding APL, it is often possible to "force" the kind of a polymorphic expr-⍞000Dession.  For example, it may be intended that the [twice] operator  be used only⍞000Dto apply its operand _function_ twice to an argument array.⍞000D⍞000D    twice ← {left←⍺⍺ ⋄ left left ⍵}⍞000D⍞000D    ⊂twice ''this''           ⍝ enclosed twice⍞000D┌──────┐⍞000D│┌────┐│⍞000D││this││⍞000D│└────┘│⍞000D└──────┘⍞000D⍞000DHowever, as coded, the operator is equally happy with an _array_ operand:⍞000D⍞000D    ''<''twice ''this''         ⍝ prefixed twice⍞000D┌─┬─┬────┐⍞000D│<│<│this│⍞000D└─┴─┴────┘⍞000D⍞000DTo force kind F for name "left", we could code:⍞000D⍞000D    twice←{left←⍺⍺∘⊢ ⋄ left left ⍵}⍞000D                ¯¯¯¯⍞000D    ⊂twice ''this''           ⍝ function operand: enclosed twice⍞000D┌──────┐⍞000D│┌────┐│⍞000D││this││⍞000D│└────┘│⍞000D└──────┘⍞000D⍞000D    ''<''twice ''this''         ⍝ array operand is a no-op.⍞000Dthis⍞000D⍞000DIn similar fashion, adding ⊣0 to the end of line[131] of →ratsum← to become:⍞000D⍞000D    [131]  digs←↑↓/(1 ¯1×''{}''≡ext ⍺⍺),⊂⍺⍺⊣0    ⍝ digits without surrounding {}s.⍞000D                                         ¯¯⍞000D... removes much of the red colouring from: http://dfns.dyalog.com/c_ratsum.htm.⍞000D⍞000DFinally, note that (1+⍺⍺) has a compound kind of N∨F, whereas the kind of (⍺⍺+1)⍞000Dis simply N. If ⍺⍺ always references an array, the latter coding should reduce⍞000Dthe burden on the human reader.⍞000D⍞000DTechnical notes:⍞000D⍞000D0. kk''s optional left argument ⍺ defaults to a dictionary of the →kind← of each⍞000D   name in the current namespace. A dictionary is a pair of vectors (names⍞000D   values) from which function [val], given a name, can obtain its value.⍞000D⍞000D1. Function →tokens← is used to create a vector of token vectors from the lines⍞000D   of the ⎕NR of the subject function.⍞000D⍞000D2. The tokens vectors for each line are joined with a synthetic newline token⍞000D   (,''┘'') to produce a single vector [toks] of tokens. With respect to parsing,⍞000D   newlines are the same as diamonds.⍞000D⍞000D3. Function [lint] removes tokens (comments and white space), not needed in the⍞000D   parsing, and returns a vector of indices into [toks] of the remaning ones.⍞000D   The orginal tokens can be retrieved from this vector with function [tx] and⍞000D   in the following descriptions the word "token" will often be used inter-⍞000D   changeably with "token index". In addition, surplus newlines and diamonds are⍞000D   removed, as are tokens for outer-product (∘.) so that all remaining ∘s can be⍞000D   treated as the commute operator. This works because kind(∘.f) ←→ kind(f).⍞000D   There are several similar transformations:⍞000D⍞000D        kind(x.y)  ←→ kind(y)⍞000D        kind(x[y]) ←→ kind(x)⍞000D        kind(x←y)  ←→ kind(y)⍞000D⍞000D4. The kind-inference process uses four mutually-recursive functions: [fnop],⍞000D   [body], [expr] and [tokn], together with a de-queueing function [dq] Here⍞000D   are their types:⍞000D⍞000D    fnop :: S E K Q ← Tinx ∇ S E K Q⍞000D    body ::   E K   ← Body ∇   E K⍞000D    expr ::   E K Q ← Expr ∇   E K Q⍞000D    tokn :: S E K Q ← Tinx ∇ S E K Q⍞000D      dq ::     K   ←      ∇   E K Q⍞000D⍞000D   where:⍞000D       S := [Kind]                  ⍝ Stack: vector of kinds⍞000D       E := [Tinx][Kind]            ⍝ Environment: maps tokens to kinds⍞000D       K := [Tinx Kind]             ⍝ Colour map: vector of token/kind pairs⍞000D       Q := [Body]                  ⍝ Queue of deferred fnop bodies⍞000D    Kind := N F M D _F NF H MD U Z  ⍝ Kind⍞000D    Body := [Expr]                  ⍝ Vector of ⋄:┘-separated exprs⍞000D    Expr := [Tinx]                  ⍝ Expression: vector of token indices⍞000D    Tinx := Indx | [Tinx]           ⍝ Index or indices into toks vector⍞000D⍞000D    [fnop] takes a nested triple: ''{'' body ''}''; logs the colours of the { and }⍞000D    braces by looking for the presence of ⍺⍺ or ⍵⍵ in the fnop body; and splits⍞000D    tokens into ⋄-, :- and ┘-separated expressions; with which it calls function⍞000D    [body].⍞000D⍞000D    [body] processes the vector of expressions, which constitute the fnop body,⍞000D    with a left-to-right [expr]-reduction, accumulating E K and Q vectors.⍞000D⍞000D    [expr] takes a vector of tokens, representing an expression, together with:⍞000D    an environment (E); current colour map (K); and body queue (Q), and returns⍞000D    new values for E, K and Q. The expression is processed with a right-to-left⍞000D    [tokn]-reduction.⍞000D⍞000D    [tokn] takes a token to its left and the tuple (S E K Q) as right argument.⍞000D    E, K, and Q are as above and S is a stack of the kinds of tokens already⍞000D    visited. For a complete and correct expression, the stack S can be resolved⍞000D    into a single kind by function [parse]⍞000D⍞000D5. The Queue Q⍞000D⍞000D    The parsing process distinguishes fnop _definitions_ from _applications_.⍞000D    Applications are processed immediately on encounter but definitions are⍞000D    deferred until the end of the current body. The following code illustrates⍞000D    why this is necessary, when colouring instances of name "sum" within the two⍞000D    inner functions:⍞000D⍞000D        {⍞000D            sum←+/          ⍝ sum:F    "sum is of kind F"⍞000D            def←{sum ⍵}     ⍝ def:F     sum:N (from below)⍞000D            app←{sum ⍵}⍵    ⍝ app:N     sum:F (from above)⍞000D            sum←+/⍵         ⍝ sum:N⍞000D            def 0           ⍝ def:F⍞000D        }⍞000D⍞000D    After  processing all expressions in a fnop body, function [dq] is called to⍞000D    flush the queue.⍞000D⍞000DAuxiliary functions:⍞000D⍞000D    toks                        ⍝ token vector with white-space and ┘-newlines⍞000D┌───┬─┬─┬─┬────┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬────┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐⍞000D│foo│←│{│┘│    │a│←│(│b│+│c│)│+│(│(│d│+│e│)│×│f│)│┘│    │a│[│g│]│∘│.│{│⍺│ │⍵│}│⍵│┘│}│⍞000D└───┴─┴─┴─┴────┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴────┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘⍞000D⍞000DFunction [lint] discards surplus tokens and returns a vector of the indices of⍞000Dthe remaining ones.⍞000D⍞000D    lint toks                   ⍝ indices of de-fluffed tokens vector⍞000D0 1 2 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 24 25 26 27 30 31 33 34 35 37⍞000D⍞000D[tx] reconstitutes tokens from their indices:⍞000D⍞000D    tx lint toks                ⍝ reconstituted by [tx] function⍞000D┌───┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐⍞000D│foo│←│{│a│←│(│b│+│c│)│+│(│(│d│+│e│)│×│f│)│┘│a│[│g│]│{│⍺│⍵│}│⍵│}│⍞000D└───┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘⍞000D⍞000D[nest] encloses each occurrence of top-level of brackets into a triple.⍞000D⍞000D    tx ''{}''nest lint toks       ⍝ nested at {} tokens⍞000D┌───┬─┬─────────────────────────────────────────────────────────────┐⍞000D│foo│←│┌─┬───────────────────────────────────────────────────────┬─┐│⍞000D│   │ ││{│┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐│}││⍞000D│   │ ││ ││a│←│(│b│+│c│)│+│(│(│d│+│e│)│×│f│)│┘│a│[│g│]│{│⍺│⍵│}│⍵││ ││⍞000D│   │ ││ │└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘│ ││⍞000D│   │ │└─┴───────────────────────────────────────────────────────┴─┘│⍞000D└───┴─┴─────────────────────────────────────────────────────────────┘⍞000D⍞000D    body ← 2 1⊃''{}''nest lint toks   ⍝ function body⍞000D    tx body⍞000D┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐⍞000D│a│←│(│b│+│c│)│+│(│(│d│+│e│)│×│f│)│┘│a│[│g│]│{│⍺│⍵│}│⍵│⍞000D└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘⍞000D⍞000D    tx ''()[]''nest body              ⍝ top-level () and [] nesting⍞000D┌─┬─┬─────────────┬─┬─────────────────────┬─┬─┬─────────┬─┬─┬─┬─┬─┐⍞000D│a│←│┌─┬───────┬─┐│+│┌─┬───────────────┬─┐│┘│a│┌─┬───┬─┐│{│⍺│⍵│}│⍵│⍞000D│ │ ││(│┌─┬─┬─┐│)││ ││(│┌─┬─┬─┬─┬─┬─┬─┐│)││ │ ││[│┌─┐│]││ │ │ │ │ │⍞000D│ │ ││ ││b│+│c││ ││ ││ ││(│d│+│e│)│×│f││ ││ │ ││ ││g││ ││ │ │ │ │ │⍞000D│ │ ││ │└─┴─┴─┘│ ││ ││ │└─┴─┴─┴─┴─┴─┴─┘│ ││ │ ││ │└─┘│ ││ │ │ │ │ │⍞000D│ │ │└─┴───────┴─┘│ │└─┴───────────────┴─┘│ │ │└─┴───┴─┘│ │ │ │ │ │⍞000D└─┴─┴─────────────┴─┴─────────────────────┴─┴─┴─────────┴─┴─┴─┴─┴─┘⍞000D⍞000DBugs:⍞000D⍞000D1. [kk] confuses names in "dotted expressions":⍞000D⍞000D    nil←0 ⋄ ⎕se.nil←⊢ ⋄ nil         ⍝ rightmost "nil" should be NNN⍞000D    NNN         FFF     FFF⍞000D⍞000D2. It is possible to confound the kind inferencing by re-using the same name for⍞000D   different kinds within a particular fnop body.  Look  at  name  "what" in the⍞000D   following code:⍞000D⍞000D    {⍞000D        what←0          ⍝ what:N⍞000D        fun←{what ⍵}    ⍝ what:?⍞000D        0⊣fun 0:        ⍝ first call on fun what:N⍞000D        what←⊢          ⍝ what:F⍞000D        fun 0           ⍝ second call on fun: what:F⍞000D    }⍞000D⍞000D   In this example, name "what", within function "fun", will be coloured F by⍞000D   the de-queueing process. Ideally it should be coloured N∨F(r) but this would⍞000D   require a significantly more complex treatment.  Of course, refraining from⍞000D   changing the kind of a name, which is (arguably) good practice, should avoid⍞000D   this problem.⍞000D⍞000D3. Primitive function execute (⍎) can return an array, function or monadic oper-⍞000D   ator: kind(⍎⍵) → N∨F∨M. [kk] ignores this fact and infers N.⍞000D⍞000D        what←⍎''+''           ⍝ "what" wrongly coloured as N⍞000D        NNNN⍞000D⍞000D   This could be improved slightly by adding some execute-specific binding rules⍞000D   but it hardly seems worth the increase in complexity. To force the colouring⍞000D   of an execute expression that is known to return a function, we could code:⍞000D⍞000D        what←(⍎''+'')∘⊢⍞000D        FFFF N    N⍞000D⍞000D   ... although the parentheses remain as N.⍞000D⍞000DPossible improvements:⍞000D⍞000D1. Some kinds can be inferred from their context. For example, for correct code:⍞000D⍞000D    The kind of a guard or error-guard must be N:⍞000D⍞000D        (0<⍺⍺):⍵⍞000D        N    N⍞000D⍞000D    Some primitive operators are known to accept only kind F operands:⍞000D⍞000D        (0<⍺⍺)¨⍵⍞000D        F    F⍞000D⍞000D    Some primitive functions are strictly dyadic so an expression to its left⍞000D    must be of kind N:⍞000D⍞000D        (0<⍺⍺)∧⍵⍞000D        N    N⍞000D⍞000D    Only kind N may be returned as the result of a function or operator:⍞000D⍞000D        (0<⍺⍺)⍞000D        N    N⍞000D⍞000D    An assignment of _multiple_ names must be of kind N:⍞000D⍞000D        this that ← (0<⍺⍺)⍞000D        NNNN NNNN   N    N⍞000D⍞000D    ... and so on.⍞000D⍞000D2. A Mk-II version of [kk] might choose to deal in only the four primary kinds:⍞000D   N F M D.⍞000D⍞000D   The inference process would create a parse-tree for the whole capsule (fnop)⍞000D   with ambiguous nodes represented as _vectors_ of multiple interpretations: a⍞000D   tree-of-trees. Items of stack S would, in general be vectors of kinds:⍞000D⍞000D        S := [[K]]                              ⍝ Stack: vector vectors of kinds⍞000D⍞000D   and [parse] would be applied to the outer-product-join reduction of the stack.⍞000D   A unification process (see →unify←) would filter consistent combinations from⍞000D   the tree-of-trees:⍞000D⍞000D        S∆ E∆ ← E unify filter parse¨ ,⊃∘.,/ S  ⍝ all consistent interpretations⍞000D                                      ¯¯¯¯¯¯⍞000D   ... leaving some, though in practice probably few, multi-coloured names:⍞000D⍞000D      {⍵/''NFMD''}¨1↓,⎕io≠⍳4/2                    ⍝ all possible kind colours⍞000D    ┌─┬─┬──┬─┬──┬──┬───┬─┬──┬──┬───┬──┬───┬───┬────┐⍞000D    │D│M│MD│F│FD│FM│FMD│N│ND│NM│NMD│NF│NFD│NFM│NFMD│⍞000D    └─┴─┴──┴─┴──┴──┴───┴─┴──┴──┴───┴──┴───┴───┴────┘⍞000D⍞000D   In particular it could:⍞000D⍞000D   1. Automatically make use of the kinds of operands passed to inner operators.⍞000D      For example, if local operator "twice" is only ever called with a function⍞000D      operand, then expressions that include ⍺⍺ within its body can be treated⍞000D      accordingly:⍞000D⍞000D        {⍞000D            twice←{left←⍺⍺ ⋄ left left ⍵}   ⍝ left is FFFF because:⍞000D            this←⊂twice ⍺                   ⍝   twice is only ever called⍞000D            that←+/twice ⍵                  ⍝       with a _function_ as operand⍞000D            ...⍞000D        }⍞000D⍞000D      Given this technology, it might be appropriate to colour the ⍺⍺, ⍵⍵ and ∇∇⍞000D      tokens themselves.⍞000D⍞000D   2. Accumulate inference information between lines. For example, in the first⍞000D      line below, "nums" might reference either an array or a function (train).⍞000D      However, assuming the second line to be correct code, the expression to⍞000D      the left of the guard (which in isolation could also evaluate to a train)⍞000D      must reduce to 0 or 1, implying nums to be a nilad: NNNN.⍞000D⍞000D        nums←1↓⍺⍺               ⍝ nums could be NNNN or FFFF⍞000D        0∊nums:''error''          ⍝ nums must be NNNN⍞000D⍞000D3. In addition to resolving ambiguities, _conflicting_ kind determinations could⍞000D   be flagged as errors in the code.⍞000D⍞000DRequires: →tokens← →kind←⍞000D⍞000DExamples:⍞000D⍞000D    mean←{⍞000D        sum←+⌿⍵⍞000D        num←≢⍞000D        (sum÷num)⍵⍞000D    }⍞000D⍞000D      (⎕nr ,[0.5] kk)''mean''         ⍝ source lines and colours⍞000D┌──────┬───────────┬─────────┬──────────────┬─┐⍞000D│mean←{│    sum←+⌿⍵│    num←≢│    (sum÷num)⍵│}│⍞000D├──────┼───────────┼─────────┼──────────────┼─┤⍞000D│FFFF·F│····NNN····│····FFF··│····FNNN·FFFF·│F│⍞000D└──────┴───────────┴─────────┴──────────────┴─┘⍞000D⍞000D    ⍝ The following function interleaves the lines of its argument function⍞000D    ⍝ with their kind colours:⍞000D⍞000D    crkk←{↑↑,/(⎕NR ⍵){⍺ ⍵}¨kk ⍵}    ⍝ ⎕cr interleaved with line colouring⍞000D⍞000D    crkk''mean''                      ⍝ colours per line of function "mean"⍞000Dmean←{⍞000DFFFF·F⍞000D    sum←+⌿⍵⍞000D····NNN····⍞000D    num←≢⍞000D····FFF··⍞000D    (sum÷num)⍵⍞000D····FNNN·FFFF·⍞000D}⍞000DF⍞000D⍞000D    crkk''crkk''                      ⍝ (selfie)⍞000Dcrkk←{↑↑,/(⎕NR ⍵){⍺ ⍵}¨kk ⍵}⍞000DFFFF·F····N·····NF···F·FF··F⍞000D⍞000DSee also: parse tokens kind alists to⍞000D⍞000DIndex:name colouring|parsing|kind|Bunda-Gerth parser|polymorphism|selfie⍞000DIndex;Bunda J.D.|Gerth J.A.|Kromberg M.J.' 
