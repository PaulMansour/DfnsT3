'rats ← {tolerance←⎕ct} ##.rational nums     ⍝ Rational approximation to real ⍵.⍞000D⍞000DArgument [nums] is a numeric,  possibly nested, array of shape S.  The result is⍞000Dan array of shape: (2,S) with pairs of whole numbers, along the first axis, with⍞000Da quotient which is  ⍺-tolerably  close  to  the  corresponding  argument  item.⍞000D[rational] guarantees to return the smallest pair of such numbers.  For example,⍞000Dif we choose pi (an irrational number) as argument, then with the default ⎕CT of⍞000D1e¯14, we see:⍞000D⍞000D        rational ○1             ⍝ tolerable rational approximation to pi⍞000D    5419351 1725033⍞000D⍞000D        (○1) = ÷/ rational ○1   ⍝ quotient of pair is ⎕CT-equal to argument.⍞000D    1⍞000D        ⎕ct←1e¯10               ⍝ coarser tolerance.⍞000D⍞000D        rational ○1             ⍝ coarser tolerance yields smaller pair.⍞000D    208341 66317⍞000D⍞000D        ⊢ numbs ← +/¨1⊂ 2 2 2⍴ +\10*-⍳8         ⍝ nested numeric array.⍞000D    ┌─────────────────┬───────────────────┐⍞000D    │0.1     0.111    │0.11     0.1111    │⍞000D    │0.11111 0.1111111│0.111111 0.11111111│⍞000D    └─────────────────┴───────────────────┘⍞000D⍞000D        disp rational numbs                     ⍝ rational pairs.⍞000D    ┌───────────────┬─────────────────┐⍞000D    │    1     111  │    11     1111  │⍞000D    │11111 1111111  │111111 11111111  │⍞000D    ├───────────────┼─────────────────┤⍞000D    │    10     1000│    100     10000│⍞000D    │100000 10000000│1000000 100000000│⍞000D    └───────────────┴─────────────────┘⍞000D⍞000D        numbs ≡ ÷⌿ rational numbs               ⍝ round-trip⍞000D    1⍞000D⍞000DThe  integer  pair  could  be reconstituted directly from the continued fraction⍞000Dreturned  by  function →cfract←. The inner reduction in the coding that follows,⍞000Drepresents the expression transformation:⍞000D⍞000D  ···+1     ···+1        ···+1        ···+1         ┐ ···+ ┌ yz+1⍞000D      ─         ─            ─            ─         │      │ ─────────  => ···⍞000D      x+1       x+1    ┐   ┌ x+z    ┐   ┌ x(yz+1)+z ├───→──┤ x(yz+1)+z⍞000D        ─         ─    ├─→─┤   ──── ├─→─┤ ───────── │      └⍞000D      ┌ y+1 ┐   ┌ yz+1 │   └   yz+1 ┘   └   yz+1    ┘⍞000D      │   ─ ├─→─┤ ──── │⍞000D      └   z ┘   └   z  ┘⍞000D⍞000D⍞000D    rational←{              ⍝ Rational approximation from continued fraction.⍞000D        ⌽↑{                 ⍝ reversed accumulation of,⍞000D            top bot←⍵       ⍝ tailmost,⍞000D            ⌽top 0+⍺ 1×bot  ⍝ fractions.⍞000D        }/(cfract ⍵),1      ⍝ continued fraction representation.⍞000D    }⍞000D⍞000Dor the equivalent one-liner:⍞000D⍞000D    rational←{⌽↑{↑⍺{⌽⍺ 0+⍺⍺ 1×⍵}/⍵}/(cfract ⍵),⊂1 1}⍞000D⍞000DFor  amusement, [rational]  could be recast as a derived function, although it''s⍞000Dhard to see a practical benefit of doing so:⍞000D⍞000D    rational ← ↑∘(÷∘⊂∘(1∘∨)⍨∘(1∘(,⍨∘⊂))⍨)       ⍝ derived fn (⎕ml=0)⍞000D⍞000DHistorical note⍞000D---------------⍞000DPrior to the implementation of primitive function GCD (∨) this more complex cod-⍞000Ding, which was slower by a factor of around 2, was used:⍞000D⍞000D    rational←{                  ⍝ Rational number near real ⍵.⍞000D        ⍺←⎕CT ⋄ ⎕CT←⍺           ⍝ default comparison tolerance.⍞000D        real←⍵                  ⍝ "real" number.⍞000D        real{                   ⍝ starting with real number.⍞000D            An←⌊⍺               ⍝ nth term of continued fraction.⍞000D            Cn←1 An+.×⍵         ⍝ nth convergent pair.⍞000D            real=÷/Cn:Cn        ⍝ tolerably close rational: done.⍞000D            (÷⍺-An)∇ 1 0↓⍵⍪Cn   ⍝ otherwise: next term.⍞000D        }2 2⍴0 1 1 0            ⍝ convergents: C¯2, C¯1.⍞000D    }⍞000D⍞000DA Perfectly Accurate (⎕ct-intolerant) Version⍞000D---------------------------------------------⍞000DIf we ignore comparison tolerance, all IEEE floating point numbers are rational,⍞000Dwith a denominator of a power of 2 (yeah?).⍞000D⍞000DUsing →hexf←, this version decodes the bits from the internal IEEE double float-⍞000Ding-point representation and uses →nats← to provide a perfectly (⎕CT=0) accurate⍞000Drational  pair.  The  two-item  result is a pair of character vectors of decimal⍞000Ddigits.⍞000D⍞000D    ratf←{⎕IO ⎕ML ⎕CT←0                 ⍝ Exact rational from IEEE double.⍞000D        digs←16↑⎕D,⎕A                   ⍝ hex digits.⍞000D        bits←,⍉2 2 2 2⊤digs⍳hexf ⍵      ⍝ binary floating number.⍞000D        split←(⍳⍴bits)∊0 1 12           ⍝ split fields: sign exponent mantissa.⍞000D        bsign bexp bmant←split⊂bits     ⍝ bit-vector fields.⍞000D        sign←bsign/''¯''                  ⍝ negative sign.⍞000D        exp←¯1022+2⊥bexp                ⍝ signed numeric binary exponent.⍞000D        deco←{↑⍺{⍺+nats ⍺⍺×nats ⍵}/⌽⍵}  ⍝ accurate ⍺-decode.⍞000D        top←2 deco 1,bmant              ⍝ numerator.⍞000D        bot←2*nats 53-exp               ⍝ denominator.⍞000D        sign '''',¨top{                   ⍝ rational pair, char vectors à la nats.⍞000D            1∊''13579''∊,↑¯1↑¨⍺ ⍵:⍺ ⍵     ⍝ either number is odd: done.⍞000D            (⍺÷nats 2)∇ ⍵÷nats 2        ⍝ both even: cancel 2s.⍞000D        }bot⍞000D    }⍞000D⍞000DNotice that some friendly decimal numbers such as 0.1 are not representable with⍞000Dperfect  accuracy in binary.  This means that the closest number to 0.1 that may⍞000Dbe represented in 53 bits, is the rational number:⍞000D⍞000D    3602879701896397 ÷ 36028797018963968⍞000D0.1⍞000D⍞000D    ratf 1234                           ⍝ whole number.⍞000D┌────┬─┐⍞000D│1234│1│⍞000D└────┴─┘⍞000D⍞000D    ratf 0.1                            ⍝ ÷10 is not a finite binary number.⍞000D┌────────────────┬─────────────────┐⍞000D│3602879701896397│36028797018963968│⍞000D└────────────────┴─────────────────┘⍞000D⍞000D    ratf 2*¯16                          ⍝ reciprocal of power of 2 is spot-on.⍞000D┌─┬─────┐⍞000D│1│65536│⍞000D└─┴─────┘⍞000D⍞000D    ratf ¯0.75                          ⍝ negative sign fixed to numerator.⍞000D┌──┬─┐⍞000D│¯3│4│⍞000D└──┴─┘⍞000D⍞000DNotice  that  the denominator of the rational pair returned by ratf is always an⍞000Dinteger power of 2.⍞000D⍞000DRef: http://en.wikipedia.org/wiki/Continued_fraction⍞000D⍞000DExamples:⍞000D⍞000D    rational 0.75             ⍝ three quarters.⍞000D3 4⍞000D    rational ÷3               ⍝ one third.⍞000D1 3⍞000D⍞000D    rational ¯0.1234          ⍝ negative real => negative numerator.⍞000D¯617 5000⍞000D⍞000D    rational 0                ⍝ 0 => 0÷1 (this is handy for →cfract←).⍞000D0 1⍞000D⍞000D    1e¯10 rational 2*÷2       ⍝ coarse rational approximation to sqrt(2).⍞000D114243 80782⍞000D⍞000D    ⎕←pi←rational ○1          ⍝ tolerable approxmiation to pi.⍞000D5419351 1725033⍞000D⍞000D    (○1)=÷/pi                 ⍝ ... compares within ⎕ct.⍞000D1⍞000D    gcd/pi                    ⍝ pair is relatively prime.⍞000D1⍞000D    gcd/⎕←rational 9÷16       ⍝ pair of relatively prime numbers:⍞000D9 16⍞000D1⍞000D    rational 11÷29            ⍝ pair matches rational of quotient ...⍞000D11 29⍞000D                              ⍝ ... for all relatively prime pairs:⍞000D⍞000D    {⍵≡rational÷/⍵}¨ ∘.,⍨ sieve 2 to 100⍞000D0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1⍞000D1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1⍞000D1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1⍞000D1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1⍞000D1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1⍞000D1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1⍞000D1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1⍞000D1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1⍞000D1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1⍞000D1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1⍞000D1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1⍞000D1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1⍞000D1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1⍞000D1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1⍞000D1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1⍞000D1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1⍞000D1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1⍞000D1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1⍞000D1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1⍞000D1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1⍞000D1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1⍞000D1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1⍞000D1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1⍞000D1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1⍞000D1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0⍞000D⍞000D    ⍉ rational +∘÷\ cfract ○1   ⍝ successive rational approximations to Pi.⍞000D      3       1⍞000D     22       7⍞000D    333     106⍞000D    355     113⍞000D 103993   33102⍞000D 104348   33215⍞000D 208341   66317⍞000D 312689   99532⍞000D 833719  265381⍞000D1146408  364913⍞000D5419351 1725033⍞000D⍞000D⍝ Looking at the third row above, we see that if we divide the number-of-the-⍞000D⍝ beast (666) by the NYC area code (212) we get a reasonable appoximation to Pi.⍞000D⍞000DSee also: factors sieve gcd cfract efract pco⍞000DSee also: hexf nats⍞000DSee also: numbers⍞000D⍞000DIndex:rational number|Pi|Beast, number of the' 
