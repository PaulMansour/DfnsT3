'B ← {rcols←1..} ##.X M                      ⍝ Exact cover: Knuth''s Algorithm X.⍞000D⍞000DGiven a set of requirements and set of actions, each of which  satisfies zero or⍞000Dmore of the requirements, choose a subset of the actions such that each require-⍞000Dment is satisfied exactly once.⍞000D⍞000DThe problem can be represented as a  boolean matrix, where each row is an action⍞000Dwith 1s at the column positions of the requirements it satisfies.⍞000D⍞000D      1   2   3   4⍞000D    ┌───┬───┬───┬───┐   Action A satisfies requirements 2 and 4⍞000D  A │ 0 │ 1 │ 0 │ 1 │     ..   B    ..      ..      ..  1  .. 2⍞000D    ├───┼───┼───┼───┤     ..   C    ..      ..      ..  1  .. 3⍞000D  B │ 1 │ 1 │ 0 │ 0 │⍞000D    ├───┼───┼───┼───┤   In this case a solution is 1 0 1, as A and C⍞000D  C │ 1 │ 0 │ 1 │ 0 │   together satisfy all requirements exactly once.⍞000D    └───┴───┴───┴───┘⍞000D⍞000DBoolean  result vector [B] identifies a  subset  of the rows of boolean argument⍞000Dmatrix [M] with exactly one 1 in each  column: 1∧.=+⌿B⌿M.  The selected rows are⍞000Dsaid to form an "exact cover" of the argument matrix.⍞000D⍞000DIf no  exact  cover  is possible, _scalar_ 0 is returned. This means that a test⍞000Dfor failure might be B≡0 or 0=⍴⍴B.⍞000D⍞000DMany problems, including →sudoku←, →queens← and pentomino-tiling can be  reduced⍞000Dto the exact cover problem. See →sudokuX←, →queensX← and ##.scripts.pentominos⍞000D⍞000DFor some problems, such as →queensX←,  some of the columns are "optional" and so⍞000Dneed not be covered. Optional boolean left argument vector [rcols], default  all⍞000D1s, specifies which columns are required to be covered.⍞000D⍞000DKnuth''s algorithm is described as being "recursive with backtracking":⍞000D⍞000D[1] If ⍵ has no columns (c=0) the algorithm succeeds with a result of r⍴0⍞000D    where r c←⍴⍵.⍞000D[2] Otherwise, choose any non-empty row r as a potential cover.⍞000D[3] Identify a sub-matrix of ⍵: columns not covered by r and rows not covered⍞000D    by r-covered columns (because each column must be covered only once).⍞000D[4] If the sub-matrix has an exact cover, merge this with r as result.⍞000D[5] Otherwise, if there are un-tried rows besides r, try these.⍞000D[6] Otherwise, return failure.⍞000D⍞000DKnuth suggests a heuristic: given that each column must be covered once and only⍞000Donce, we can choose rows r by selecting a column with a minimum number of 1s and⍞000Dexamining only those rows selected by 1s in this column.⍞000D⍞000DAs an example:⍞000D⍞000D      1   2   3   4   5   6   7⍞000D    ┌───┬───┬───┬───┬───┬───┬───┐⍞000D  A │ 1 │ 0 │ 0 │ 1 │ 0 │ 0 │ 1 │⍞000D    ├───┼───┼───┼───┼───┼───┼───┤⍞000D  B │ 1 │ 0 │ 0 │ 1 │ 0 │ 0 │ 0 │⍞000D    ├───┼───┼───┼───┼───┼───┼───┤⍞000D  C │ 0 │ 0 │ 0 │ 1 │ 1 │ 0 │ 1 │⍞000D    ├───┼───┼───┼───┼───┼───┼───┤⍞000D  D │ 0 │ 0 │ 1 │ 0 │ 1 │ 1 │ 0 │⍞000D    ├───┼───┼───┼───┼───┼───┼───┤⍞000D  E │ 0 │ 1 │ 1 │ 0 │ 0 │ 1 │ 1 │⍞000D    ├───┼───┼───┼───┼───┼───┼───┤⍞000D  F │ 0 │ 1 │ 0 │ 0 │ 0 │ 0 │ 1 │⍞000D    └───┴───┴───┴───┴───┴───┴───┘⍞000D⍞000DSelect any column; Knuth''s heuristic recommends choosing one with a minimal num-⍞000Dber of marked rows (1s). Let''s select the leftmost column [1]:⍞000D⍞000D     [1]  2   3   4   5   6   7⍞000D    ┌───┬───┬───┬───┬───┬───┬───┐⍞000D  A │ 1 │ 0 │ 0 │ 1 │ 0 │ 0 │ 1 │⍞000D    ├───┼───┼───┼───┼───┼───┼───┤⍞000D  B │ 1 │ 0 │ 0 │ 1 │ 0 │ 0 │ 0 │⍞000D    ├───┼───┼───┼───┼───┼───┼───┤⍞000D  C │ 0 │ 0 │ 0 │ 1 │ 1 │ 0 │ 1 │⍞000D    ├───┼───┼───┼───┼───┼───┼───┤⍞000D  D │ 0 │ 0 │ 1 │ 0 │ 1 │ 1 │ 0 │⍞000D    ├───┼───┼───┼───┼───┼───┼───┤⍞000D  E │ 0 │ 1 │ 1 │ 0 │ 0 │ 1 │ 1 │⍞000D    ├───┼───┼───┼───┼───┼───┼───┤⍞000D  F │ 0 │ 1 │ 0 │ 0 │ 0 │ 0 │ 1 │⍞000D    └───┴───┴───┴───┴───┴───┴───┘⍞000D⍞000DSelecting any marked row in this column identifies  an  "uncovered"  sub-matrix.⍞000DFirst we mark columns selected by this row and then we mark rows selected by any⍞000Dof the marked columns.⍞000D⍞000DArbitrarily choosing the second row and marking the covered rows and columns:⍞000D⍞000D      ┌───────────┬───────────────── Columns marked by second row.⍞000D      │           │⍞000D     [1]  2   3   4   5   6   7⍞000D    ┌───┬───┬───┬───┬───┬───┬───┐⍞000D  A │[1]│ 0 │ 0 │[1]│ 0 │ 0 │ 1 │─┬─ Rows marked by marked columns.⍞000D    ├───┼───┼───┼───┼───┼───┼───┤ │⍞000D [B]│[1]│ 0 │ 0 │[1]│ 0 │ 0 │ 0 │─┤⍞000D    ├───┼───┼───┼───┼───┼───┼───┤ │⍞000D  C │ 0 │ 0 │ 0 │[1]│ 1 │ 0 │ 1 │─┘⍞000D    ├───┼───┼───┼───┼───┼───┼───┤⍞000D  D │ 0 │ 0 │ 1 │ 0 │ 1 │ 1 │ 0 │─┬─ Unmarked rows⍞000D    ├───┼───┼───┼───┼───┼───┼───┤ │⍞000D  E │ 0 │ 1 │ 1 │ 0 │ 0 │ 1 │ 1 │─┤⍞000D    ├───┼───┼───┼───┼───┼───┼───┤ │⍞000D  F │ 0 │ 1 │ 0 │ 0 │ 0 │ 0 │ 1 │─┘⍞000D    └───┴───┴───┴───┴───┴───┴───┘⍞000D          │   │       │   │   │⍞000D          └───┴───────┴───┴───┴───── Unmarked columns⍞000D⍞000DThe algorithm is applied recursively to the unmarked submatrix, in this case the⍞000Dmatrix:⍞000D⍞000D      2   3   5   6   7⍞000D    ┌───┬───┬───┬───┬───┐⍞000D  D │ 0 │ 1 │ 1 │ 1 │ 0 │⍞000D    ├───┼───┼───┼───┼───┤⍞000D  E │ 1 │ 1 │ 0 │ 1 │ 1 │⍞000D    ├───┼───┼───┼───┼───┤⍞000D  F │ 1 │ 0 │ 0 │ 0 │ 1 │⍞000D    └───┴───┴───┴───┴───┘⍞000D⍞000DIf the recursive call fails to find an exact cover, it "backtracks" and a diff-⍞000Derent row is examined. If there are no untried rows, the search fails.⍞000D⍞000DOtherwise, if the  recursive  call succeeds, the resulting covering vector, ext-⍞000Dended with the marked row, is returned as result.⍞000D⍞000DTechnical note:⍞000D⍞000DIn general, APL provides two ways to identify a subset of the rows  and  columns⍞000Dof a matrix: the first is to use indices M[I;] or M[;I] and the second employs a⍞000Dboolean selection vector B/M or B⌿M.  The coding of X  arbitrarily  chooses  the⍞000Dsecond (boolean selection) method.⍞000D⍞000DRef: http://en.wikipedia.org/wiki/Algorithm_X⍞000D⍞000DAlternative⍞000D-----------⍞000DPhil Last provides this alternative coding, which is good for small arrays:⍞000D⍞000D    X←{⍵{⍉(⍵⍴2)⊤{⍵/⍳⍴⍵}1∧.=(⍉⍺)+.∧(⍵⍴2)⊤⍳2*⍵}⍬⍴⍴⍵}⍞000D⍞000DExample:⍞000D⍞000D    M               ⍝ Constraint matrix.⍞000D1 0 0 1 0 0 1⍞000D1 0 0 1 0 0 0⍞000D0 0 0 1 1 0 1⍞000D0 0 1 0 1 1 0⍞000D0 1 1 0 0 1 1⍞000D0 1 0 0 0 0 1⍞000D⍞000D    X M             ⍝ Rows that form exact cover.⍞000D0 1 0 1 0 1⍞000D⍞000D    (X M)⌿M         ⍝ selected covering rows.⍞000D1 0 0 1 0 0 0⍞000D0 0 1 0 1 1 0⍞000D0 1 0 0 0 0 1⍞000D⍞000D    1∧.=+⌿(X M)⌿M   ⍝ condition for exact cover.⍞000D1⍞000D⍞000D⍝ See also →sudokuX←                ⍝ Exact cover Sudoku solver.⍞000D⍝ See also →queensX←                ⍝ Exact cover N-Queens solver.⍞000D⍝ See also ##.scripts.pentominos    ⍝ Exact cover Pentomino tiling.⍞000D⍞000DSee also: Graphs assign sudoku sudokuX queensX⍞000D⍞000DIndex:cover, exact|Algorithm X|exact cover|sudoku, game of|N-Queens|pentomino⍞000DIndex:assignment⍞000DIndex;Knuth D.E.|Last P.' 
