'Ackermann''s Function in Brainfuck⍞000D---------------------------------⍞000DAckermann''s function is usually written in →declarative← style as three cases:⍞000D⍞000D    ack 0 n → n+1⍞000D    ack m 0 → ack (m-1) 1⍞000D    ack m n → ack (m-1) (ack m (n-1))⍞000D⍞000Dwhere ''→'' is pronounced "reduces to".⍞000D⍞000DWe  can  transform  this  definition into tail-recursive form with an additional⍞000Dargument [a], which is a list of values-to-be-processed:⍞000D⍞000D    ack ⍬,0 n → n+1⍞000D    ack a,0 n → ack a,n+1⍞000D    ack a,m 0 → ack a,(m-1) 1⍞000D    ack a,m n → ack a,(m-1) m (n-1)⍞000D⍞000DThe  pattern-matching for a null argument list (⍬,0 n) may be made a little more⍞000Dregular if we mark the list with a special terminating value of, say, ¯1:⍞000D⍞000D    ack a,¯1 n → n⍞000D    ack a, 0 n → ack a,n+1⍞000D    ack a, m 0 → ack a,(m-1) 1⍞000D    ack a, m n → ack a,(m-1) m (n-1)⍞000D⍞000DThis simplification entails one additional final reduction, so instead of:⍞000D⍞000D    ack ⍬ 0 n → n+1⍞000D⍞000Dwe have:⍞000D⍞000D    ack ¯1 0 n → ack ¯1 (n+1) → n+1⍞000D⍞000DCoded in D and using ⍺ as the accumulator:⍞000D⍞000D    ack←{⍺←¯1⍞000D          a←¯2↓⍺,⍵⍞000D        m n←¯2↑⍺,⍵⍞000D        m=¯1:n⍞000D        m=0:a ∇ n+1⍞000D        n=0:a ∇(m-1)1⍞000D            a ∇(m-1)m(n-1)⍞000D    }⍞000D⍞000D    ack 3 3     ⍝ ack 3 3 → 61⍞000D61⍞000D⍞000DWe  can now code this tail-recursive version of Ackermann''s function in BF using⍞000D→mac← our simple macro processor.⍞000D⍞000DThe following small function collects character vectors into a newline-separated⍞000Dline-vector in buffer ⍙:⍞000D⍞000D    ∆←{{}⍙,←⍵,¯1↑4↑⎕av}     ⍝ accumulate into ⍙ buffer.⍞000D    ⍙←''''                    ⍝ null accumulation buffer.⍞000D⍞000DSo:⍞000D⍞000D    ⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍞000D    ⍝                                                               ⍝⍞000D    ⍝ Macros:                           ⍝ Ackermann''s function.     ⍝⍞000D    ⍝                                   ⍝                           ⍝⍞000D    ∆''  ;=(, ∆=/- >6∆[+<8∆>]<  )· · ''   ⍝ input digit               ⍝⍞000D    ∆''  :=(  ∆=/+ >6∆[-<8∆>]< .)· · ''   ⍝ output digit              ⍝⍞000D    ∆''                              ''   ⍝                           ⍝⍞000D    ∆''  {=/>+/<[/>-/< · · · · · · · ''   ⍝ if                        ⍝⍞000D    ∆''  ⋄=/>]/>[-/< · · · · · · · · ''   ⍝ else                      ⍝⍞000D    ∆''  }=/>/>]/</< · · · · · · · · ''   ⍝ fi                        ⍝⍞000D    ∆''                              ''   ⍝                           ⍝⍞000D    ∆''  ≥=(                         ''   ⍝ dup ⍺ right               ⍝⍞000D    ∆''      [-/>+>+</<]/>>          ''   ⍝   m .. 0  → 0 .. m m      ⍝⍞000D    ∆''      [-</<+/>>]</<           ''   ⍝   m .. m  ←               ⍝⍞000D    ∆''  ) ·                         ''   ⍝                           ⍝⍞000D    ∆''                              ''   ⍝                           ⍝⍞000D    ∆''  ←=[-/<+/>]  · · · · · · · · ''   ⍝ move ⍺ left               ⍝⍞000D    ∆''  →=[-/>+/<]  · · · · · · · · ''   ⍝ move ⍺ right              ⍝⍞000D    ∆''                              ''   ⍝                           ⍝⍞000D    ⍝ Code:                             ⍝                           ⍝⍞000D    ∆''                              ''   ⍝                           ⍝⍞000D    ∆'' -                            ''   ⍝  (¯1)                     ⍝⍞000D    ∆'' >;                           ''   ⍝   ¯1(m)                   ⍝⍞000D    ∆'' >;<                          ''   ⍝   ¯1(m)n                  ⍝⍞000D    ∆'' +[-                          ''   ⍝   a(m)n                   ⍝⍞000D    ∆''      2{                      ''   ⍝   if m≠0:                 ⍝⍞000D    ∆''          >1{                 ''   ⍝       if n≠0:             ⍝⍞000D    ∆''              <3≥             ''   ⍝           a(m)n 0 m       ⍝⍞000D    ∆''              >1→             ''   ⍝           a m(0)n m       ⍝⍞000D    ∆''              >>2←            ''   ⍝           a m m n(0)      ⍝⍞000D    ∆''              <-<<->>         ''   ⍝           a(m-1)(m)(n-1)  ⍝⍞000D    ∆''          1⋄                  ''   ⍝       else if n=0:        ⍝⍞000D    ∆''              <->+            ''   ⍝           a(m+1)1         ⍝⍞000D    ∆''          1}<                 ''   ⍝       fi                  ⍝⍞000D    ∆''      2⋄                      ''   ⍝   else if m=0:            ⍝⍞000D    ∆''          >1←<+<              ''   ⍝       a(a)(n+1)0          ⍝⍞000D    ∆''      2}                      ''   ⍝   fi                      ⍝⍞000D    ∆''  +]                          ''   ⍝ until a(¯1)n              ⍝⍞000D    ∆''  >:                          ''   ⍝ output n                  ⍝⍞000D        ack ⍙←⍙ ''''                                                  ⍝⍞000D    ⍝                                                               ⍝⍞000D    ⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍞000D⍞000DThe  program  inputs two single digits and outputs a single digit result. Unless⍞000Dwe use the memory dump, this restricts the possible arguments to:⍞000D⍞000D        m n→0   1   2   3   4   5   6   7   8⍞000D        ↓ ┌───┬───┬───┬───┬───┬───┬───┬───┬───┐⍞000D        0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │⍞000D          ├───┼───┼───┼───┼───┼───┼───┼───┼───┘⍞000D        1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │⍞000D          ├───┼───┼───┼───┼───┴───┴───┴───┘⍞000D        2 │ 3 │ 5 │ 7 │ 9 │⍞000D          ├───┼───┴───┴───┘⍞000D        3 │ 5 │⍞000D          └───┘⍞000D⍞000D    bf mac ack      ⍝ ack 2 3 → 9⍞000D2⍞000D3⍞000D9⍞000D⍞000DThe  following function removes all non-BF "white space", which was preserved by⍞000Dthe macro processor:⍞000D⍞000D    dark ← ∩∘''[]<>+-,.''         ⍝ without white space.⍞000D⍞000Dand this optimiser removes cancelling <> and >< sequences.⍞000D⍞000D    opt ← {↑{({⍵⍱¯1⌽⍵}⍺⍷⍵)/⍵}⍣≡/''><'' ''<>''⍵}     ⍝ cancelling >< pairs removed.⍞000D⍞000D    ⍴opt dark mac ack           ⍝ size of optimzed BF code.⍞000D181⍞000D⍞000DThis function wraps and indents BF loops for easier reading:⍞000D⍞000D    pretty←{⎕ML←1⍞000D        nl←⊃⌽⎕TC⍞000D        dents←{∊¨(0⌈⍵+1 ¯1)⍴¨⊂⊂4↑''·''}⍞000D        0{⍞000D            nice(next nasty)←⍵⍞000D            ''∘''=next:∊nice⍞000D            more less←dents ⍺⍞000D            ''[''=next:(⍺+1)∇(nice,next,nl,more)nasty⍞000D            '']''=next:(⍺-1)∇(nice,nl,less,next)nasty⍞000D            ⍺ ∇(nice next)nasty⍞000D        }↑{⍺ ⍵}/⍵,''∘''⍞000D    }⍞000D⍞000DYou should be able to copy and paste the following output into any BF system:⍞000D⍞000D    pretty opt dark mac ack     ⍝ Ackermann''s function in Brainfuck.⍞000D->,>------[⍞000D·   +<-------->⍞000D],>------[⍞000D·   +<-------->⍞000D]<<+[⍞000D·   ->>+<<[⍞000D·   ·   >>-+<[⍞000D·   ·   ·   >-<<[⍞000D·   ·   ·   ·   ->>>+>+<<<<⍞000D·   ·   ·   ]>>>>[⍞000D·   ·   ·   ·   -<<<<+>>>>⍞000D·   ·   ·   ]<<<[⍞000D·   ·   ·   ·   ->+<⍞000D·   ·   ·   ]>>[⍞000D·   ·   ·   ·   -<<+>>⍞000D·   ·   ·   ]<-<<->>>⍞000D·   ·   ]>[⍞000D·   ·   ·   -<<->+>>⍞000D·   ·   ]<⍞000D·   ]>>[⍞000D·   ·   -<[⍞000D·   ·   ·   -<+>⍞000D·   ·   ]<+>>>⍞000D·   ]<<<<+⍞000D]>>++++++[⍞000D·   -<++++++++>⍞000D]<.⍞000D⍞000DSee also: bf mac balm⍞000D⍞000DIndex:Ackermann''s function|Brainfuck|declarative programming⍞000DIndex:tail recursion|pattern-matching⍞000DIndex;Ackermann W.' 
