'z←x ##.xtimes y                         ⍝ Fast multi-digit product using FFT.⍞000D⍞000D0. Introduction⍞000D⍞000DFFT is used to provide an O(n×⍟n) algorithm for the convolution of  two  vectors⍞000D(polynomial multiplication), which is then used to implement a  fast  multiplic-⍞000Dation for integers with an arbitrary number of digits.  The ideas and code  were⍞000Dpresented by Henry Rich in the Jwiki essay FFT on  2010-12-27,  here  translated⍞000Dfrom J to Dyalog APL. See: http://www.jsoftware.com/jwiki/Essays/FFT⍞000D⍞000DIn these notes, ⎕pp←6 and ⎕io←0 .⍞000D⍞000D1. Convolution⍞000D⍞000DConvolution (polynomial multiplication) can be coded succinctly:⍞000D⍞000D   convolve←{+⌿(-⍳⍴⍺)⌽⍺∘.×⍵,0×1↓⍺}⍞000D⍞000D   x←9 3 5 8 1 0 5⍞000D   y←6 2 3 7 4⍞000D⍞000D   x convolve y⍞000D54 36 63 130 94 73 109 49 19 35 20⍞000D⍞000Dconvolve works by summing the antidiagonals of x∘.×y , that is, summing the ele-⍞000Dments of x∘.×y having like indices in (⍳⍴x)∘.+⍳⍴y , resulting in a  vector  with⍞000D¯1+(⍴x)+⍴y elements.⍞000D⍞000D   (x∘.×y) ''     '' ((⍳⍴x)∘.+⍳⍴y)⍞000D 54 18 27 63 36         0 1 2 3  4⍞000D 18  6  9 21 12         1 2 3 4  5⍞000D 30 10 15 35 20         2 3 4 5  6⍞000D 48 16 24 56 32         3 4 5 6  7⍞000D  6  2  3  7  4         4 5 6 7  8⍞000D  0  0  0  0  0         5 6 7 8  9⍞000D 30 10 15 35 20         6 7 8 9 10⍞000D⍞000Dconvolve takes time of order (⍴x)×(⍴y) , making it impractical  on  large  argu-⍞000Dments (longer than 1e5 , say).⍞000D⍞000D2. FFT⍞000D⍞000DA faster convolution obtains by use of FFT (fast Fourier  transform).  FFT  con-⍞000Dverts a polynomial represented by its coefficients into its value at  n  points,⍞000Dhere the n roots of unity, and the inverse FFT converts from the n  points  back⍞000Dinto coefficients. The important properties are that⍞000D⍞000D   ⍺ convolve ⍵  ←→  iFFT (FFT ⍺) × (FFT ⍵)⍞000D⍞000Dand that FFT and iFFT are computed  in  O(n×⍟n)  time  (justifying  the  moniker⍞000D"fast").⍞000D⍞000DThe key computation in FFT (and iFFT) is:⍞000D⍞000D   floop←{(⊣/⍺)∇⍣(×m)⊢(+⌿⍵),[m-0.5]⍺×[⍳m←≢⍴⍺]-⌿⍵}⍞000D⍞000DThe right argument is a hypercube initially constructed from the argument  ⍵  to⍞000DFFT as (r⍴2)⍴⍵ where r←2⍟⍬⍴⍴⍵ . floop applies to the hypercube r times, to  each⍞000Dof the axes in order. Let p←¯1*2÷2*r be a primitive root of unity of  order 2*r.⍞000DThe left argument is the hypercube p*(2*k)×s⍴⍳×/s←2⍴⍨(r-1)-k on the k-th applic-⍞000Dation of floop . Equivalently, the initial left argument is p*s⍴⍳×/s←(r-1)⍴2 and⍞000Dthe next left argument obtains from the current one by ⊣/⍺ .⍞000D⍞000D    x⍞000D9 3 5 8 1 0 5⍞000D    y⍞000D6 2 3 7 4⍞000D⍞000D    iFFT (FFT 16↑x) × (FFT 16↑y)⍞000D54J¯9.32587E¯15 36J¯3.51108E¯15 63J¯6.38378E¯15 ...⍞000D⍞000D    x rconvolve y⍞000D54J¯9.32587E¯15 36J¯3.51108E¯15 63J¯6.38378E¯15 ...⍞000D⍞000D    ⌊0.5+9○ x rconvolve y⍞000D54 36 63 130 94 73 109 49 19 35 20⍞000D⍞000D    x convolve y⍞000D54 36 63 130 94 73 109 49 19 35 20⍞000D⍞000DBecause rconvolve is mathematically (if not numerically) equivalent to convolve,⍞000Dthe application of 9○ to its result is justified when the arguments are real and⍞000Dof ⌊0.5+ when the they are integral.⍞000D⍞000D⍞000D3. Integer Multiplication⍞000D⍞000DThe convolution of x and y are the digits of their product when x and y are  in-⍞000Dterpreted as vectors of digits. The convention here is that the digits are list-⍞000Ded from most significant to least significant. For example, the number  3142  is⍞000Drepresented by 3 1 4 2 . Base 10 is used here but other bases are possible.⍞000D⍞000DIt remains to convert the result into standard form, with each element less than⍞000Dthe base.  If carry performs one step of propagating the carries, then the limit⍞000Dof its application is the desired computation.⍞000D⍞000D    x⍞000D9 3 5 8 1 0 5⍞000D    y⍞000D6 2 3 7 4⍞000D⍞000D    ⎕←t←⌊0.5+9○ x rconvolve y⍞000D54 36 63 130 94 73 109 49 19 35 20⍞000D⍞000D    carry 0,t⍞000D5 7 12 16 9 11 13 13 10 12 7 0⍞000D⍞000D    carry carry 0,t⍞000D5 8 3 6 10 2 4 4 1 2 7 0⍞000D⍞000D    carry carry carry 0,t⍞000D5 8 3 7 0 2 4 4 1 2 7 0⍞000D⍞000D    carry carry carry carry 0,t⍞000D5 8 3 7 0 2 4 4 1 2 7 0⍞000D⍞000D    carry⍣≡ 0,t⍞000D5 8 3 7 0 2 4 4 1 2 7 0⍞000D⍞000D    x xtimes y⍞000D5 8 3 7 0 2 4 4 1 2 7 0⍞000D⍞000D    '' ''~⍨⍕x xtimes y⍞000D583702441270⍞000D⍞000D    {⎕pp←18 ⋄ ⍕⍵} 9358105 × 62374⍞000D583702441270⍞000D⍞000D    s t ← ↓ ? 2 1.5e4⍴10⍞000D⍞000D    s xtimes time t⍞000D00.296⍞000D⍞000Dxtimes has the potential to multiply numbers with over a million digits in under⍞000Da minute.  The function as written is constrained by the fact that in Dyalog APL⍞000Dthe maximum rank of an array is 15, so that the maximum product  can  have  only⍞000D2*15 or 32768 digits.⍞000D⍞000D⍞000D4. Collected Definitions⍞000D⍞000DThe presentation here favors terseness and clarity over efficiency.  Some  poss-⍞000Dible improvements are described in the Jwiki essay.  (For example, computing the⍞000Droots of unity just once rather than four times.)⍞000D⍞000D    convolve←{+⌿(-⍳⍴⍺)⌽⍺∘.×⍵,0×1↓⍺}⍞000D⍞000D    xtimes←{⍞000D        roots     ← {×\1,1↓(⍵÷2)⍴¯1*2÷⍵}⍞000D        cube      ← {⍵⍴⍨2⍴⍨2⍟⍴⍵}⍞000D        extend    ← {(2*⌈2⍟¯1+(⍴⍺)+⍴⍵)↑¨⍺ ⍵}⍞000D        floop     ← {(⊣/⍺)∇⍣(×m)⊢(+⌿⍵),[m-0.5]⍺×[⍳m←≢⍴⍺]-⌿⍵}⍞000D        FFT       ← {      ,(cube  roots ⍴⍵)floop cube ⍵}⍞000D        iFFT      ← {(⍴⍵)÷⍨,(cube +roots ⍴⍵)floop cube ⍵}⍞000D        rconvolve ← {(¯1+(⍴⍺)+⍴⍵)↑iFFT ⊃×/FFT¨⍺ extend ⍵}⍞000D        carry     ← {1↓+⌿1 0⌽0,0 10⊤⍵}⍞000D        (+/∧\0=t)↓t←carry⍣≡0,⌊0.5+9○ ⍺ rconvolve ⍵⍞000D    }⍞000D⍞000DRef: http://www.jsoftware.com/jwiki/Essays/FFT⍞000D⍞000DSee also: nats big xpower⍞000D⍞000DIndex:Fast Fourier Transform|convolution|polynomial⍞000DIndex;Hui R.K.W.|Rich H.' 
