'cvec ← larg (fn ##.nats) rarg               ⍝ Natural number arithmetic.⍞000D⍞000DNats  applies  its operand function between natural (non-negative, whole) number⍞000Darguments. The operand may be one of:⍞000D⍞000D    +       sum⍞000D    -       difference⍞000D    ×       product⍞000D    ÷       quotient⍞000D    *       exponent⍞000D    ⌊       min⍞000D    ⌈       max⍞000D    |       residue⍞000D    ∨       greatest common divisor⍞000D    ∧       least common multiple⍞000D    <≤=≥>≠  relational⍞000D⍞000DArguments  [larg] and [rarg] are typically vectors of characters ''0''-''9'' but may⍞000Dbe numeric for (natural) numbers with no more than ⎕PP digits.⍞000D⍞000DNB: [nats] deals only in single (scalar) numbers, rather than whole arrays.⍞000D⍞000DThe result is a character vector of decimal digits.⍞000D⍞000D        1234567890 ×nats ''12345678901234567890''⍞000D    15241578751714678875019052100⍞000D⍞000D[nats] is similar to operator →big← except that it:⍞000D⍞000D    - deals only in non-negative numbers,⍞000D    - accepts only dyadic operand functions,⍞000D    - is quicker for large numbers.⍞000D⍞000DOperand (-) takes the "elementary school" approach of returning 0 if the minuend⍞000Dis smaller than the subtrahend (larg<rarg).⍞000D⍞000D          2 -nats 3         ⍝ larg < rarg⍞000D    0⍞000D⍞000DOperand (÷) returns the floor of the real quotient:⍞000D⍞000D        100 ÷nats 13        ⍝ floor of real quotient.⍞000D    7⍞000D        13 |nats 100        ⍝ residue (remainder).⍞000D    9⍞000D        9 +nats 7 ×nats 13  ⍝ dividend = remainder + quotient × divisor⍞000D    100⍞000D⍞000DGianluigi Quario comments that it is difficult to enter large-magnitude numbers:⍞000D⍞000D        456 +nats 123E20                        ⍝ raw E-notation won''t work.⍞000D    Bad number: 1.23E22⍞000D        456+nats 1.23E22⍞000D       ∧⍞000D⍞000D        456 +nats ''12300000000000000000000''     ⍝ this works but is ungainly.⍞000D    12300000000000000000456⍞000D⍞000D        456+nats 123×nats 10*nats 20            ⍝ OK but inconvenient.⍞000D    12300000000000000000456⍞000D⍞000DGianluigi suggests this function:⍞000D⍞000D    pfmt←{⎕IO ⎕ML ⎕PP←0 0 16            ⍝ plain format of a numeric scalar.⍞000D        rep←⍕⍵⍞000D        ⍵≡rep:⍵⍞000D        ~''E''∊rep:rep⍞000D        exp←⍎(1+rep⍳''E'')↓rep⍞000D        0>exp:''_ ''~⍨(⎕PP-exp)⍕⍵⍞000D        sig←''¯''=⊃rep⍞000D        man←⎕PP↑''.''~⍨(sig↓(rep⍳''E'')↑rep),⎕PP⍴''0''  ⍝ mantissa⍞000D        (sig⍴''¯''),(1+exp)↑man,exp⍴''0''⍞000D    }⍞000D⍞000DThen:⍞000D        456 +nats pfmt 123E20⍞000D    12300000000000000000456⍞000D⍞000D        456 +nats pfmt 1.23E22⍞000D    12300000000000000000456⍞000D⍞000DTechnical notes:⍞000D⍞000DPerformance  benefits from representing the numbers internally in a fairly large⍞000Dbase  (radix).  However, if too large a base is chosen, intermediate results run⍞000Dthe risk of exceeding the 53-bit precision of IEEE floating point arithmetic and⍞000Dso losing accuracy.  A base of 10*6 seems optimal.  A power of 10 base is chosen⍞000Dto simplify conversion to and from internal format.⍞000D⍞000DProduct⍞000D-------⍞000DRoger Hui points out that however small a base we choose, the product of suffic-⍞000Diently long vectors of digits will cause 53-bit overflow.  To avoid this loss of⍞000Dprecision, inner function "mul" tests the lengths of its arguments and, if  nec-⍞000Dessary, splits them into sub-products of shorter vectors. If ⍺ and ⍵ are vectors⍞000Dof radix-rx digits, and + and × are vector sum and product respectively, then:⍞000D                        ¯     ¯⍞000D    ⍺ × ⍵  ←→  ((⍺ × s↑⍵),s↓⍵⍴0)  +  ⍺ × s↓⍵⍞000D      ¯            ¯              ¯    ¯⍞000DFor example,  suppose a 7-digit product were enough to cause overflow.  We could⍞000Davoid the overflow  by splitting the product  into the sum of a 3-digit and a 4-⍞000Ddigit product, like so:⍞000D⍞000D    1 2 × 3 4 5 6 7 8 9  ←→  ((1 2 × 3 4 5),0 0 0 0)  +  1 2 × 6 7 8 9⍞000D        ¯ └─────7─────┘            ¯ └─3─┘            ¯      ¯ └──4──┘⍞000D⍞000DAs a test case,  Roger  observes  that  the  square  of  natural number ⍵/''9'' is⍞000D(⍵ 2 ⍵ 2-1)/''9801'':⍞000D⍞000D          ×nats⍨''9''⍞000D    81⍞000D          ×nats⍨''99''⍞000D    9801⍞000D          ×nats⍨''999''⍞000D    998001⍞000D          ×nats⍨''99999999''⍞000D    9999999800000001⍞000D⍞000DWith nat''s radix of 10*6,  the square of 999...9 is sufficent  to require split-⍞000Dting:                                    └60000┘⍞000D⍞000D    (×nats⍨6e4/''9'')≡(6e4 2 6e4 2-1)/''9801''      ⍝ (takes around a minute).⍞000D1⍞000D⍞000DSee →xtimes← for a faster multi-digit product.⍞000D⍞000DExponent⍞000D--------⍞000DFor  ⍺*⍵, we avoid calculating ⍵ products  ⍺ × ⍺ × ···,  by using the recurrence⍞000Drelation:                                  └─── ⍵ ───┘⍞000D⍞000D    ⍺*0 = 1⍞000D    ⍺*1 = ⍺⍞000D    ⍺*⍵ = (⍺*2|⍵) × {⍵×⍵} ⍺*⌊⍵÷2⍞000D⍞000Dwhich needs only O(2⍟⍵) products.⍞000D⍞000D(muse:⍞000D⍞000D    Notice in the examples below that */5/2 is a number with 19,729 decimal dig-⍞000D    its.  An amusing way to distinguish mathematicians from computer programmers⍞000D    at  a social gathering (perhaps a cocktail party or wedding reception) is to⍞000D    sing this little song (to the tune of "The Grand old Duke of York"):⍞000D⍞000D        Two,⍞000D        Two-to-the-two,⍞000D        Two-to-the-two-to-the-two,⍞000D        Two-to-the-two-to-the-two-to-the-two,⍞000D        Two-to-the-two-to-the-two-to-the-two-to-the-two,⍞000D        ...⍞000D⍞000D    You  will  find  that  after six or seven lines, the mathematicians begin to⍞000D    look bored, while the computer programmers turn pale and start to faint.⍞000D⍞000D    See also: staples⍞000D)⍞000D⍞000DQuotient⍞000D--------⍞000DWe  use  the traditional "high-school" long division method (invented by Charles⍞000DBabbage,  see: eval.dws/notes.Long_division). A minor refinement is that, as the⍞000Dradix  is  large, it pays to do a binary, rather than linear search for the next⍞000D"digit" of the result. With a radix of 10*6 (around 2*20), we can find the digit⍞000Din  about  20  comparisons when using (0, radix-1) as the lower and upper search⍞000Dbounds.⍞000D⍞000DBut  we  can  do a little better. We take the two most significant digits of the⍞000Ddividend  and  divisor  ((p0 p1 ···)(q0 q1 ···))  and decode each pair using the⍞000Dradix.  This gives a pair of numbers (pp qq), each in the range 0,radix*2, which⍞000Dis still well within our required 53-bit precision limit.⍞000D⍞000DTo  find  a lower bound, we assume that all digits following p0 and p1 are 0 and⍞000Dthat  all  those  following q0 and q1 are (radix-1). This gives a lower bound of⍞000D(⌊pp÷qq+1).⍞000D⍞000DLikewise,  an  upper  bound assumes all digits following p0 and p1 are (radix-1)⍞000Dand  all  those following q0 and q1 are 0, giving a upper bound of (⌈(pp+1)÷qq).⍞000DIt  makes  things a little easier if we soften this upper bound very slightly by⍞000Dobserving that:⍞000D⍞000D    (  ⌈⍵) = ⌊1+⍵   ⍝ for non-integer ⍵⍞000D    (1+⌈⍵) = ⌊1+⍵   ⍝ for integer ⍵⍞000D⍞000Dso we can reasonably take an upper bound of: (⌊1+(pp+1)÷qq).⍞000D⍞000DIn other words, the lower-upper bound pair is (⌊pp÷qq+1) (⌊1+(pp+1)÷qq).⍞000D⍞000DThen, using expression transformation to simplify:⍞000D⍞000D    (⌊pp÷qq+1) (⌊1+(pp+1)÷qq)       ⍝ (⌊⍺)(⌊⍵) = ⌊⍺ ⍵⍞000D    _¯          ¯⍞000D=   ⌊(pp÷qq+1) (1+(pp+1)÷qq)        ⍝ (0+⍺)(1+⍵) = 0 1+⍺ ⍵⍞000D     ____       ¯¯⍞000D=   ⌊0 1+(pp÷qq+1) ((pp+1)÷qq)      ⍝ (⍺÷⍵)(∊÷⍴) = (⍺ ∊)÷(⍵ ⍴)⍞000D            ¯             ¯⍞000D=   ⌊0 1+(pp(pp+1))÷(qq+1)qq        ⍝ ⍺(⍺+1) = ⍺+0 1,  if ⍺ scalar.⍞000D          ¯¯¯¯¯¯¯¯  ¯¯¯¯¯¯¯¯⍞000D=   ⌊0 1+(pp+0 1) ÷ qq+1 0          ⍝ ⍺÷⍵ = ↑÷/⍺ ⍵⍞000D                  ¯⍞000D=   ⌊0 1+↑÷/(pp+0 1) (qq+1 0)       ⍝ (⍺+⍵)(∊+⍴) = ⍺ ⍵+∊ ⍴⍞000D               ¯        ¯⍞000D=   ⌊0 1+↑÷/pp qq+(0 1)(1 0)        ⍝ thus (pp qq) can use a single name ppqq.⍞000D⍞000DExamples:⍞000D⍞000D    ⎕d ×nats ⎕d                     ⍝ 123456789 * 2⍞000D15241578750190521⍞000D⍞000D    2*nats 1024                     ⍝ 2*1024⍞000D17976931348623159077293051907890247336179769789423065727343008115773267580550096⍞000D      31327084773224075360211201138798713933576587897688144166224928474306394741⍞000D      24377767893424865485276302219601246094119453082952085005768838150682342462⍞000D      88147391311054082723716335051068458629823994724593847971630483535632962422⍞000D      4137216⍞000D⍞000D    ⍴↑*nats/5/2                     ⍝ */5/2 has 19,729 decimal digits.⍞000D19729⍞000D⍞000D    ⎕d *nats 8                      ⍝ 123456789 * 8⍞000D53965948844821664748141453212125737955899777414752273389058576481⍞000D⍞000D    ↑÷nats/⎕d ⎕d *nats¨ 101 100     ⍝ test accuracy⍞000D123456789⍞000D⍞000D    0 1{⍵=0:⊃⍺ ⋄ (1↓⍺,+nats/⍺)∇ ⍵-1}1000    ⍝ 1,000th Fibonacci number (JRC).⍞000D43466557686937456435688527675040625802564660517371780402481729089536555417949051⍞000D      89040387984007925516929592259308032263477520968962323987332247116164299644⍞000D      0906533187938298969649928516003704476137795166849228875⍞000D⍞000D    factorial ← ↑∘(×nats/)∘⍳        ⍝ !⍵⍞000D⍞000D    factorial 1000                  ⍝ !1000⍞000D40238726007709377354370243392300398571937486421071463254379991042993851239862902⍞000D      05920442084869694048004799886101971960586316668729948085589013238296699445⍞000D      90997424504087073759918823627727188732519779505950995276120874975462497043⍞000D      60141827809464649629105639388743788648733711918104582578364784997701247663⍞000D      28898359557354325131853239584630755574091142624174743493475534286465766116⍞000D      67797396668820291207379143853719588249808126867838374559731746136085379534⍞000D      52422158659320192809087829730843139284440328123155861103697680135730421616⍞000D      87476096758713483120254785893207671691324484262361314125087802080002616831⍞000D      51027341827977704784635868170164365024153691398281264810213092761244896359⍞000D      92870511496497541990934222156683257208082133318611681155361583654698404670⍞000D      89756029009505376164758477284218896796462449451607653534081989013854424879⍞000D      84959953319101723355556602139450399736280750137837615307127761926849034352⍞000D      62520001588853514733161170210396817592151090778801939317811419454525722386⍞000D      55414610628921879602238389714760885062768629671466746975629112340824392081⍞000D      60153780889893964518263243671616762179168909779911903754031274622289988005⍞000D      19544441428201218736174599264295658174662830295557029902432415318161721046⍞000D      58320367869061172601587835207515162842255402651704833042261439742869330616⍞000D      90897968482590125458327168226458066526769958652682272807075781391858178889⍞000D      65220816434834482599326604336766017699961283186078838615027946595513115655⍞000D      20360939881806121385586003014356945272242063446317974605946825731037900840⍞000D      24432438465657245014402821885252470935190620929023136493273497565513958720⍞000D      55965422874977401141334696271542284586237738753823048386568897646192738381⍞000D      49001407673104466402598994902222217659043399018860185665264850617997023561⍞000D      93897017860040811889729918311021171229845901641921068884387121855646124960⍞000D      79872290851929681937238864261483965738229112312502418664935314397013742853⍞000D      19266498753372189406942814341185201580141233448280150513996942901534830776⍞000D      44569099073152433278288269864602789864321139083506217095002597389863554277⍞000D      19674282224875758676575234422020757363056949882508796892816275384886339690⍞000D      99598262809561214509948717012445164612603790293091208890869420285106401821⍞000D      54399457156805941872748998094254742173582401063677404595741785160829230135⍞000D      35808184009699637252423056085590370062427124341690900415369010593398383577⍞000D      79394109700277534720000000000000000000000000000000000000000000000000000000⍞000D      00000000000000000000000000000000000000000000000000000000000000000000000000⍞000D      00000000000000000000000000000000000000000000000000000000000000000000000000⍞000D      0000000000000000000000000000000000000000000000⍞000D⍞000D    binomial ← {(factorial ⍵)÷nats(factorial ⍺)×nats factorial ⍵-⍺}     ⍝ ⍺!⍵⍞000D⍞000D    1000 binomial 2000⍞000D20481516269894897143351625029808250443964248879813970338203826376717481862020837⍞000D      55828932994182610206201464766319998023692415481798004524792018047549769261⍞000D      57856301289663432064714851152395251651227768588611539546256147907378668464⍞000D      15444453361761377007385567381458963007130651045595951447988874620636871851⍞000D      45518285511731662762536637730846829322553890497438594814317550307837964443⍞000D      70810085163724827462791417016619883764840843541430817785947037746565188475⍞000D      51468074969467492380303310181872329800966856745856025254991011811352535346⍞000D      58887941966653674904511306110096311906270342502293155911108976733963991149⍞000D      120⍞000D⍞000D⍝ Handy prefixes for the first few 2*10×⍵:⍞000D⍝⍞000D    prefs ← ''kilo'' ''mega'' ''giga'' ''tera'' ''peta'' ''exa'' ''zetta'' ''yotta'' ''...''⍞000D⍞000D    ⍉↑prefs{⍺ ⍵}2*nats¨ 10 20 to 200⍞000D kilo   1024⍞000D mega   1048576⍞000D giga   1073741824⍞000D tera   1099511627776⍞000D peta   1125899906842624⍞000D exa    1152921504606846976⍞000D zetta  1180591620717411303424⍞000D yotta  1208925819614629174706176⍞000D ...    1237940039285380274899124224⍞000D        1267650600228229401496703205376⍞000D        1298074214633706907132624082305024⍞000D        1329227995784915872903807060280344576⍞000D        1361129467683753853853498429727072845824⍞000D        1393796574908163946345982392040522594123776⍞000D        1427247692705959881058285969449495136382746624⍞000D        1461501637330902918203684832716283019655932542976⍞000D        1496577676626844588240573268701473812127674924007424⍞000D        1532495540865888858358347027150309183618739122183602176⍞000D        1569275433846670190958947355801916604025588861116008628224⍞000D        1606938044258990275541962092341162602522202993782792835301376⍞000D⍞000DSee also: xtimes xpower big gcd rats bt adic⍞000DSee also: numbers⍞000D⍞000DIndex:natural number|infinite precision|expression transformation⍞000DIndex:greatest common divisor|least common multiple|IEEE FP precision⍞000DIndex:factorial|binomial|fibonacci number|division, long⍞000DIndex:kilo-|mega-|giga-|tera-|peta-|exa-|zetta-|yotta-⍞000DIndex:computer programmers|mathematicians⍞000DIndex;Babbage C.|Fibonacci L.|York, Grand old Duke of|Hui R.K.W.|Quario G.' 
