'bmat ← {A CI} ##.baby bmat      ⍝ Manchester Small Scale Experimental Machine.⍞000D⍞000DThe Manchester Small Scale Experimental Machine (Baby) was the first operational⍞000Delectronic stored-program computer. The first program, which ran on 21 June 1948⍞000Dsearched for the highest factor of a given number. See the example below.⍞000D⍞000DThis  function,  which  emulates  the SSEM machine, takes a 32×32 boolean matrix⍞000Dargument that defines the initial state of the machine''s memory and, on encount-⍞000Dering a Halt instruction, returns the final state as result.⍞000D⍞000DTechnical notes for SSEM⍞000D------------------------⍞000DNB: Binary values in the SSEM are written with the least significant bits on the⍞000Dleft, for example:⍞000D⍞000D0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0     ⍝  0⍞000D1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0     ⍝  1⍞000D0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0     ⍝  2⍞000D1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0     ⍝  3⍞000D1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1     ⍝ ¯3⍞000D0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1     ⍝ -2*18⍞000D1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0     ⍝ ¯1+2*18⍞000D⍞000DThe  machine''s  memory is a 32×32 matrix of bits,  stored in a  Williams-Kilburn⍞000Dcathode ray tube.  The memory is addressed as 32 words or "lines",  each 32 bits⍞000Dwide. Each line represents either a (2''s complement) signed integer or an instr-⍞000Duction in the following format:⍞000D⍞000D     0         5               13    16⍞000D    ┌─────────┬───────────────┬─────┬───────────────────────────────┐⍞000D    │0 0 0 0 0│0 0 0 0 0 0 0 0│0 0 0│0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0│⍞000D    └─────────┴───────────────┴─────┴───────────────────────────────┘⍞000D     │         │               │     └─── unused⍞000D     │         │               └───────── function number (operation code)⍞000D     │         └───────────────────────── (spare: storage unit number)⍞000D     └─────────────────────────────────── operand address.⍞000D⍞000DIn addition to the main store, there are three visible "registers":⍞000D⍞000D    A  32-bit Accumulator.⍞000D    CI 32-bit Control Instruction (program counter) only first 5 bits are used.⍞000D    PI 32-bit Present Instruction (op-code buffer) only first 3 bits are used.⍞000Dand⍞000D    S is a 5-bit internal register used to hold the current operand address.⍞000D⍞000DThe seven machine instructions are:⍞000D⍞000D    0 0 0   jmp     CI ←STORE[S;]       ⍝ Jump⍞000D    1 0 0   jrp     CI+←STORE[S;]       ⍝ Jump relative⍞000D    0 1 0   ldn     A ←-STORE[S;]       ⍝ Load negative⍞000D    1 1 0   sto     STORE[S;]←A         ⍝ Store⍞000D    0 0 1   sub     A-←STORE[S;]        ⍝ Subtract⍞000D    1 0 1           (same as 0 0 1)     ⍝⍞000D    0 1 1   cmp     CI+←A<0             ⍝ Compare⍞000D    1 1 1   hlt     (stop)              ⍝ Halt⍞000D⍞000DNotice that there are no "immediate" instructions; literal values must be loaded⍞000Dfrom the store.⍞000D⍞000DThe  program  counter  (CI) is incremented immediately _before_ each instruction⍞000Dfetch, so that it usually shows the address of the prior instruction. This means⍞000Dthat on executing a jmp nn instruction, the next instruction to be executed will⍞000Dbe  the one whose address is one more than the value in line nn. For example, to⍞000Djump to line number 03, we could store a 2 in line 0 (say) and jmp 00.⍞000D⍞000DSome system software⍞000D--------------------⍞000DRather than having to program the machine in binary, we can invent a simple ass-⍞000Dembly  language using the instruction mnemonics from above. An assembler program⍞000Dis  a  character  array (simple matrix, line_list, vector of vectors). Each line⍞000Dhas the following format:⍞000D⍞000D    nn oper rand    ⍝ optional comment.⍞000Dor⍞000D    nn numb         ⍝ optional comment.⍞000D⍞000Dwhere:⍞000D⍞000D    nn   is the decimal line number 00-31,⍞000D    oper is one of: jmp jrp ldn sto sub cmp hlt,⍞000D    rand is a scalar-integer-returning APL expression,⍞000D    numb    ..      ..      ..      ..      ..⍞000D⍞000DLines that are not represented in the assembler source are set to 0.⍞000D⍞000DAn  example might be the following program to add the number in line[10] to that⍞000Din line[11] and store the result in line[12]:⍞000D⍞000D    display sum⍞000D┌→──────────────────────────────────────────────────┐⍞000D│01 ldn 10   ⍝ negate first number into accumulator.│⍞000D│02 sub 11   ⍝ subtract second number.              │⍞000D│03 sto 12   ⍝ store negative of result.            │⍞000D│04 ldn 12   ⍝ negate negative ...                  │⍞000D│05 sto 12   ⍝ ... result.                          │⍞000D│06 hlt      ⍝ stop                                 │⍞000D│                                                   │⍞000D│10 1234     ⍝ input                                │⍞000D│11 5678     ⍝ input                                │⍞000D│12          ⍝ result                               │⍞000D└───────────────────────────────────────────────────┘⍞000D⍞000DHere is an assember for baby code:⍞000D⍞000D    asm←{⎕ML ⎕IO←0                              ⍝ Assembler for Baby.⍞000D        ⍺←32 32 ⋄ lines bits←⍺                  ⍝ memory size.⍞000D        ops←↓8 3⍴''jmpjrpldnstosub   cmphlt''     ⍝ opcode mnemonics.⍞000D        wds←{⍵~⊂''''}∘{⍵~¨'' ''}∘{(1,1↓⍵='' '')⊂⍵}    ⍝ blank-separated words.⍞000D        raw←{(∧\⍵≠''⍝'')/⍵}                       ⍝ without comments.⍞000D        bin←{⌽(⍺/2)⊤⍵}                          ⍝ ssem-binary from decimal.⍞000D        ↑{                                      ⍝ bool store matrix.⍞000D            ↑(⍺⍳,¨⍳lines)⊃¨⊂lines↑⍵             ⍝ lines in line-number order.⍞000D        }/↓⍉↑{                                  ⍝ line_numbers, lines.⍞000D            0::11 ⎕SIGNAL⍨''bad line: '',⍵        ⍝ something wrong with line.⍞000D            nn instr←{(⊃⍵)(1↓⍵)}wds raw ⍵       ⍝ line number and content.⍞000D            line←(⍎nn,'',⍬'')∘{⍺ ⍵}               ⍝ line_number, bool_vector pair.⍞000D            0=⍴instr:line bits bin 0            ⍝ null instruction: 0 line.⍞000D            ~(1↑instr)∊ops:line bits bin⍎⍕instr ⍝ 1st wd not opcode: raw value.⍞000D            oper rand←2↑instr,⊂''0''              ⍝ opcode and operand address.⍞000D            addr←5 bin⍎rand                     ⍝ operand address.⍞000D            unit←8 bin 0                        ⍝ (storage unit number).⍞000D            opco←3 bin ops⍳⊂oper                ⍝ operator code.⍞000D            line bits↑addr,unit,opco            ⍝ line number and bool vector.⍞000D        }¨↓⎕FMT↑⍵                               ⍝ char vecs from any format.⍞000D    }⍞000D⍞000D.. and a corresponding disassembler:⍞000D⍞000D    dis←{⎕IO ⎕ML←0                              ⍝ Disassembler for Baby.⍞000D        lines bits←⍴⍵                           ⍝ no of lines and word size.⍞000D        max←2*bits                              ⍝ miximum unsigned value.⍞000D        ops←↓8 3⍴''jmpjrpldnstosubsubcmphlt''     ⍝ opcode mnemonics.⍞000D        arity←⍎''  1  1  1  1  1  1  0  0  ''     ⍝ instruction arity.⍞000D        decode←(0 5 13 16∊⍨⍳bits)∘⊂             ⍝ instruction decode.⍞000D        lfmt←{¯2↑''0'',⍕⍵}                        ⍝ line number format.⍞000D        dec←(-max÷2){⍺⍺+⍵⍵|⍵-⍺⍺}max∘{2⊥⌽⍵}      ⍝ signed decimal from ⌽binary.⍞000D        {                                       ⍝ assembled lines:⍞000D            nn num instr←⍵                      ⍝ line, decimal value, instr.⍞000D            (↑nn),'' '',(⍕⍪num),↑instr            ⍝ assembled to char matrix.⍞000D        }↓⍉↑(lfmt¨⍳lines){                      ⍝ label for each line.⍞000D            addr _ opco _←dec¨decode ⍵          ⍝ instruction decode.⍞000D            oper←opco⊃ops                       ⍝ instruction mnemonic.⍞000D            rand←(opco⊃arity)/'' '',lfmt addr     ⍝ operand address.⍞000D            ⍺(dec ⍵)(''  ⍝ '',oper,rand)          ⍝ instruction ⍝ number.⍞000D        }¨↓⍵                                    ⍝ ... for each line.⍞000D    }⍞000D⍞000DThe disassembler shows both an integer and instruction decoding of each line. In⍞000Dparticular,  the  instruction  decoding  for a line with a value of 0 is jmp 00.⍞000DHere is the result of our sum program from above. Notice that the result (1234 +⍞000D5678 → 6912) is in line[12]:⍞000D⍞000D    display dis baby asm sum    ⍝ assemble-run-disassemble sum program.⍞000D┌→─────────────────┐⍞000D↓00     0  ⍝ jmp 00│⍞000D│01 16394  ⍝ ldn 10│⍞000D│02 32779  ⍝ sub 11│⍞000D│03 24588  ⍝ sto 12│⍞000D│04 16396  ⍝ ldn 12│⍞000D│05 24588  ⍝ sto 12│⍞000D│06 57344  ⍝ hlt   │⍞000D│07     0  ⍝ jmp 00│⍞000D│08     0  ⍝ jmp 00│⍞000D│09     0  ⍝ jmp 00│⍞000D│10  1234  ⍝ jmp 18│⍞000D│11  5678  ⍝ jmp 14│⍞000D│12  6912  ⍝ jmp 00│⍞000D│13     0  ⍝ jmp 00│⍞000D│14     0  ⍝ jmp 00│⍞000D│15     0  ⍝ jmp 00│⍞000D│16     0  ⍝ jmp 00│⍞000D│17     0  ⍝ jmp 00│⍞000D│18     0  ⍝ jmp 00│⍞000D│19     0  ⍝ jmp 00│⍞000D│20     0  ⍝ jmp 00│⍞000D│21     0  ⍝ jmp 00│⍞000D│22     0  ⍝ jmp 00│⍞000D│23     0  ⍝ jmp 00│⍞000D│24     0  ⍝ jmp 00│⍞000D│25     0  ⍝ jmp 00│⍞000D│26     0  ⍝ jmp 00│⍞000D│27     0  ⍝ jmp 00│⍞000D│28     0  ⍝ jmp 00│⍞000D│29     0  ⍝ jmp 00│⍞000D│30     0  ⍝ jmp 00│⍞000D│31     0  ⍝ jmp 00│⍞000D└──────────────────┘⍞000D⍞000DWatching Baby working⍞000D---------------------⍞000DTo  watch  the  machine  working, we can display its Williams-Kilburn tube in an⍞000Dedit window in the following way:⍞000D⍞000D1. Fix function <asm> by Cutting & Pasting from the notes above.⍞000D⍞000D2. Edit  [baby]  to  inject  a  new line, which formats the machine state into a⍞000D   global  character  matrix  CRT,  at  the  start of the inner state transition⍞000D   function:⍞000D⍞000D    ...⍞000D    0{                                      ⍝ CI increment.⍞000D        CRT∘←disp{↑,/2↑¨⍵⊃¨⊂''·⍟''}¨⍪⍵        ⍝ NEW LINE: update CRT display.⍞000D        A CI_ M←⍵                           ⍝ Acc Ctrl-Instr Store-Matrix.⍞000D    ...⍞000D⍞000D3. Cut & Paste prog0 (say) assembly source, from the examples below, into a var-⍞000D   iable:⍞000D⍞000D    )ed →prog0⍞000D⍞000D4. Open an edit window on global character matrix CRT:⍞000D⍞000D    )ed -CRT⍞000D⍞000D5. Now run the program:⍞000D⍞000D    baby asm prog0      ⍝ watch that Baby go ...⍞000D⍞000DHistory⍞000D-------⍞000DThe precise wording of "first operational electronic stored-program computer" is⍞000Dsignificant.⍞000D⍞000DWikipedia provides an excellent chronology:⍞000D⍞000D    http://en.wikipedia.org/wiki/Timeline_of_computing_2400_BC-1949⍞000D    http://en.wikipedia.org/wiki/Computing_timeline_1950-1979⍞000D    http://en.wikipedia.org/wiki/Computing_timeline_1980-1989⍞000D    http://en.wikipedia.org/wiki/Computing_timeline_1990-forward⍞000D⍞000DHere is an extract from this history, with relevance to the SSEM:⍞000D⍞000D         Provided a computing service to end users ──────────────────────────┐⍞000D         Multiple instances built ───────────────────────────────────────┐   │⍞000D         Number base ────────────────────────────────────────────────┐   │   │⍞000D         Practical ──────────────────────────────────────────────┐   │   │   │⍞000D         Turing-complete ────────────────────────────────────┐   │   │   │   │⍞000D         Electronic ─────────────────────────────────────┐   │   │   │   │   │⍞000D         Stored program ─────────────────────────────┐   │   │   │   │   │   │⍞000D         General purpose ────────────────────────┐   │   │   │   │   │   │   │⍞000D         Conceived ──────────────────┐           │   │   │   │   │   │   │   │⍞000D         Operational ─────┐          │           │   │   │   │   │   │   │   │⍞000D                          O          C           G   S   E   T   P   N   M   U⍞000D                         ┌──────────┬──────────┬───┬───┬───┬───┬───┬───┬───┬───┐⍞000D            Tally sticks │¯35000    │          │ Y │ - │ - │ - │ Y │  1│ Y │ Y │⍞000D                         ├──────────┼──────────┼───┼───┼───┼───┼───┼───┼───┼───┤⍞000D             Bead Abacus │¯2400     │          │ Y │ - │ - │ - │ Y │2×5│ Y │ Y │⍞000D                         ├──────────┼──────────┼───┼───┼───┼───┼───┼───┼───┼───┤⍞000D   da Vinci''s calculator │          │1492      │ Y │ - │ - │ - │ Y │ 10│ - │ - │⍞000D                         ├──────────┼──────────┼───┼───┼───┼───┼───┼───┼───┼───┤⍞000D          Napier''s Bones │1617      │1614      │ Y │ - │ - │ - │ Y │ 10│ Y │ Y │⍞000D                         ├──────────┼──────────┼───┼───┼───┼───┼───┼───┼───┼───┤⍞000D              Slide Rule │1622      │          │ Y │ - │ - │ - │ Y │ 10│ Y │ Y │⍞000D                         ├──────────┼──────────┼───┼───┼───┼───┼───┼───┼───┼───┤⍞000D  Schickard''s calculator │1623      │          │ Y │ - │ - │ - │ Y │ 10│ - │ Y │⍞000D                         ├──────────┼──────────┼───┼───┼───┼───┼───┼───┼───┼───┤⍞000D     Pascal''s adding m/c │1642      │          │ Y │ - │ - │ - │ Y │ 10│ Y │ Y │⍞000D                         ├──────────┼──────────┼───┼───┼───┼───┼───┼───┼───┼───┤⍞000D   Babbage''s Anal.Engine │          │1834      │ Y │ - │ - │ Y │ Y │ 10│ - │ - │⍞000D                         ├──────────┼──────────┼───┼───┼───┼───┼───┼───┼───┼───┤⍞000D          Turing''s paper │          │1936      │ Y │ Y │ - │ Y │ - │ - │ - │ - │⍞000D                         ├──────────┼──────────┼───┼───┼───┼───┼───┼───┼───┼───┤⍞000D               Zuse''s Z3 │1941-05-12│1936      │ Y │ - │ - │ Y │ - │  2│   │   │⍞000D                         ├──────────┼──────────┼───┼───┼───┼───┼───┼───┼───┼───┤⍞000D   Atanasoff/Berry''s ABC │1942      │1937      │ - │ - │ Y │ - │ - │  2│   │   │⍞000D                         ├──────────┼──────────┼───┼───┼───┼───┼───┼───┼───┼───┤⍞000D                Colossus │1943-04   │          │ - │ Y │ Y │ - │ Y │  2│   │ Y │⍞000D                         ├──────────┼──────────┼───┼───┼───┼───┼───┼───┼───┼───┤⍞000D            Harvard Mk1  │1944-08-07│          │ - │ - │ - │ - │ Y │ 10│   │   │⍞000D                         ├──────────┼──────────┼───┼───┼───┼───┼───┼───┼───┼───┤⍞000D                  ENIAC  │1946-02   │          │ Y │ - │ Y │ Y │ Y │ 10│   │ Y │⍞000D    ┌────┐               ├──────────┼──────────┼───┼───┼───┼───┼───┼───┼───┼───┤⍞000D    │Baby├──────── SSEM  │1948-06-21│          │ Y │ Y │ Y │ Y │ - │  2│ - │   │⍞000D    └────┘               ├──────────┼──────────┼───┼───┼───┼───┼───┼───┼───┼───┤⍞000D                  EDSAC  │1949-05-06│          │ Y │ Y │ Y │ Y │ Y │  2│ - │ Y │⍞000D                         ├──────────┼──────────┼───┼───┼───┼───┼───┼───┼───┼───┤⍞000D            ACE (Pilot)  │1950-05-10│1946-02-19│ Y │ Y │ Y │ Y │ Y │  2│ - │   │⍞000D                         ├──────────┼──────────┼───┼───┼───┼───┼───┼───┼───┼───┤⍞000D                   MESM  │1951-01-04│          │ Y │ Y │ Y │ Y │ Y │  2│   │ Y │⍞000D                         ├──────────┼──────────┼───┼───┼───┼───┼───┼───┼───┼───┤⍞000D                  EDVAC  │1951      │1945-06-30│ Y │ Y │ Y │ Y │ Y │  2│ - │ Y │⍞000D                         ├──────────┼──────────┼───┼───┼───┼───┼───┼───┼───┼───┤⍞000D                 UNIVAC  │1951-03-30│          │ Y │ Y │ Y │ Y │ Y │  2│ Y │ Y │⍞000D                         └──────────┴──────────┴───┴───┴───┴───┴───┴───┴───┴───┘⍞000D                          O          C           G   S   E   T   P   N   M   U⍞000DSSEM References:⍞000D⍞000D    http://www.computer50.org⍞000D    http://en.wikipedia.org/wiki/Manchester_Small-Scale_Experimental_Machine⍞000D    http://www.cs.man.ac.uk/CCS/ssem/progref1.html⍞000D    https://en.wikipedia.org/wiki/Williams_tube⍞000D⍞000DTechnical notes:⍞000D⍞000D[baby] is written in a pure functional style, without variables or side-effects.⍞000DTherefore, it would be possible to transform the code step-by-step into a single⍞000D(albeit  long)  expression,  which  contains no name-assignments or guards; only⍞000Dprimitive  functions,  operators  and  parentheses. See →cmat← for an example of⍞000Dthis process.⍞000D⍞000D(muse:⍞000D    We can view this expression as a mapping from a vector  of machine states to⍞000D    a vector of machine states. The <domain> vector has one item for each of the⍞000D    2*32×32+2  possible  initial  machine  configurations (if we include initial⍞000D    states of CI and A). The considerably shorter <range> vector has an item for⍞000D    each  state in which CI addresses a line containing a <hlt> instruction, to-⍞000D    gether  with  a  single  additional  special state "⊥" ("bottom"), which re-⍞000D    presents non-termination. See →declarative←.⍞000D)⍞000D⍞000DIn  the  interests of authenticity (but at considerable expense to performance),⍞000Dsubsystems of the machine are written to use SSEM-binary values directly, rather⍞000Dthan to cheat by using regular APL numbers. In particular, no use is made of APL⍞000Dprimitive functions ⊤ or ⊥. For example, the <sub> instruction is implemented as⍞000Da binary subtractor, which deals directly with its boolean-vector arguments.⍞000D⍞000DIn fact, the machine has both an adder and a subtractor. As these differ only in⍞000Dtheir bit-manipulation functions ...⍞000D⍞000D    add←{                           ⍝ parallel binary adder.⍞000D        c←⍺∧⍵           ⍝ note ∧    ⍝ carry bits.⍞000D        ~1∊c:⍺∨⍵        ⍝ note ∨    ⍝ no carry bits: done.⍞000D        (⍺≠⍵)∇ 0,¯1↓c               ⍝ shift & add/sub carry bits.⍞000D    }⍞000D⍞000D    sub←{                           ⍝ parallel binary subtractor.⍞000D        c←⍺<⍵           ⍝ note <    ⍝ carry bits.⍞000D        ~1∊c:⍺>⍵        ⍝ note >    ⍝ no carry bits: done.⍞000D        (⍺≠⍵)∇ 0,¯1↓c               ⍝ shift & add/sub carry bits.⍞000D    }⍞000D⍞000D...  we  can  abstract them into a single operator and pass the bit-manipulation⍞000Dfunctions as operands:⍞000D⍞000D    addsub←{                        ⍝ parallel binary adder/subtractor.⍞000D        c←⍺ ⍺⍺ ⍵                    ⍝ carry bits.⍞000D        ~1∊c:⍺ ⍵⍵ ⍵                 ⍝ no carry bits: done.⍞000D        (⍺≠⍵)∇ 0,¯1↓c               ⍝ shift & add/sub carry bits.⍞000D    }⍞000D⍞000Dthen:⍞000D⍞000D    add←∧addsub∨                    ⍝ parallel binary adder.⍞000D    sub←<addsub>                    ⍝ parallel binary subtractor.⍞000D⍞000DFor example:⍞000D⍞000D    1 0 1 0 0 add 0 1 1 0 0         ⍝ 5 + 6 → 11⍞000D1 1 0 1 0⍞000D⍞000D    1 0 1 0 0 sub 0 1 1 0 0         ⍝ 5 - 6 → ¯1⍞000D1 1 1 1 1⍞000D⍞000DWe also need binary successor, predecessor and negation functions:⍞000D⍞000D    inc←{(⍵>∧\⍵)∨<\~⍵}              ⍝ binary successor.⍞000D    dec←{(⍵><\⍵)∨∧\~⍵}              ⍝ binary predecessor.⍞000D    neg←{(⍵<∨\⍵)∨<\⍵}               ⍝ 2s complement negation.⍞000D⍞000D    inc 1 0 1 0 0                   ⍝ 5 +1 → 6⍞000D0 1 1 0 0⍞000D⍞000D    dec 0 1 1 0 0                   ⍝ 6 -1 → 5⍞000D1 0 1 0 0⍞000D⍞000D    neg 1 0 1 0 0                   ⍝ - 5 → ¯5⍞000D1 1 0 1 1⍞000D⍞000D(⍞000D    Notice that <inc> and <dec> could also be abstracted into an incdec operator⍞000D    in a manner similar to addsub:⍞000D⍞000D        incdec←{(⍵>⍺⍺\⍵)∨⍵⍵\~⍵}     ⍝ binary successor/predecessor.⍞000D⍞000D    then:⍞000D⍞000D        inc←∧incdec<                ⍝ binary successor.⍞000D        dec←<incdec∧                ⍝ binary predecessor.⍞000D⍞000D    though it hardly seems worth the abstraction for such small functions.⍞000D)⍞000D⍞000DFinally,  we  need  a "Y-shift" unit, which returns a line-selection mask from a⍞000Dbinary address:⍞000D⍞000D    yshift←(0=⍳⊃⍴⍵)∘{               ⍝ Y-shift: Y-mask from ssem-binary.⍞000D        ~1∊⍵:⍺                      ⍝ 0: done.⍞000D        (¯1⌽⍺)∇ dec ⍵               ⍝ mask shift.⍞000D    }⍞000D⍞000D    yshift 1 0 1 0 0                ⍝ mask for line[5].⍞000D0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D⍞000D(muse:⍞000D⍞000D    For  the  sake  of purity, the code eschews indexed assignment to a variable⍞000D    ("STORE", say) when executing a <sto> instruction. Instead, it uses a rather⍞000D    contorted →at← operator to indicate the new value:⍞000D⍞000D        store←{⍺(⍵ set)msk ⍺⍺}      ⍝ store-matrix ⍺ with ⍵ in line ⍺⍺.⍞000D⍞000D    where:⍞000D⍞000D        msk←(1∨⍵)∘{⍺∧[0]yshift ⍵}   ⍝ mask for line ⍵ of store.⍞000D        set←{(⍺>⍵)∨⍵∧[1]⍺⍺}         ⍝ merge of ⍺ with val ⍺⍺ in line ⍵.⍞000D⍞000D    <store>  takes a store-matrix and new line value as left and right arguments⍞000D    and a line selection as left operand and returns the new store-matrix.⍞000D⍞000D    See operator →at←.⍞000D)⍞000D⍞000DThe coding of the <cmp> function uses an unusual scan {0}\:⍞000D⍞000D        0 1 1≡PI:({0}\⌽A)∇ A CI M           ⍝ cmp: CI+←A<0⍞000D                  ¯¯¯¯⍞000DApplied  between  scalar  arguments, {0} is one of the 16 boolean functions, see⍞000D→truth_tables←.  Applied  to a boolean vector, {0}\ returns a vector of the same⍞000Dlength, duplicating the first item and with all following items, 0.⍞000D⍞000DTherefore, the left argument ({0}\⌽A) of cmp''s recursive call is:⍞000D⍞000D   A negative (ends in 1):  1 0 0 0 ... 0⍞000D   otherwise  (ends in 0):  0 0 0 0 ... 0⍞000D⍞000DNB:  The expression {0}\⌽A is used in spirit of exploration; it is currently im-⍞000Dplemented  in Dyalog as an O(n*2) algorithm and so not recommended when perform-⍞000Dance is an issue. In this case 32↑⊃⌽A would be inordinately faster but not quite⍞000Das "cool".  A further advantage of {0}\⌽ over 32↑⊃⌽ is that,  apart from the in-⍞000Dstruction decode function, baby makes no assumpions about the size of the memory⍞000Dmatrix; this baby will already run 64-bit software!⍞000D⍞000DExamples:⍞000D⍞000D    ⍝ After defining <asm> and <dis> from above:⍞000D⍞000D    prog0                   ⍝ First program to run on the Baby: 1948-06-21⍞000D01 ldn 24⍞000D02 sto 26⍞000D03 ldn 26⍞000D04 sto 27⍞000D05 ldn 23⍞000D06 sub 27⍞000D07 cmp⍞000D08 jrp 20⍞000D09 sub 26⍞000D10 sto 25⍞000D11 ldn 25⍞000D12 cmp⍞000D13 hlt⍞000D14 ldn 26⍞000D15 sub 21⍞000D16 sto 27⍞000D17 ldn 27⍞000D18 sto 26⍞000D19 jmp 22⍞000D20 ¯3⍞000D21  1⍞000D22  4⍞000D23 -2*18⍞000D24 ¯1+2*18⍞000D⍞000D    bin0 ← asm prog0        ⍝ assembled to ssem-binary.⍞000D⍞000D    bin0                    ⍝ ssem-binary is the 32×32 store matrix.⍞000D0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 0 0 1 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 1 0 1 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 1 0 1 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D1 1 0 1 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D1 1 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D1 1 0 1 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D1 0 0 1 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D1 0 0 1 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 1 0 1 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D1 1 0 1 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D1 1 0 1 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 1 0 1 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1⍞000D1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1⍞000D1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D⍞000D    rslt0 ← baby bin0       ⍝ Takes many minutes ...⍞000D⍞000D    rslt0                   ⍝ store dump.⍞000D0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 0 0 1 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 1 0 1 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 1 0 1 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D1 1 0 1 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D1 1 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D1 1 0 1 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D1 0 0 1 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D1 0 0 1 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 1 0 1 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D1 1 0 1 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D1 1 0 1 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 1 0 1 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1⍞000D1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1⍞000D1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1⍞000D0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0⍞000D⍞000D    dis rslt0           ⍝ disassembled result of prog0⍞000D00       0  ⍝ jmp 00⍞000D01   16408  ⍝ ldn 24⍞000D02   24602  ⍝ sto 26⍞000D03   16410  ⍝ ldn 26⍞000D04   24603  ⍝ sto 27⍞000D05   16407  ⍝ ldn 23⍞000D06   32795  ⍝ sub 27⍞000D07   49152  ⍝ cmp⍞000D08    8212  ⍝ jrp 20⍞000D09   32794  ⍝ sub 26⍞000D10   24601  ⍝ sto 25⍞000D11   16409  ⍝ ldn 25⍞000D12   49152  ⍝ cmp⍞000D13   57344  ⍝ hlt⍞000D14   16410  ⍝ ldn 26⍞000D15   32789  ⍝ sub 21⍞000D16   24603  ⍝ sto 27⍞000D17   16411  ⍝ ldn 27⍞000D18   24602  ⍝ sto 26⍞000D19      22  ⍝ jmp 22⍞000D20      ¯3  ⍝ hlt⍞000D21       1  ⍝ jmp 01⍞000D22       4  ⍝ jmp 04⍞000D23 ¯262144  ⍝ jmp 00⍞000D24  262143  ⍝ hlt⍞000D25       0  ⍝ jmp 00⍞000D26 ¯131072  ⍝ jmp 00⍞000D27  131072  ⍝ jmp 00⍞000D28       0  ⍝ jmp 00⍞000D29       0  ⍝ jmp 00⍞000D30       0  ⍝ jmp 00⍞000D31       0  ⍝ jmp 00⍞000D⍞000D      hcf⍞000D ⍝ code:⍞000D01 ldn 30       ⍝ Highest common factor (Tootill 1948).⍞000D02 sto 29       ⍝ http://www.computer50.org/mark1/prog98/intro.html⍞000D03 ldn 31⍞000D04 sto 31⍞000D05 ldn 31⍞000D06 sto 30⍞000D07 ldn 29⍞000D08 sub 30⍞000D09 cmp⍞000D10 jrp 27⍞000D11 sub 31⍞000D12 sto 31⍞000D13 sub 28⍞000D14 cmp⍞000D15 jmp 00⍞000D16 hlt⍞000D ⍝ data:⍞000D27     -3⍞000D28     2⍞000D29     0⍞000D30     3141593  ⍝ input → rslt⍞000D31     5214     ⍝ input⍞000D⍞000D    dis baby asm hcf⍞000D00     0  ⍝ jmp 00⍞000D01 16414  ⍝ ldn 30⍞000D02 24605  ⍝ sto 29⍞000D03 16415  ⍝ ldn 31⍞000D04 24607  ⍝ sto 31⍞000D05 16415  ⍝ ldn 31⍞000D06 24606  ⍝ sto 30⍞000D07 16413  ⍝ ldn 29⍞000D08 32798  ⍝ sub 30⍞000D09 49152  ⍝ cmp⍞000D10  8219  ⍝ jrp 27⍞000D11 32799  ⍝ sub 31⍞000D12 24607  ⍝ sto 31⍞000D13 32796  ⍝ sub 28⍞000D14 49152  ⍝ cmp⍞000D15     0  ⍝ jmp 00⍞000D16 57344  ⍝ hlt⍞000D17     0  ⍝ jmp 00⍞000D18     0  ⍝ jmp 00⍞000D19     0  ⍝ jmp 00⍞000D20     0  ⍝ jmp 00⍞000D21     0  ⍝ jmp 00⍞000D22     0  ⍝ jmp 00⍞000D23     0  ⍝ jmp 00⍞000D24     0  ⍝ jmp 00⍞000D25     0  ⍝ jmp 00⍞000D26     0  ⍝ jmp 00⍞000D27    ¯3  ⍝ hlt⍞000D28     2  ⍝ jmp 02⍞000D29  ¯237  ⍝ hlt⍞000D30    79  ⍝ jmp 15⍞000D31     0  ⍝ jmp 00⍞000D⍞000D    ⍝ For more sample Baby programs, see:⍞000D    ⍝ test script ##.scripts.baby and⍞000D    ⍝ http://www.computer50.org/mark1/prog98/prizewinners.html⍞000D⍞000DSee also: at truth_tables bf lisp⍞000D⍞000DIndex:SSEM|computer, first|assembler|disassembler|diversions|bottom ⊥|Baby⍞000DIndex:turing complete|non-termination|pure function|Manchester computer⍞000DIndex:UNIVAC|EDVAC|MESM|ACE|EDSAC|ENIAC|Harvard Mk1|Colossus|ABC|Zuse Z3⍞000DIndex:at⍞000DIndex;Kilburn T.|Williams F.C.|Tootill G.C.|Turing A.M.|Babbage C.|Schickard.W.' 
