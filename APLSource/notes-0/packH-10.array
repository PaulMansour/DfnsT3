'cmp ← {cmp←1} ##.packH exp                  ⍝ Huffman packing.⍞000D⍞000DHuffman''s  algorithm  builds  a binary tree of unique items in the input string,⍞000Dusing  the  items''  frequency  of occurrence as a weighting. Frequently occuring⍞000Ditems  are  placed near the root of the tree and those less frequent towards the⍞000Dleaves. For example, using the string ''Mississippi'':⍞000D⍞000D    Original string:    M i s s i s s i p p i⍞000D    unique items:       M i s p⍞000D    item frequency:     1 4 4 2⍞000D⍞000D    Huffman tree:       ┌──┴──┐⍞000D                        s   ┌─┴──┐⍞000D                        4 ┌─┴─┐  i⍞000D                          M   p  4⍞000D                          1   2⍞000D⍞000DAn item may then be picked from the tree using binary code: 0:left, 1:right. For⍞000Dexample, in the above tree ''M'' is at (1 0 0), ''i'' is at (1 1) and ''s'' is at (0).⍞000DThe full coding for ''Mississippi'' is the concatenation of codes:⍞000D⍞000D     M       i     s   s   i     s   s   i     p       p       i⍞000D    (1 0 0) (1 1) (0) (0) (1 1) (0) (0) (1 1) (1 0 1) (1 0 1) (1 1)⍞000D⍞000D=>  1 0 0 1 1 0 0 1 1 0 0 1 1 1 0 1 1 0 1 1 1⍞000D⍞000DChoosing  the shortest codes for the most frequently occurring items, guarantees⍞000Dthat the total code length is optimally short.⍞000D⍞000DNotice  that no separation marker is needed between successive code items in the⍞000Doutput "bit string" as the length of each is determined by the path it describes⍞000Dfrom  the  root  of the tree to its leaf. On expansion, bits are taken one-at-a-⍞000Dtime  from  the input bit stream, to navigate through the tree. Each time a leaf⍞000Dis  encountered, it is emitted to the output stream and the process resumed with⍞000Dthe following bit, starting from the tree''s root.⍞000D⍞000DOutput  from  the encoding is the bit string, together with its Huffman tree. In⍞000Daddition,  in  order  to allow simple arrays of _any_ rank, the subject array is⍞000Dravelled, with its original shape prefixed to the output structure.⍞000D⍞000DTechnical notes:⍞000D⍞000DThe nested array form of the Huffman tree could be included directly in the out-⍞000Dput  structure,  but  there are more space-efficient representations. An obvious⍞000Done  is  to emit the vector of unique items and its corresponding frequency vec-⍞000Dtor.  This  is  appealing in that the sub-function that builds the tree from the⍞000Dfrequency  vector  may be used for both compression and expansion, and so may be⍞000Dincluded in the packH capsule as a common local function.⍞000D⍞000DUsing this method, the output would look like this:⍞000D⍞000D        packH''Mississippi''⍞000D    ┌──┬────┬───────┬─────────────────────────────────────────┐⍞000D    │11│Misp│1 4 4 2│1 0 0 1 1 0 0 1 1 0 0 1 1 1 0 1 1 0 1 1 1│⍞000D    └──┴────┴───────┴─────────────────────────────────────────┘⍞000D⍞000DHowever, for an array where any item occurs more than 127 times, elements of the⍞000Dfrequency vector will occupy 16 bits apiece (and 32 bits if any item occurs more⍞000Dthan  32,767  times).  A more frugal method is to output the tree''s [leaves] and⍞000D[depths]  vectors.  For  all  pratical purposes, items of the depths vector will⍞000Dconsume only 8 bits each.⍞000D⍞000D        packH''Mississippi''⍞000D    ┌──┬────┬───────┬─────────────────────────────────────────┐⍞000D    │11│sMpi│1 3 3 2│1 0 0 1 1 0 0 1 1 0 0 1 1 1 0 1 1 0 1 1 1│⍞000D    └──┴────┴───────┴─────────────────────────────────────────┘⍞000D⍞000DA  Huffman  tree has the property that each node has either 0 or 2 sub-trees. It⍞000Dis  this  property that allows us to reconstruct the tree unambiguously from the⍞000Ddepths  of  its  leaves.  For  example, there are only four such distinct 4-leaf⍞000Dtrees, and they have distinct leaf-depth vectors.⍞000D⍞000D    4-leaf trees:       ┌─∘┐         ┌─∘──┐       ┌─∘─┐        ┌─∘─┐⍞000D                      ┌─∘┐ D        ┌∘─┐  D       A  ┌∘─┐      A ┌─∘┐⍞000D                     ┌∘┐ C          A ┌∘┐           ┌∘┐ D        B ┌∘┐⍞000D                     A B              B C           B C            C D⍞000D    leaf depths:     3 3 2 1        2 3 3 1       1 3 3 2      1 2 3 3⍞000D⍞000DIn contrast, leaf-depth can not distinguish more general binary trees:⍞000D⍞000D    2-leaf trees:     ┌∘┐          ┌∘─┐⍞000D                     ┌∘ B          ∘┐ B⍞000D                     A              A⍞000D    leaf depths:     2  1           2 1⍞000D⍞000DAs  a  larger  example, look at the following (approximate (*)) Huffman tree for⍞000Dthese  notes, with character ''·'' substituted for blanks and newlines. Notice how⍞000Dthe  most  frequently  occurring  character  ''·''  is allocated code (0) and that⍞000Dgroups  of related characters such as ''()'', ''{}'', ''[]'', ''├ ┼ ┤'', ''┌ ┐'' and ''└ ┘''⍞000Dtend to appear at the same depth in the tree. Notice also, how the very presence⍞000Dof  this  tree  diagram in the notes has forced the ''─'' character up to position⍞000D(1 0 0) in itself.⍞000D⍞000D┌┴───────────────────────────────────────────────────────────────────────────────────────────────────────────────┐⍞000D·  ┌─────────────────────────────────────────────────────────────────────────────────────────────────────────────┴─────────────────────────────────────────────────────────┐⍞000D  ┌┴───────────────────────────────────────────────────────────────────────────────────────┐                                                                     ┌─────────┴─────────────────────────┐⍞000D  ─                      ┌─────────────────────────────────────────────────────────────────┴───────────────────┐                                   ┌─────────────┴───┐                             ┌─┴───────────────────────────────┐⍞000D     ┌───────────────────┴─┐                                                                     ┌─────────────┴┐                          ┌───────┴─┐             ┌─┴───┐   ┌─────────────────────┴┐    ┌───────────────────────────┴─┐⍞000D    ┌┴───────────┐        ┌┴───────────────────┐                                             ┌───┴─┐            t    ┌─────────────────────┴─┐      ┌┴─┐          ┌┴┐  ┌─┴┐ ┌┴───────────────────┐  e  ┌─┴─┐                          ┌┴┐⍞000D    c          ┌─┴─┐      h  ┌─────────────────┴───────────────────────┐                    ┌┴─┐  ┌┴─────────┐     ┌─┴───────┐              ┌┴─┐    o ┌┴─┐        │ n ┌┴┐ r a        ┌───────────┴┐   ┌┴┐ ┌┴───────────────────┐      s i⍞000D         ┌─────┴┐ ┌┴───┐    ┌┴─────┐                                 ┌─┴─────────────────┐  1 ┌┴┐ m    ┌─────┴┐   ┌┴┐      ┌─┴───────────┐  f ┌┴─┐    u ┌┴─────┐      l ┴          ┌─┴─┐          ┐   ┌ p d  ┌─────────────────┴─┐⍞000D       ┌─┴───┐  y v  ┌─┴┐   b  ┌───┴───┐               ┌─────────────┴┐                ┌─┴┐   0 →    ┌─┴─┐    .   , -    ┌─┴┐          ┌─┴┐   '' ┌┴┐     g  ┌───┴┐              ┌───┴┐ ┌┴─┐                  ┌┴─────────┐        ┌┴─┐⍞000D      ┌┴┐  ┌─┴┐     ┌┴┐ 3     ┌┴─┐   ┌─┴───┐       ┌───┴─────┐        x        ┌───────┴┐ w         ┌┴┐ ┌┴─┐           ┌─┴┐ M      ┌───┴┐ 2     └ ┘       ┌┴─┐  ⍝             ┌┴─┐  ( ) ┌┴───┐              :        ┌─┴─────┐  ┬ ┌┴┐⍞000D      } ↑ ┌┴┐ 4     ↓ ¯       A ┌┴┐ ┌┴┐  ┌─┴─┐   ┌─┴─┐   ┌───┴───┐         ┌───┴───┐    j           ⍺ T ⊃ ┌┴┐         ┌┴┐ ∘      ┌─┴─┐  H                 > ┌┴┐               k ┌┴┐     q  ┌─┴─┐                 ┌───┴┐    ┌─┴┐   ⍵ +⍞000D          B ≡                   F C D ⌽ ┌┴┐ ┌┴┐ ┌┴┐ ┌┴┐ ┌┴─┐   ┌─┴─┐     ┌─┴─┐   ┌─┴─┐                    " ├         ┼ ┤      ┌─┴┐ ┌┴┐                     = ~                 ⍉ ←       ┌┴┐ ┌┴┐              ┌─┴─┐  <  ┌─┴┐ {⍞000D                                        N E * [ ] \ R 9 S ┌┴┐ ┌┴┐ ┌┴┐   ┌┴┐ ┌┴┐ ┌┴┐ ┌┴┐                                       ┌┴┐ O 7 ⍬                                                   ⊂ ¨ / ∇             ┌┴┐ ┌┴┐   ┌┴┐ I⍞000D                                                          # ! ⍨ W ⍋ ⊥   ⍳ ; 5 _ ⍪ ⎕ ∨ ⍕                                       × |                                                                             U 6 8 ⍴   ≠ P⍞000D⍞000D(*)  The  tree  is approximate, because inserting it into the notes, changes the⍞000Dnotes''  Huffman  tree slightly (as does adding this comment). Several iterations⍞000Dof  recalculating  and replacing the tree resulted in a loop of several distinct⍞000Dtrees, of which the above is one. Therefore, the above tree _does not_ represent⍞000Dthese notes exactly unless adding this final remark happens to cause the iterat-⍞000Dions to converge! The tree was formatted using:⍞000D⍞000D    hfmt←{                                                ⍝ Format Huffman tree.⍞000D        join←{⍵⍪⍉↑↑{⍺,'' '',⍵}/↓∘⍉¨⍺}                       ⍝ join sub-trees.⍞000D        arch←{⍺⍺ ⍺[⎕IO+{⍵+∨\⍵}⍺⍺''┴''=⊃↓⍵]}                 ⍝ make ┌─┴─┐ archway.⍞000D        0=≡⍵:↑,↓⍕,⍵                                       ⍝ leaf: char mat.⍞000D        lft rgt←∇¨⍵                                       ⍝ sub-trees and their,⍞000D        case←×|≡¨⍵                                        ⍝ relative depths:⍞000D        0 0≡case:lft rgt join''┌┴┐''                        ⍝ leaf-leaf,⍞000D        0 1≡case:lft rgt join''┌┴'','' ─┐''⌽arch rgt          ⍝ leaf-branch,⍞000D        1 0≡case:lft rgt join''┴┐'',⍨'' ─┌''+arch lft         ⍝ branch-leaf,⍞000D        lft rgt join('' ─┌''+arch lft),''┴'','' ─┐''⌽arch rgt   ⍝ branch-branch.⍞000D    }⍞000D⍞000D-----------⍞000Dcompression⍞000D-----------⍞000DThe  tree  is  built  by taking the two most infrequently occurring items in the⍞000Dunique  list  and  replacing them with a single item: their "pair" together with⍞000Dthe  sum of their frequencies. This process is repeated until only a single item⍞000Dremains:⍞000D⍞000D        tree←{                          ⍝ Huffman tree.⍞000D            1=⍴⍵:⊃⌽⊃⍵                   ⍝ list exhausted: done⍞000D            nxt←⍵[2↑⍋⊃¨⍵]               ⍝ next two lowest frequencies,⍞000D            freqs items←↓⍉↑nxt          ⍝ and corresponding items.⍞000D            ∇(⍵~nxt),⊂(+/freqs),⊂items  ⍝ collect 2 most infrequent items.⍞000D        }↓⍉↑freq uniq                   ⍝ tree from frequency-item pairs.⍞000D⍞000D ┌→──┬───┬───┬───┐    ┌→──┬───┬──────┐    ┌→──┬──────────┐    ┌→──────────────┐⍞000D │1 M│4 i│4 s│2 p│ => │   │   │┌→┬──┐│ => │   │┌→┬──────┐│ => │┌→─┬──────────┐│⍞000D └+─→┴+─→┴+─→┴+─→┘    │4 i│4 s││3│Mp││    │   ││ │┌→─┬─┐││    ││  │┌→┬──────┐││⍞000D                      │   │   │└─┴─→┘│    │4 s││7││Mp│i│││    ││  ││ │┌→─┬─┐│││⍞000D                      └+─→┴+─→┴─────→┘    │   ││ │└─→┴─┘││    ││11││s││Mp│i││││⍞000D                                          │   │└─┴─────→┘│    ││  ││ │└─→┴─┘│││⍞000D                 ┌→┬──────┐               └+─→┴─────────→┘    ││  │└─┴─────→┘││⍞000D yielding tree:  │ │┌→─┬─┐│                                   │└~─┴─────────→┘│⍞000D                 │s││Mp│i││                                   └──────────────→┘⍞000D                 │ │└─→┴─┘│⍞000D                 └─┴─────→┘⍞000D⍞000DThe  leaves and depths vectors are extracted from the tree by a simple recursive⍞000Dtraversal.⍞000D⍞000D        leaves depths←↓⍉↑tree{      ⍝ tree leaves and depths.⍞000D            ⍬≡⍴⍺:⊂⍺ ⍵               ⍝ leaf: leaf and depth.⍞000D            ↑,/⍺ ∇¨1+⍵              ⍝ branch: traverse deeper sub-branches.⍞000D        }0                          ⍝ starting at depth 0 for the root.⍞000D⍞000D---------⍞000Dexpansion⍞000D---------⍞000DThe  tree  is  restored from its [depths] and [leaves] vectors with a single re-⍞000Dductive  pass  across their transpose [depth-leaf] vector. During the reduction,⍞000Dthe  operand function examines adjacent nodes, replacing ones of identical depth⍞000Dwith a new pair of depth less by 1. The reduction is "seeded" with a dummy depth⍞000Dof ¯1 on the right. Using the ''Mississippi'' example:⍞000D⍞000D        depths leaves               ⍝ depths and leaves vectors.⍞000D    ┌───────┬────┐⍞000D    │1 3 3 2│sMpi│⍞000D    └───────┴────┘⍞000D⍞000D        ↓⍉↑depths leaves            ⍝ depth-leaf vector.⍞000D    ┌───┬───┬───┬───┐⍞000D    │1 s│3 M│3 p│2 i│⍞000D    └───┴───┴───┴───┘⍞000D⍞000D    tree←⍬ 0 1⊃{                    ⍝ reconstituted Huffman tree.⍞000D        (⊃⍺)≠⊃⊃⍵:(⊂⍺),⍵             ⍝ distinct adjacent depths: continue.⍞000D        (⌽{⊃⍵-1}\⌽↓⍉↑⍺(⊃⍵))∇ 1↓⍵    ⍝ identical adjacent depths: coalesce.⍞000D    }/(↓⍉↑depths leaves),¯1         ⍝ depths/leaves ++ trailing dummy entry.⍞000D⍞000DThe  first  line  skips over (or accumulates into the result,) adjacent items if⍞000Dtheir depths differ:⍞000D⍞000D        (⊃⍺)≠⊃⊃⍵:(⊂⍺),⍵             ⍝ distinct adjacent depths: continue.⍞000D⍞000DThe  second  line  calls  the operand function recursively for adjacent items of⍞000Didentical depth. We can break open the line to examine its constituent parts:⍞000D⍞000D        (·················)∇ 1↓⍵    ⍝ repeat with adjacent nodes coalesced.⍞000D        ·············⍺(⊃⍵)······    ⍝ pair of adjacent same-depth tree nodes.⍞000D        ··········↓⍉↑···········    ⍝ => (depth depth) (node node)⍞000D        ·⌽{····}\⌽··············    ⍝ apply to _first_ item of pair.⍞000D        ···⊃⍵-1·················    ⍝ reduced depth⍞000D        ························    ⍝ => (depth-1)(node node)⍞000D⍞000DThe ''Mississippi'' example proceeds through the reduction as follows:⍞000D⍞000D                     ┌────────────────  ⍝ adjacent depths:⍞000D                  ┌──┴───┐⍞000D    ┌───┬───┬───┬─↓─┐  ┌─↓─┐⍞000D    │ 1 │ 3 │ 3 │ 2 │  │¯1 │            ⍝ depths 2 ¯1 distinct: continue.⍞000D    │ s │ M │ p │ i │  │   │⍞000D    └───┴───┴───┴───┘  └───┘⍞000D⍞000D        ┌───┬───┬───┐  ┌───┬───┐⍞000D        │ 1 │ 3 │ 3 │  │ 2 │¯1 │        ⍝ depths 3 2  distinct: continue.⍞000D        │ s │ M │ p │  │ i │   │⍞000D        └───┴───┴───┘  └───┴───┘⍞000D⍞000D            ┌───┬───┐  ┌───┬───┬───┐⍞000D            │ 1 │ 3 │  │ 3 │ 2 │¯1 │    ⍝ depths 3 3 same: pair ''M'' ''p''⍞000D            │ s │ M │  │ p │ i │   │⍞000D            └───┴───┘  └───┴───┴───┘⍞000D⍞000D            ┌───┬───┐  ┌───┬───┐⍞000D            │ 1 │ 2 │  │ 2 │¯1 │        ⍝ depths 2 2 same: pair ''Mp'' ''i''⍞000D            │ s │┌┴┐│  │ i │   │⍞000D            │   │M p│  └───┴───┘⍞000D            └───┴───┘⍞000D⍞000D          ┌───┬─────┐  ┌───┐⍞000D          │ 1 │   1 │  │¯1 │            ⍝ depths 1 ¯1 distinct: continue.⍞000D          │ s │ ┌─┴┐│  │   │⍞000D          │   │┌┴┐ i│  └───┘⍞000D          │   │M p  │⍞000D          └───┴─────┘⍞000D⍞000D                ┌───┐  ┌─────┬───┐⍞000D                │ 1 │  │   1 │¯1 │      ⍝ depths 1 1 same: pair ''s''(''Mp'' ''i'')⍞000D                │ s │  │ ┌─┴┐│   │⍞000D                └───┘  │┌┴┐ i│   │⍞000D                       │M p  │   │⍞000D                       └─────┴───┘⍞000D⍞000D            ┌───────┐  ┌───┐⍞000D            │ 0     │  │¯1 │            ⍝ depths 0 ¯1 distinct: continue,⍞000D            │┌┴───┐ │  │   │⍞000D            │s  ┌─┴┐│  └───┘⍞000D            │  ┌┴┐ i│⍞000D            │  M p  │⍞000D            └───────┘⍞000D⍞000D                       ┌───────┬───┐⍞000D                       │ 0     │¯1 │    ⍝ reduction complete.⍞000D                       │┌┴───┐ │   │⍞000D                       │s  ┌─┴┐│   │⍞000D                       │  ┌┴┐ i│   │⍞000D                       │  M p  │   │⍞000D                       └───────┴───┘⍞000D⍞000DThe  tree  is extracted from the final (scalar) result of the (vector) reduction⍞000Dusing (⍬ 0 1⊃)⍞000D⍞000D            ┌───────────────────┐⍞000D            │┌→─────────────┬──┐│⍞000D            ││┌→┬──────────┐│  ││⍞000D            │││ │┌→┬──────┐││  ││      ┌→┬──────┐⍞000D            │││ ││ │┌→─┬─┐│││  ││      │ │┌→─┬─┐│⍞000D {⍬ 0 1⊃⍵}  │││0││s││Mp│i││││¯1││  =>  │s││Mp│i││⍞000D            │││ ││ │└─→┴─┘│││  ││      │ │└─→┴─┘│⍞000D            │││ │└─┴─────→┘││  ││      └─┴─────→┘⍞000D            ││└─┴─────────→┘│  ││⍞000D            │└─────────────→┴~─┘│⍞000D            └──────────────────→┘⍞000D⍞000DHaving  reconstructed  the Huffman tree, the bit-stream is traversed to retrieve⍞000Dthe  original items. A potential performance bottleneck for the unpacking funct-⍞000Dion, is that the algorithm accesses one bit at a time, using consecutive bits to⍞000Dtraverse the tree. An alternative approach is to construct a dictionary that can⍞000Dbe  indexed by the (2∘⊥) of a number of consecutive bits at once. If the maximum⍞000Ddepth  of the tree is [maxd], then a dictionary of (2*maxd) entries will have an⍞000Dentry  for  any  possible  value of [maxd] bits taken from the input string. For⍞000D_short_ paths through the tree (for example, to the ''s'' of ''Mississippi''), dict-⍞000Dionary  entries  are duplicated. Each dictionary entry contains the value of its⍞000Dleaf,  and the number of bits required to reach it, and hence to skip in the in-⍞000Dput  stream.  The  input stream is padded with [maxd] dummy bits, to prevent the⍞000Dfinal indexing operation from failing.⍞000D⍞000D        dict⍞000D    ┌───┬───┬───┬───┬───┬───┬───┬───┐⍞000D    │1 s│1 s│1 s│1 s│3 M│3 p│2 i│2 i│⍞000D    └───┴───┴───┴───┴───┴───┴───┴───┘⍞000D⍞000DPrefixing bit string values for each entry:⍞000D⍞000D        ⍉↑(,⍳2 2 2)dict⍞000D    ┌─────┬───┐⍞000D    │0 0 0│1 s│⍞000D    ├─────┼───┤⍞000D    │0 0 1│1 s│⍞000D    ├─────┼───┤⍞000D    │0 1 0│1 s│⍞000D    ├─────┼───┤⍞000D    │0 1 1│1 s│⍞000D    ├─────┼───┤⍞000D    │1 0 0│3 M│⍞000D    ├─────┼───┤⍞000D    │1 0 1│3 p│⍞000D    ├─────┼───┤⍞000D    │1 1 0│2 i│⍞000D    ├─────┼───┤⍞000D    │1 1 1│2 i│⍞000D    └─────┴───┘⍞000D⍞000DRef: David A. Huffmann, "A Method for the Construction of Minimum-Redundancy⍞000DCodes," Proc. IRE, vol. 40, no. 9, pp. 1098-1101; September, 1952.⍞000D⍞000DSee also: Data_compression morse⍞000D⍞000DIndex:packing|compression⍞000DIndex;Huffman D.' 
