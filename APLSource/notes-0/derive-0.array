'Mechanical Transformation of Simple D-functions into Derived Functions      <V>⍞000D----------------------------------------------------------------------⍞000DThe following functions are said to be "extensionally equal" as, given any array⍞000Dargument, each returns the same result.⍞000D⍞000D    {⍬⍴⍴⍵}      ⍝ D-function for first-of-shape.⍞000D⍞000D    ⍬∘⍴∘⍴       ⍝ Derived function for first-of-shape.⍞000D⍞000DFor very small functions, either coding may be appropriate, though for more com-⍞000Dplex ones, the first style is probably preferable.⍞000D⍞000DHaving  said  this,  it is possible to prescribe a set of rules for transforming⍞000D(a subset of) simple monadic D-functions into derived functions.⍞000D⍞000DNB:  There seems to be little practical value in performing this transformation,⍞000Dother than  as an entertainment.  One possible exception is that primitive power⍞000Doperator ⍣ may derive the inverse of a derived function, whereas D-functions are⍞000Dnot currently admitted.                                                     <V>⍞000D⍞000DThe  following  rules may be applied repeatedly to transform a simple monadic D-⍞000Dfunction into a derived function:⍞000D⍞000D    [0]     { f ⍵} → f⍞000D    [1]     a f ⍵} → a∘f ⍵}⍞000D    [2]     ⍵ f a} → (f∘a) ⍵}⍞000D    [3]     ⍵ f ⍵} → f⍨ ⍵}⍞000D    [4]     f f ⍵} → f∘f ⍵}⍞000D    [5]     f f a} → f (f a)⍞000D    [6]   (X) f ⍵} → ⍵ f⍨ X}⍞000D    [7]   (X) f a} → (f∘a) X}⍞000D⍞000Dwhere:⍞000D⍞000D    a is an array⍞000D    f is a (possibly derived) function⍞000D    X is an array-returning expression⍞000D⍞000DIn  the  following  examples  "n→"  means "transforms using rule[n] to:" and the⍞000Dpattern of the underlined tokens selects which rule to apply next.⍞000D               ¯¯¯¯¯¯¯¯¯¯⍞000D        {(⊂⍋⍵)⌷⍵}           ⍝ sort (Phil Last)⍞000D         ¯¯¯¯¯¯¯¯⍞000D    6→  {⍵⌷⍨⊂⍋⍵}⍞000D            ¯¯¯¯⍞000D    4→  {⍵⌷⍨⊂∘⍋⍵}⍞000D          ¯¯¯¯¯¯¯⍞000D    4→  {⍵⌷⍨∘⊂∘⍋⍵}⍞000D         ¯¯¯¯¯¯¯¯¯⍞000D    3→  {⌷⍨∘⊂∘⍋⍨⍵}⍞000D        ¯¯¯¯¯¯¯¯¯¯⍞000D    0→   ⌷⍨∘⊂∘⍋⍨⍞000D⍞000D⍞000D        {(+/⍵)÷⍴⍵}          ⍝ mean item of vector ⍵⍞000D              ¯¯¯¯⍞000D    4→  {(+/⍵)÷∘⍴⍵}⍞000D         ¯¯¯¯¯¯¯¯¯¯⍞000D    6→  {⍵ ÷∘⍴⍨ +/ ⍵}⍞000D           ¯¯¯¯¯¯¯¯¯¯⍞000D    4→  {⍵ ÷∘⍴⍨∘(+/) ⍵}⍞000D         ¯¯¯¯¯¯¯¯¯¯¯¯¯¯⍞000D    3→  {÷∘⍴⍨∘(+/)⍨⍵}⍞000D        ¯¯¯¯¯¯¯¯¯¯¯¯¯⍞000D    0→   ÷∘⍴⍨∘(+/)⍨⍞000D⍞000DRegarding rule [6]:  if expression X in (X) does not include an occurrence of ⍵,⍞000Dan optimisation is to apply rule [1] instead.  This generally leads to a simpler⍞000Dderived  function  (although  see the section on optimisation in "Extensions and⍞000DRestrictions" below):⍞000D⍞000D        {(⊂⍬),⍵}        ⍝ (⊂⍬) does not contain ⍵, so apply rule [1].⍞000D         ¯¯¯¯¯¯¯⍞000D    1→  {(⊂⍬)∘,⍵}⍞000D         ¯¯¯¯¯¯¯¯⍞000D    0→   (⊂⍬)∘,⍞000D⍞000Das opposed to:⍞000D⍞000D        {(⊂⍬),⍵}        ⍝ ignore optimisation: apply rule [6].⍞000D         ¯¯¯¯¯¯¯⍞000D    6→  {⍵,⍨⊂⍬}⍞000D          ¯¯¯¯¯⍞000D    5→  {⍵,⍨(⊂⍬)}⍞000D         ¯¯¯¯¯¯¯¯⍞000D    2→  {(,⍨∘(⊂⍬))⍵}⍞000D        ¯¯¯¯¯¯¯¯¯¯¯¯⍞000D    0→    ,⍨∘(⊂⍬)⍞000D⍞000DPrior to the transformations, the D-function must be pre-processed to remove:⍞000D⍞000D[1] array strands that include an ⍵:⍞000D⍞000D    ... A ⍵ B ... → ... (⊂A),(⊂⍵),(⊂B) ...⍞000D⍞000D    For example:⍞000D⍞000D        {⍵ ⍵}               ⍝ dup[licate]⍞000D         ¯¯¯⍞000D     →  {(⊂⍵),⊂⍵}⍞000D             ¯¯¯¯⍞000D    4→  {(⊂⍵),∘⊂⍵}⍞000D         ¯¯¯¯¯¯¯¯¯⍞000D    6→  {⍵,∘⊂⍨⊂⍵}⍞000D          ¯¯¯¯¯¯¯⍞000D    4→  {⍵,∘⊂⍨∘⊂⍵}⍞000D         ¯¯¯¯¯¯¯¯¯⍞000D    3→  {,∘⊂⍨∘⊂⍨⍵}⍞000D        ¯¯¯¯¯¯¯¯¯¯⍞000D    0→   ,∘⊂⍨∘⊂⍨⍞000D⍞000D[2] square-brackets:⍞000D⍞000D    A[B;C] → B C ⌷ A        ⍝ index brackets⍞000D⍞000D    ↓[1] ... → ↓⍉ ...       ⍝ axis brackets⍞000D⍞000DThere is a larger example towards the end of ##.scripts.dft⍞000D⍞000DRestrictions and Extensions⍞000D---------------------------⍞000D[1] This  process doesn''t cope with an expression that contains ⍵ as the operand⍞000D    of an operator:⍞000D⍞000D        {(⊂⍣⍵)''Doh''}⍞000D⍞000D[2] Nor will it transform a recursive call ∇.  Although it seems likely (to JMS)⍞000D    that  rules  might  be discovered for replacing some cases of recursion with⍞000D    the power operator ⍣.⍞000D⍞000D[3] For multi-line dfns,  Phil Last has shown us how to transform a guard into a⍞000D    simple expression using /. See, for example →pow← and →cond←.⍞000D⍞000D        [8] C:T⋄F}  →  ⊃{F}/(⍳~C),{T}/(⍳C),⊂⍵}⍞000D⍞000D    where C, T and F are expressions. Unfortunately, guard expression C is eval-⍞000D    uated twice.⍞000D⍞000D    (muse:⍞000D⍞000D        There was overwhelming cultural pressure, in the specification of primi-⍞000D        tive power operator ⍣, for the "repeat count" to be the right _operand_.⍞000D⍞000D        Had  the  repeat count been assigned to the left _argument_ of a monadic⍞000D        operator, as in →pow←, rule [8] could have been the simplified slightly:⍞000D⍞000D        [8] C:T⋄F}  →  (~C){F}⍣ C{T}⍣ ⍵}⍞000D⍞000D        Oh, and the _monadic_ derived function could have been "fixpoint":⍞000D⍞000D            1∘+∘÷ ⍣ 1       ⍝ 1+÷ 1+÷ ... 1⍞000D        1.618033989⍞000D    )⍞000D⍞000DDyadic Functions⍞000D----------------⍞000DIn the absence of Hooks and Forks, the best plan appears to be to convert dyadic⍞000Dfunctions into monadic equivalents by passing left and right arguments as a pair⍞000Dand referencing them from within the function as (⊃⍵) and (⊃⌽⍵).  If the subject⍞000Dfunction is applied under an operator, the argument-pair array must be  prepared⍞000Daccordingly:⍞000D⍞000DX {...⍺...⍵...} Y   →  {...(⊃⍵)...(⊃⌽⍵)...} X Y             ⍝ simply applied fn.⍞000DX {...⍺...⍵...}¨ Y  →  {...(⊃⍵)...(⊃⌽⍵)...}¨ (⊂¨X) ,¨ ⊂¨Y   ⍝ applied with each.⍞000DX ∘.{...⍺...⍵...} Y →  {...(⊃⍵)...(⊃⌽⍵)...}¨ (⊂¨X) ∘., ⊂¨Y  ⍝ outer product.⍞000D...etc.⍞000D⍞000DOptimisation⍞000D------------⍞000DIt  might be interesting to provide a second set of post-transformation optimis-⍞000Dation rules such as:⍞000D⍞000D    [o1]    f⍨⍨     → f⍞000D    [o2]    f⍨∘a    → a∘f⍞000D    [o3]    a∘(f⍨)  → f∘a⍞000D    ...⍞000D⍞000DRule [o2] would render choosing between rules [1] and [6], in the case (a) f ⍵},⍞000Dunnecessary as either would (eventually) produce the same result:⍞000D⍞000D        {(⊂⍬),⍵}        ⍝ (⊂⍬) does not contain ⍵, so apply rule [1].⍞000D         ¯¯¯¯¯¯¯⍞000D    1→  {(⊂⍬)∘,⍵}⍞000D         ¯¯¯¯¯¯¯¯⍞000D    0→   (⊂⍬)∘,⍞000D⍞000Das opposed to:⍞000D⍞000D        {(⊂⍬),⍵}        ⍝ ignore optimisation: apply rule [6].⍞000D         ¯¯¯¯¯¯¯⍞000D    6→  {⍵,⍨⊂⍬}⍞000D          ¯¯¯¯¯⍞000D    5→  {⍵,⍨(⊂⍬)}⍞000D         ¯¯¯¯¯¯¯¯⍞000D    2→  {(,⍨∘(⊂⍬))⍵}⍞000D        ¯¯¯¯¯¯¯¯¯¯¯¯⍞000D    0→    ,⍨∘(⊂⍬)⍞000D          ¯¯¯¯¯¯¯⍞000D    o2→  (⊂⍬)∘,         ⍝ (same derived function as above)⍞000D⍞000DSee also: dft trains⍞000D⍞000DIndex:derived function|expression transformation|transformation, expression⍞000DIndex:hook|fork|fixpoint⍞000D⍞000DIndex;Last P.' 
