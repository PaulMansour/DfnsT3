'list ← ##.list vect                     ⍝ list from vector ⍵.⍞000Drslt ← init (acc ##.ltrav) list         ⍝ List traversal.⍞000D⍞000DFunction [list] takes a vector as right argument and returns a list.⍞000D⍞000DOperator  [ltrav]  takes  a dyadic [acc]umulating function as left operand, with⍞000Dan  initial  accumulator value of [init] as left argument. The right argument is⍞000Dthe subject [list].⍞000D⍞000DBackground⍞000D----------⍞000DAPL is pre-eminent when it comes to the processing of arrays. Occasionally, how-⍞000Dever  we encounter a task where the value of the first of a number of items det-⍞000Dermines  how  we  are to interpret any remaining ones. In this case, it might be⍞000Dworth  considering representing the items as a list, rather than as a vector. An⍞000Dexample might be in writing a parser for a sequence of expression tokens.⍞000D⍞000DDefinition: A List-of-⍺-s is either Null or a Pair (Head Tail), where Head is an⍞000D⍺ and Tail is a  List-of-⍺-s. More succinctly:⍞000D⍞000D    List ⍺ ::= Null | Pair ⍺ (List ⍺)⍞000D⍞000DPair is sometimes called "Cons", short for "list constructor".⍞000D⍞000DWe  use a nested 2-vector to implement a list with a special value ''∘'' for Null.⍞000DNote  that the choice of ''∘'' for Null is arbitrary and could just as well be any⍞000Dspecific array value, including a 2-vector!⍞000D⍞000DIn general, a list has many of the properties of an APL vector, except that:⍞000D⍞000D    Separating the first from any remaining items in a list:⍞000D⍞000D        head tail←⍵⍞000D⍞000D    is quicker and more elegant than the vector equivalent:⍞000D⍞000D        head tail←(⊃⍵)(1↓⍵)⍞000D⍞000DHowever,⍞000D⍞000D    A list has no prototypical item, so "overtake" must be coded explicitly.⍞000D⍞000D    There is an overhead of around 40 bytes per item  (80 in 64-bit APL),  comp-⍞000D    ared with a simple vector but this overhead is diluted when  compared with a⍞000D    nested vector.⍞000D⍞000D            size←{⎕size''⍵''}                 ⍝ size in bytes.⍞000D⍞000D            size        1e3⍴⎕a              ⍝ size of 1000-vector of bytes.⍞000D        1016⍞000D            size list   1e3⍴⎕a              ⍝ size of 1000-list of bytes.⍞000D        39980⍞000D⍞000D            size      ,¨1e3⍴⎕a              ⍝ size of 1000-vector of 1-vectors.⍞000D        24016⍞000D            size list ,¨1e3⍴⎕a              ⍝ size of 1000-list of 1-vectors.⍞000D        44016⍞000D⍞000D    To  access  the  ⍺''th  item  of a list takes ⍺ iterations, as opposed to the⍞000D    vector''s 1.  In  other words, list-item-access is O(n), whereas vector-item-⍞000D    access is O(1). However, in both cases, access-each-item is O(n).⍞000D⍞000D    To process all of the items in a list, a common operation, there is no equi-⍞000D    valent of the array''s primitive operator ¨ (each). Instead, an explicit loop⍞000D    must be coded.⍞000D⍞000D    (⍞000D        However,  in  defence  of the list: splitting a problem into what-to-do-⍞000D        with-the-head  together  with what-to-do-with-the-tail is a powerful de-⍞000D        composition  technique. Proponents of the list argue that, in situations⍞000D        where a vector can not be treated as a whole, recurring on a list as op-⍞000D        posed to iterating on the vector leads to many fewer "plus-or-minus-one"⍞000D        problems.⍞000D    )⍞000D⍞000DThe following function counts the number of items in a list.⍞000D⍞000D    litems←{                ⍝ No. of list items.⍞000D        ⍺←0                 ⍝ initial count is 0.⍞000D        ⍵≡''∘'':⍺             ⍝ null list: accumulated count.⍞000D        head tail←⍵         ⍝ head item and tail.⍞000D        (⍺+1)∇ tail         ⍝ accumulate with tail.⍞000D    }⍞000D⍞000Dand this function converts a list to its equivalent vector:⍞000D⍞000D    vect←{                  ⍝ Vector from list.⍞000D        ⍺←⍬                 ⍝ initial vector is ⍬.⍞000D        ⍵≡''∘'':⍺             ⍝ null list: accumulated vector.⍞000D        head tail←⍵         ⍝ head item and tail.⍞000D        (⍺,⊂head)∇ tail     ⍝ accumulate with tail.⍞000D    }⍞000D⍞000Dleading to operator [ltrav], which abstracts the essence of traversing a list:⍞000D⍞000D    ltrav←{                 ⍝ List traversal.⍞000D        ⍵≡''∘'':⍺             ⍝ null list : accumulator.⍞000D        head tail←⍵         ⍝ head item and tail.⍞000D        (⍺ ⍺⍺ head)∇ tail   ⍝ accumulated with tail.⍞000D    }⍞000D⍞000DNote  that  in this general case, the initial accumulator ⍺ must be supplied ex-⍞000Dplicitly as the operator can not know its type.⍞000D⍞000DUsing such techniques we can show that, in some circumstances, the processing of⍞000Da list can outpace the equivalent (naïvely coded) vector version:⍞000D⍞000D        vsum←{                      ⍝ vector summation.⍞000D            ⍺←0                     ⍝ initial accumulator.⍞000D            0=⍴⍵:⍺                  ⍝ null vector: finished.⍞000D            head tail←(⊃⍵)(1↓⍵)     ⍝ first and remaining items.⍞000D            (⍺+head)∇ tail          ⍝ accumulated sum.⍞000D        }⍞000D⍞000D        lsum←{                      ⍝ list summation.⍞000D            ⍺←0                     ⍝ initial accumulator.⍞000D            ⍵≡''∘'':⍺                 ⍝ null list: finished.⍞000D            head tail←⍵             ⍝ first and remaining items.⍞000D            (⍺+head)∇ tail          ⍝ accumulated sum.⍞000D        }⍞000D⍞000D        cmpx''vsum⍳1e4'' ''lsum list⍳1e4''⍞000D    vsum⍳1e4      2.2E¯1   0% ⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⍞000D    lsum list⍳1e4 6.5E¯2 -72% ⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⍞000D⍞000DThe reason why vsum is so much slower is that (1↓⍵), which is executed ⍴⍵ times,⍞000Dmakes a copy of all but the first item of the vector ⍵.⍞000D⍞000DNB: Of course, there are better ways to sum a numeric vector!⍞000D⍞000DTechnical note:⍞000D⍞000DThe coding for list is simply:⍞000D⍞000D    list←{              ⍝ list from vector ⍵.⍞000D        ↑{⍺ ⍵}/⍵,''∘''    ⍝ with ''∘'' as null.⍞000D    }⍞000D⍞000DAs {⍺ ⍵} is an idiom, the list function is relatively fast.⍞000D⍞000DNaming leading items⍞000D--------------------⍞000DWe  can  name more than one item at the head of the list by using "structure as-⍞000Dsignment"⍞000D⍞000D    (head tail) ← ⍵                 ⍝ name first item and remainder.⍞000D    (head (next tail)) ← ⍵          ⍝ name first two items and remainder.⍞000D    (a (b (c (d (e ... ))))) ← ⍵    ⍝ name first umpteen items and remainder.⍞000D⍞000DA  rather contrived example of the use of this technique might be to remove adj-⍞000Dacent duplicate values from a list:⍞000D⍞000D        rmdups←{                        ⍝ remove adjacent duplicates.⍞000D            ⍺←''∘''                       ⍝ null accumulator.⍞000D            (a(b tail))←⍵               ⍝ a and b are first two items.⍞000D            b≡''∘'':''∘''{⍺ ⍵}⍨ltrav a ⍺    ⍝ b null: list-reversed accumulator.⍞000D            a≡b:⍺ ∇ b tail              ⍝ two items match: drop first one.⍞000D            a ⍺ ∇ b tail                ⍝ accumulate first, continue.⍞000D        }⍞000D⍞000D        vect rmdups list ''Mississippi''  ⍝ removal of adjacent duplicates.⍞000D    Misisipi⍞000D⍞000DHandy functions on lists⍞000D------------------------⍞000DHere are some list utility functions:⍞000D⍞000D    rev←{⍺←''∘'' ⋄ ⍵≡''∘'':⍺ ⋄ hd r←⍵ ⋄ hd ⍺ ∇ tl}  ⍝ reversed list: (⌽⍵),⍺⍞000D    cat←{⍺≡''∘'':⍵ ⋄ hd tl←⍺ ⋄ hd(tl ∇ ⍵)}        ⍝ list catenation: ⍺,⍵⍞000D    pop←{⍺=0:⊂⍵ ⋄ hd tl←⍵ ⋄ ((⍺-1)∇ tl),⊂hd}    ⍝ ⍺ items and tail from list ⍵⍞000D⍞000DExamples:⍞000D⍞000D    ltrav←{                         ⍝ List traversal.⍞000D        ⍵≡''∘'':⍺                     ⍝ null list : accumulator.⍞000D        head tail←⍵                 ⍝ head item and tail.⍞000D        (⍺ ⍺⍺ head)∇ tail           ⍝ accumulated with tail.⍞000D    }⍞000D⍞000D    0 {⍺+1} ltrav list''hello''       ⍝ length of list.⍞000D5⍞000D    length←0∘( {⍺+1} ltrav )        ⍝ named list-length function.⍞000D⍞000D    length list ⎕a⍞000D26⍞000D    vect←⍬∘( {⍺,⊂⍵} ltrav )         ⍝ vector from list.⍞000D⍞000D    vect list ''hello''               ⍝ round-trip vector.⍞000Dhello⍞000D⍞000D    revl←''∘''∘( {⍺ ⍵}⍨ ltrav )       ⍝ reverse of list.⍞000D⍞000D    vect revl list ''hello''          ⍝ vector reverse.⍞000Dolleh⍞000D⍞000D⍝ A more substantial example is this little "lambda expression" parser:⍞000D⍞000D    parse←{                                 ⍝ Right-to-left lambda expr parser.⍞000D        ↑{ ⍝ ⎕←⍺''│''⍵                        ⍝ (uncomment to see trace).⍞000D            (toks a)(b(c accs))←⍺ ⍵         ⍝  a│b c : a│b c    3-item window.⍞000D            ''⊣''≡a:b                         ⍝  ⊣│*   :  *       finished⍞000D            ''()''≡a c:toks ∇ b accs          ⍝  (│* ) :  │* ·⍞000D            ''(→''≡a b:⍺ ∇ c accs             ⍝  (│→ * : (│*· ·⍞000D            ''→→''≡a b:toks ∇ ⍵               ⍝  →│→ * :  │→ *⍞000D            ''→''≡b:toks ∇ b((''→''a c)accs)    ⍝  v│→ b :  │→ v→b  lambda node.⍞000D            ''→)''≡a c:toks ∇ a ⍵             ⍝  →│* ) :  │→ * )⍞000D            a∊''→('':⍺ ∇(''@''b c)accs          ⍝  (│f a : (│fa     apply node.⍞000D            toks ∇ a ⍵                      ⍝  *│* · :  │* *⍞000D        }/↑{⍺ ⍵}⍨/⌽''⊣('',⍵,'')''               ⍝ parse of token list ⍵.⍞000D    }⍞000D⍞000D⍝ Notice that, apart from the last line, there are very few APL primitive funct-⍞000D⍝ ions in the code; most of the action takes place using structure construction⍞000D⍝ and deconstruction by assembling and naming parts of the ⍺ and ⍵ lists.⍞000D⍞000D    )copy min trees                     ⍝ borrow Min''s expression tree display.⍞000D⍞000D    trees parse ''(t→ttt)(fx→f(fx))+0''   ⍝ parse tree for lambda expression.⍞000D         ┌─@┐⍞000D      ┌──@┐ 0⍞000D ┌────@─┐ +⍞000D┌→──┐  ┌→─┐⍞000Dt ┌─@┐ f ┌→─┐⍞000D ┌@┐ t   x ┌@─┐⍞000D t t       f ┌@┐⍞000D             f x⍞000D⍞000DSee also: alists parse lisp joy⍞000D⍞000DIndex:accumulator|lambda expression|min (workspace)|parsing|lists|cons' 
