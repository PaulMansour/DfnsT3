'Brainbalm: An easier-to-program interface to Brainfuck⍞000D------------------------------------------------------⍞000DHere are some →mac←ros for a simple interface to Brainfuck. The macros expand to⍞000Dregular "pure" BF code, which uses only tokens: [ ] + - < > , .⍞000D⍞000DThe Balm machine extends BF with:⍞000D⍞000D    * If-else-fi constructions, which may be nested.⍞000D    * A push-down stack (for non-negative values).⍞000D    * Directly addressable (random-access) memory.⍞000D    * Instructions ; and : for input/output of numeric digits.⍞000D⍞000DThis little function "∆" will help us to collect sample source lines into a new-⍞000Dline-separated line-vector in buffer ⍙:⍞000D⍞000D    ∆←{{}⍙,←⍵,¯1↑4↑⎕av}     ⍝ accumulate into ⍙ buffer.⍞000D    ⍙←''''                    ⍝ null accumulation buffer.⍞000D⍞000DFirst, we implement directly-addressable (random-access)  memory in BF, with the⍞000Dhome (current) cell used as an accumulator "A". In addition, internal, invisible⍞000D"registers" b and c will be used for some copy operations and will be assumed to⍞000Dbe zero between instructions.⍞000D⍞000D     ┌─┬─┬─────────── Accumulator A and registers b and c.⍞000D    ┬─┬─┼A┬─┬─┬─┬─┬─┬─⍞000D    │c b│ │ │ │ │ │ │ ∘∘∘⍞000D    ┴─┴─┼0┴1┴2┴3┴4┴5┴─⍞000D         └─┴─┴─┴─┴─┴── "memory addresses" 0 1 2 3 4 5 ...⍞000D⍞000DMacros ≡, ← and → implement directly-addressable or random-access BF memory:⍞000D⍞000D    ∆''≡=(           ''   ⍝ ≡ copy <n> to A.  eg: n≡⍞000D    ∆''  />          ''   ⍝   go to <n>⍞000D    ∆''  [-/<+<+>/>] ''   ⍝   move <n> to A and b.⍞000D    ∆''  /<          ''   ⍝   go to A.⍞000D    ∆''  <           ''   ⍝   go to b.⍞000D    ∆''  [->/>+/<<]  ''   ⍝   move b to <n>⍞000D    ∆''  >           ''   ⍝   go to A.⍞000D    ∆'')             ''⍞000D⍞000D    ∆''→=(           ''   ⍝ → move <n> to A.  eg: n→⍞000D    ∆''  />          ''   ⍝   go to <n>⍞000D    ∆''  [-/<+/>]    ''   ⍝   move <n> to A.⍞000D    ∆''  /<          ''   ⍝   go to A.⍞000D    ∆'')             ''⍞000D⍞000D    ∆''←=(           ''   ⍝ ← move A to <n>   eg: n←⍞000D    ∆''  />[-]/<     ''   ⍝   clear <n>⍞000D    ∆''  [-/>+/<]    ''   ⍝   move A to <n>⍞000D    ∆'')             ''⍞000D⍞000D    ram ⍙←⍙ ''''          ⍝ directly-addressable memory macros ≡, ← and →.⍞000D⍞000DHere are macros ↓ and ↑ for pushing (down) and popping (up)  stack items.  As we⍞000Drely on the presence of a value in the v field when searching leftwards for top-⍞000Dof-stack, we can''t push a value of 0.  No problem; we just add 1 before stacking⍞000Da value and subtract 1 after popping it.⍞000D⍞000D             ┌────────────────────── top of stack⍞000D             │             ┌──────── stack base⍞000D       ─┬─┬─┬T┬─   ─┬─┬─┬─┬S┬─┬─┼A┬⍞000D   <-  0 0│t v│ ... │t v│t v│c b│ │⍞000D       ─┴─┴─┴─┴─   ─┴─┴─┴─┴─┴─┴─┼0┴⍞000D⍞000DThe  stack  is  to  the _left_ of the "home" cell A. If your BF system is fitted⍞000Dwith only a right-infinite  memory  tape,  you should use the ! macro to preface⍞000Dyour code with a ">>···>" sequence  long  enough  to  reserve  sufficient  stack⍞000Dspace.⍞000D⍞000D    ∆''↓=(           ''   ⍝ push:                     S←A,S ⋄ A←0⍞000D    ∆''  ←=[-/<+/>]  ''   ⍝   ← move ⍺ cells left (local macro defn).⍞000D    ∆''  →=[-/>+/<]  ''   ⍝   → move ⍺ cells right    ..  ..  ..⍞000D    ∆''  +           ''   ⍝ increment value to be pushed⍞000D    ∆''  4←          ''   ⍝ copy A to t in stack base (S.t)⍞000D    ∆''  <<<         ''   ⍝ go (move BF''s memory pointer) to S⍞000D    ∆''  [< 2← <]    ''   ⍝ move S.t to (T+1).t, where (T+1) is left of T⍞000D    ∆''  < 1→ >      ''   ⍝ move (T+1).t to (T+1).v⍞000D    ∆''  [>>]        ''   ⍝ skip back to (S-1).v (aka b)⍞000D    ∆''  >           ''   ⍝ go to A⍞000D    ∆'')             ''⍞000D⍞000D    ∆''↑=(           ''   ⍝ pop:                      A+←↑S ⋄ S←1↓A⍞000D    ∆''  →=[-/>+/<]  ''   ⍝   → move ⍺ cells right⍞000D    ∆''  <<<         ''   ⍝ go to S⍞000D    ∆''  [<<] >>     ''   ⍝ go to T⍞000D    ∆''  1→          ''   ⍝ move T.v to (T-1).t⍞000D    ∆''  >>          ''   ⍝ go to T-1⍞000D    ∆''  [< 2→ > >>] ''   ⍝ move value down stack to (S-1).t (aka c)⍞000D    ∆''  <           ''   ⍝ go to c⍞000D    ∆''  2→          ''   ⍝ move c to A⍞000D    ∆''  >>          ''   ⍝ go to A⍞000D    ∆''  -           ''   ⍝ decrement popped value.⍞000D    ∆'')             ''⍞000D⍞000D    ∆''!=>>/>/>>>    ''   ⍝ reserve space for ⍺-stack and regs b and c. Eg: 1000!⍞000D⍞000D    stk ⍙←⍙ ''''          ⍝ stack macros ↓ ↑ and !.⍞000D⍞000DMacros ; and : code  the  standard  BF  sequences that convert between character⍞000Ddigits ''0''-''9'' and their numeric equivalents, by adding or subtracting ''0'':⍞000D⍞000D    ∆'';=(           ''   ⍝ ; input digit   A←⎕⍞000D    ∆''  ,           ''   ⍝   input char ''0''-''9''.⍞000D    ∆''  ∆=/-        ''   ⍝   minus.⍞000D    ∆''  <6∆[+>8∆<]> ''   ⍝   subtract ''0''=48.⍞000D    ∆'')''⍞000D⍞000D    ∆'':=(           ''   ⍝ : output digit  ⎕←A⍞000D    ∆''  ∆=/+        ''   ⍝   plus.⍞000D    ∆''  <6∆[->8∆<]> ''   ⍝   add ''0''=48.⍞000D    ∆''  .           ''   ⍝   output char ''0''-''9''.⍞000D    ∆'')             ''⍞000D⍞000D    io ⍙←⍙ ''''           ⍝ numeric I/O macros ; and :.⍞000D⍞000Dand finally, here are {, ⋄ and }, which give us an if-else-fi control struct:⍞000D⍞000D    ∆''  {=<+>[<->   ''   ⍝ {  if A≠0⍞000D    ∆''  ⋄=<]<[->    ''   ⍝ ⋄  else⍞000D    ∆''  }=<<]>>     ''   ⍝ }  fi⍞000D⍞000D    if ⍙←⍙ ''''           ⍝ if-else-fi macros { ⋄ }.⍞000D⍞000DExamples:⍞000D⍞000D    dark ← ∩∘''[]<>+-,.''                         ⍝ without white space.⍞000D⍞000D    opt ← {↑{({⍵⍱¯1⌽⍵}⍺⍷⍵)/⍵}⍣≡/''><'' ''<>''⍵}     ⍝ cancelling >< pairs removed.⍞000D⍞000D    dark mac ram,io, ''m=1 n=2 ;m← ;n←'' ⍝ BF: store input digits at [1] and [2].⍞000D,<------[+>--------<]>>[-]<[->+<],<------[+>--------<]>>>[-]<<[->>+<<]⍞000D⍞000D    bf mac io,stk, ''1! ;↓;↑:''   ⍝ sum of two input digits.⍞000D2⍞000D3⍞000D5⍞000D⍞000DHere is a (very inefficient, compared with →bfack←) coding of Ackermann''s funct-⍞000Dion. The function is usually written in →declarative← style as three cases:⍞000D⍞000D    ack 0 n = n+1⍞000D    ack m 0 = ack (m-1) 1⍞000D    ack m n = ack (m-1) (ack m (n-1))⍞000D⍞000DThe  recursion  can  be  recast  using iteration if we provide an explicit stack⍞000Dwhose  top two items are the arguments for the next call. Compare the above with⍞000Dthe following pseudo-code:⍞000D⍞000D    ack m n⍞000D    ·   push ¯1             ⍝ end of stacked-items marker.⍞000D    ·   repeat              ⍝ loop⍞000D    ·   ·   if m=0          ⍝ ack(0, n)⍞000D    ·   ·   ·   push n+1    ⍝   = n+1⍞000D    ·   ·   else if n=0     ⍝ ack(m, 0)⍞000D    ·   ·   ·   push m-1    ⍝   = ack(m-1, ─────────┐⍞000D    ·   ·   ·   push 1      ⍝         1)            │ "recursive"⍞000D    ·   ·   else            ⍝ ack(m, n)             │   calls.⍞000D    ·   ·   ·   push m-1    ⍝   = ack(m-1, ─────────┤⍞000D    ·   ·   ·   push m      ⍝         ack(m, ───────┘⍞000D    ·   ·   ·   push n-1    ⍝             n-1))⍞000D    ·   ·   fi              ⍝⍞000D    ·   ·   n ← pop         ⍝ ──┐ "recursive"⍞000D    ·   ·   m ← pop         ⍝ ──┘   return.⍞000D    ·   while m≠¯1          ⍝ while items on stack.⍞000D    ·   return n⍞000D⍞000DIt  will  simplify our task if we replace the "else if" construct in favour of a⍞000Dsimpler, though more deeply-nested, "if else fi".⍞000D⍞000D    ack m n⍞000D    ·   push ¯1⍞000D    ·   repeat⍞000D    ·   ·   if m=0⍞000D    ·   ·   ·   push n+1⍞000D    ·   ·   else                ⍝ "else if" → "else" with an⍞000D    ·   ·   ·   if n=0          ⍝   indented "if"⍞000D    ·   ·   ·   ·   push m-1    ⍝⍞000D    ·   ·   ·   ·   push 1      ⍝⍞000D    ·   ·   ·   else            ⍝⍞000D    ·   ·   ·   ·   push m-1    ⍝⍞000D    ·   ·   ·   ·   push m      ⍝⍞000D    ·   ·   ·   ·   push n-1    ⍝⍞000D    ·   ·   ·   fi              ⍝ together with an additional "fi".⍞000D    ·   ·   fi⍞000D    ·   ·   n ← pop⍞000D    ·   ·   m ← pop⍞000D    ·   while m≠¯1⍞000D    ·   return n⍞000D⍞000DNow we can factor the "push m-1" from both clauses of the "if n=0" case:⍞000D⍞000D    ack m n⍞000D    ·   push ¯1⍞000D    ·   repeat⍞000D    ·   ·   if m=0⍞000D    ·   ·   ·   push n+1⍞000D    ·   ·   else⍞000D·   ·   ·   ·   push m-1        ⍝ factored-out push.⍞000D    ·   ·   ·   if n=0⍞000D    ·   ·   ·   ·   push 1⍞000D    ·   ·   ·   else⍞000D    ·   ·   ·   ·   push m⍞000D    ·   ·   ·   ·   push n-1⍞000D    ·   ·   ·   fi⍞000D    ·   ·   fi⍞000D    ·   ·   n ← pop⍞000D    ·   ·   m ← pop⍞000D    ·   while m≠¯1⍞000D    ·   return n⍞000D⍞000Dand reverse the sense of the tests from =0 to ≠0 by exchanging the corresponding⍞000Dclauses.⍞000D⍞000D    ack m n⍞000D    ·   push ¯1⍞000D    ·   repeat⍞000D    ·   ·   if m≠0              ⍝ test for non-0⍞000D·   ·   ·   ·   push m-1⍞000D    ·   ·   ·   if n≠0          ⍝ test for non-0⍞000D    ·   ·   ·   ·   push m⍞000D    ·   ·   ·   ·   push n-1⍞000D    ·   ·   ·   else⍞000D    ·   ·   ·   ·   push 1⍞000D    ·   ·   ·   fi⍞000D    ·   ·   else⍞000D    ·   ·   ·   push n+1⍞000D    ·   ·   fi⍞000D    ·   ·   n ← pop⍞000D    ·   ·   m ← pop⍞000D    ·   while m≠¯1⍞000D    ·   return n⍞000D⍞000DFinally,  as  copying negative values would add significant complexity to the BF⍞000Dcoding, we add 1 to m and n throughout  and subtract one  from the final result.⍞000DThis allows our end-of-stacked-items marker to be 0, rather than ¯1.⍞000D⍞000DHere is the version of Ackermann''s fuction that we will code in Brainfuck:⍞000D⍞000D    ┌─Iterative Ackermann───────────┐⍞000D    │                               │⍞000D    │   ack m n                     │⍞000D    │   ·   m n +← 1                │⍞000D    │   ·   push 0                  │⍞000D    │   ·   repeat                  │⍞000D    │   ·   ·   if 0≠m-1            │⍞000D    │   ·   ·   ·   push m-1        │⍞000D    │   ·   ·   ·   if 0≠n-1        │⍞000D    │   ·   ·   ·   ·   push m      │⍞000D    │   ·   ·   ·   ·   push n-1    │⍞000D    │   ·   ·   ·   else            │⍞000D    │   ·   ·   ·   ·   push 1+1    │⍞000D    │   ·   ·   ·   fi              │⍞000D    │   ·   ·   else                │⍞000D    │   ·   ·   ·   push n+1        │⍞000D    │   ·   ·   fi                  │⍞000D    │   ·   ·   n ← pop             │⍞000D    │   ·   ·   m ← pop             │⍞000D    │   ·   while m≠0               │⍞000D    │   ·   return n-1              │⍞000D    │                               │⍞000D    └───────────────────────────────┘⍞000D⍞000D    ⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍞000D    ⍝                                                       ⍝⍞000D    ⍝                           ⍝ Ackermann''s function.     ⍝⍞000D    ∆''  m=1 n=2             ''   ⍝   declare local vars.     ⍝⍞000D    ∆''  ;+m← ;+n←           ''   ⍝   input and incr m and n  ⍝⍞000D    ∆''  ↓                   ''   ⍝   push 0                  ⍝⍞000D    ∆''  m≡[                 ''   ⍝   repeat                  ⍝⍞000D    ∆''  ·   -{              ''   ⍝   ·   if 0≠m-1            ⍝⍞000D    ∆''  ·   ·   ↓           ''   ⍝   ·   ·   push m-1        ⍝⍞000D    ∆''  ·   ·   n≡-{[-]     ''   ⍝   ·   ·   if 0≠n-1        ⍝⍞000D    ∆''  ·   ·   ·   m→ ↓    ''   ⍝   ·   ·   ·   push m      ⍝⍞000D    ∆''  ·   ·   ·   n→-↓    ''   ⍝   ·   ·   ·   push n-1    ⍝⍞000D    ∆''  ·   ·   ⋄           ''   ⍝   ·   ·   else            ⍝⍞000D    ∆''  ·   ·   ·    ++↓    ''   ⍝   ·   ·   ·   push 1+1    ⍝⍞000D    ∆''  ·   ·   }           ''   ⍝   ·   ·   fi              ⍝⍞000D    ∆''  ·   ⋄               ''   ⍝   ·   else                ⍝⍞000D    ∆''  ·   ·   n→+↓        ''   ⍝   ·   ·   push n+1        ⍝⍞000D    ∆''  ·   }               ''   ⍝   ·   fi                  ⍝⍞000D    ∆''  ·   ↑n←             ''   ⍝   ·   pop n               ⍝⍞000D    ∆''  ·   ↑m←             ''   ⍝   ·   pop m               ⍝⍞000D    ∆''  m≡]                 ''   ⍝   while stacked items     ⍝⍞000D    ∆''  n→-:                ''   ⍝   output n-1              ⍝⍞000D        ack ⍙←⍙ ''''                                          ⍝⍞000D    ⍝                                                       ⍝⍞000D    ⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍞000D⍞000D    bf opt dark mac if,io,ram,stk, ''10!'',ack    ⍝ ack 2 3 → 9⍞000D2⍞000D3⍞000D9⍞000D    ⍴opt dark mac if,io,ram,stk,ack             ⍝ Size of BF code for Ackermann.⍞000D601⍞000D⍞000D⍝ Using this coding, ack(3,3) takes around half an hour on a 2GHz machine.⍞000D⍝ Compare this with around 15 seconds for the coding in →bfack←.⍞000D⍞000DThis function wraps and indents BF loops for easier reading:⍞000D⍞000D    pretty←{⎕ML←1⍞000D        nl←⊃⌽⎕TC⍞000D        dents←{∊¨(0⌈⍵+1 ¯1)⍴¨⊂⊂4↑''·''}⍞000D        0{⍞000D            nice(next nasty)←⍵⍞000D            ''∘''=next:∊nice⍞000D            more less←dents ⍺⍞000D            ''[''=next:(⍺+1)∇(nice,next,nl,more)nasty⍞000D            '']''=next:(⍺-1)∇(nice,nl,less,next)nasty⍞000D            ⍺ ∇(nice next)nasty⍞000D        }↑{⍺ ⍵}/⍵,''∘''⍞000D    }⍞000D⍞000D    pretty opt dark mac if,io,ram,stk,ack   ⍝ Ackermann''s function from Balm.⍞000D,<------[⍞000D·   +>--------<⍞000D]>+>[⍞000D·   -⍞000D]<[⍞000D·   ->+<⍞000D],<------[⍞000D·   +>--------<⍞000D]>+>>[⍞000D·   -⍞000D]<<[⍞000D·   ->>+<<⍞000D]+[⍞000D·   -<<<<+>>>>⍞000D]<<<[⍞000D·   <[⍞000D·   ·   -<<+>>⍞000D·   ]<⍞000D]<[⍞000D·   ->+<⍞000D]>[⍞000D·   >>⍞000D]>>[⍞000D·   -<+<+>>⍞000D]<<[⍞000D·   ->>+<<⍞000D]>[⍞000D·   -<+>[⍞000D·   ·   <->+[⍞000D·   ·   ·   -<<<<+>>>>⍞000D·   ·   ]<<<[⍞000D·   ·   ·   <[⍞000D·   ·   ·   ·   -<<+>>⍞000D·   ·   ·   ]<⍞000D·   ·   ]<[⍞000D·   ·   ·   ->+<⍞000D·   ·   ]>[⍞000D·   ·   ·   >>⍞000D·   ·   ]>>>[⍞000D·   ·   ·   -<<+<+>>>⍞000D·   ·   ]<<<[⍞000D·   ·   ·   ->>>+<<<⍞000D·   ·   ]>-<+>[⍞000D·   ·   ·   <->[⍞000D·   ·   ·   ·   -⍞000D·   ·   ·   ]>[⍞000D·   ·   ·   ·   -<+>⍞000D·   ·   ·   ]<+[⍞000D·   ·   ·   ·   -<<<<+>>>>⍞000D·   ·   ·   ]<<<[⍞000D·   ·   ·   ·   <[⍞000D·   ·   ·   ·   ·   -<<+>>⍞000D·   ·   ·   ·   ]<⍞000D·   ·   ·   ]<[⍞000D·   ·   ·   ·   ->+<⍞000D·   ·   ·   ]>[⍞000D·   ·   ·   ·   >>⍞000D·   ·   ·   ]>>>[⍞000D·   ·   ·   ·   -<<+>>⍞000D·   ·   ·   ]<<-+[⍞000D·   ·   ·   ·   -<<<<+>>>>⍞000D·   ·   ·   ]<<<[⍞000D·   ·   ·   ·   <[⍞000D·   ·   ·   ·   ·   -<<+>>⍞000D·   ·   ·   ·   ]<⍞000D·   ·   ·   ]<[⍞000D·   ·   ·   ·   ->+<⍞000D·   ·   ·   ]>[⍞000D·   ·   ·   ·   >>⍞000D·   ·   ·   ]⍞000D·   ·   ]<[⍞000D·   ·   ·   ->+++[⍞000D·   ·   ·   ·   -<<<<+>>>>⍞000D·   ·   ·   ]<<<[⍞000D·   ·   ·   ·   <[⍞000D·   ·   ·   ·   ·   -<<+>>⍞000D·   ·   ·   ·   ]<⍞000D·   ·   ·   ]<[⍞000D·   ·   ·   ·   ->+<⍞000D·   ·   ·   ]>[⍞000D·   ·   ·   ·   >>⍞000D·   ·   ·   ]<⍞000D·   ·   ]>⍞000D·   ]<[⍞000D·   ·   ->>>[⍞000D·   ·   ·   -<<+>>⍞000D·   ·   ]<<++[⍞000D·   ·   ·   -<<<<+>>>>⍞000D·   ·   ]<<<[⍞000D·   ·   ·   <[⍞000D·   ·   ·   ·   -<<+>>⍞000D·   ·   ·   ]<⍞000D·   ·   ]<[⍞000D·   ·   ·   ->+<⍞000D·   ·   ]>[⍞000D·   ·   ·   >>⍞000D·   ·   ]<⍞000D·   ]<[⍞000D·   ·   <<⍞000D·   ]>>[⍞000D·   ·   ->+<⍞000D·   ]>>[⍞000D·   ·   <[⍞000D·   ·   ·   ->>+<<⍞000D·   ·   ]>>>⍞000D·   ]<[⍞000D·   ·   ->>+<<⍞000D·   ]>>->>[⍞000D·   ·   -⍞000D·   ]<<[⍞000D·   ·   ->>+<<⍞000D·   ]<<<[⍞000D·   ·   <<⍞000D·   ]>>[⍞000D·   ·   ->+<⍞000D·   ]>>[⍞000D·   ·   <[⍞000D·   ·   ·   ->>+<<⍞000D·   ·   ]>>>⍞000D·   ]<[⍞000D·   ·   ->>+<<⍞000D·   ]>>->[⍞000D·   ·   -⍞000D·   ]<[⍞000D·   ·   ->+<⍞000D·   ]>[⍞000D·   ·   -<+<+>>⍞000D·   ]<<[⍞000D·   ·   ->>+<<⍞000D·   ]>⍞000D]>>[⍞000D·   -<<+>>⍞000D]<<-<++++++[⍞000D·   ->++++++++<⍞000D]>.⍞000D⍞000DSee also: bfack bf mac⍞000D⍞000DIndex:Ackermann''s function|macro|Turing tape⍞000DIndex;Ackermann W.' 
