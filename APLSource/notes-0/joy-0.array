'stack ← {repl←0} ##.joy program             ⍝ Subset of the Joy language.⍞000D⍞000DEvaluates character-vector Joy [program]:⍞000D⍞000D      joy''2 3 4 + *''                ⍝ 2×3+4⍞000D14⍞000D      joy''[1 2 3 4 5] 0 [+] fold''   ⍝ +/⍳5⍞000D15⍞000D      joy''[1 2 3 4 5] [dup *] map''  ⍝ (⍳5)*2⍞000D[1 4 9 16 25]⍞000D⍞000DIf an error occurs,  the stack and operator stream are returned with a │ between⍞000Dthe offending operator and its argument(s).⍞000D⍞000D      joy''2 3 + 0 / 2 *''            ⍝ divide-by-0 error⍞000D5 0│/ 2 *⍞000D⍞000DIf optional left argument [repl←0] is set, [joy]  prompts  for  additional input⍞000Dafter evaluating its argument expression. Such an interactive session is termin-⍞000Dated by operator: quit.⍞000D⍞000D      1 joy''2 dup +''                ⍝ 1 joy ... => interactive session:⍞000D                   4│[] cons        (* ⊂,⍵      *)⍞000D                 [4]│[2 3]          (* ⍵,⊂2 3   *)⍞000D           [4] [2 3]│swap           (* ⌽ ⍵      *)⍞000D           [2 3] [4]│concat         (* ⊃,/⍵     *)⍞000D             [2 3 4]│1 swons        (* ⍵ ,⍨ ⊂1  *)⍞000D           [1 2 3 4]│[10 *] map     (* 10×¨⍵    *)⍞000D       [10 20 30 40]│1 [*] fold     (* ×/⍵      *)⍞000D              240000│quit           (* ⎕OFF ⍵   *)⍞000D240000⍞000D⍞000DThe Joy machine  consists  of a right-growing  stack of values to the left and a⍞000Dstream of operators to the right of separator: │.  The operator  immediately  to⍞000Dthe right of the separator interacts with the item(s) to its left to reduce  the⍞000Dstate of the machine.  This process repeats  until either an error occurs or the⍞000Doperator stream is exhausted. At this point, if left argument [repl] is 0, [joy]⍞000Dterminates  returning  the  current  machine  state.  Otherwise, if [repl] is 1,⍞000Dfurther input is solicited until operator <quit> is entered, as shown above.⍞000D⍞000DReferences⍞000D----------⍞000DJoy Programming Language:⍞000Dhttp://www.latrobe.edu.au/humanities/research/research-projects/past-projects/joy-programming-language⍞000D⍞000DVarious Joy resources from Kevin Albrecht:⍞000Dhttp://www.kevinalbrecht.com/code/joy-mirror/joy.html⍞000D⍞000DConcatenative Languages:⍞000Dhttp://concatenative.org/wiki/view/Concatenative%20language⍞000D⍞000DStevan Apter: Functional Programming in Joy and K:⍞000Dhttp://archive.vector.org.uk/art10000360⍞000D⍞000DStevan Apter: Interview with Manfred von Thun, the originator of Joy:⍞000Dhttp://archive.vector.org.uk/art10000350⍞000D⍞000DManfred von Thun: Joy in Joy - a metacircular interpreter:⍞000Dhttp://www.kevinalbrecht.com/code/joy-mirror/jp-joyjoy.html⍞000D⍞000DStevan Apter''s concatenative language XY has roots in both Joy and K:⍞000Dhttp://nsl.com/k/xy/xy.htm⍞000D⍞000DBrent Kerby: The Theory of Concatenative Combinators:⍞000Dhttp://tunes.org/%7Eiepos/joy.html⍞000D⍞000DThanks to Stevan Apter for references.⍞000D⍞000D"Joy is a functional programming language which is not based on the  application⍞000D of functions to arguments but on the composition of functions.  It does not use⍞000D lambda-abstraction of expressions but instead it uses quotation of expressions.⍞000D A large number of combinators are used to perform dequotation,  they  have  the⍞000D effect of higher order functions.  Several of them can be used to eliminate re-⍞000D cursive definitions. Programs in Joy are compact and often look just like post-⍞000D fix notation.  Writing  programs  and reasoning about them is made easy because⍞000D there is no substitution of actual for formal parameters." Manfred von Thun.⍞000D⍞000DPlaying with Joy⍞000D----------------⍞000DIn an interactive session the separator, which is  placed  initially  at  column⍞000Dposition ⌊⎕PW÷4, may be adjusted at any time by adding or removing spaces to its⍞000Dleft during input:⍞000D⍞000D      1 joy''''⍞000D                    │2 3 +  (* separator starts at ⌊⎕pw÷4                   *)⍞000D                   5│       (* move separator to left by deleting blanks    *)⍞000D        5│⍞000D        5│2 +               (* separator continues here until moved again   *)⍞000D        7│⍞000D             7│dup *        (* and so on                                    *)⍞000D            49│⍞000D            49│quit         (* remember to quit !                           *)⍞000D49⍞000D⍞000DLibrary⍞000D-------⍞000DScript ##.scripts._joy contains a number of examples of simple Joy programs:⍞000D⍞000D    fac     factorial:              ⍵ fac → !⍵⍞000D    fac-i   iterative factorial         ..⍞000D    fac-r   recursive factorial         ..⍞000D    fac-y   factorial Y                 ..⍞000D    fib     fibonacci:              ⍵ fib → ⍵''th fibonacci number⍞000D    fib-i   iterative fibonacci:        ..      ..      ..⍞000D    fib-r   recursive fibonacci         ..      ..      ..⍞000D    2∧      two-to-the-power-of:    2*⍵⍞000D    seq     number sequence         [m..n]⍞000D    ack     recursive Ackermann⍞000D    ack-y   Ackermann Y⍞000D    qsort   Quicksort               ⍵[⍋⍵]⍞000D    Y       Y-combinator            [f]Y → f[f]Y⍞000D    →       clear the stack⍞000D⍞000DTracing⍞000D¯¯¯¯¯¯¯⍞000DThe evaluation of a ⊢···⊣ bracketed expression is traced. Traced output is dist-⍞000Dinguished from regular output by leading dots ···.  Notice the traced  expansion⍞000Dof defined names (such as append == reverse cons reverse) in the following:⍞000D⍞000D      1 joy scripts._joy⍞000D                    │4 [1 2 3] append 0 [+] fold    (* untraced *)⍞000D                  10│→                              (* )reset   *)⍞000D                    │⍞000D                    │⊢4 [1 2 3] append⊣ 0 [+] fold  (* partial tracing *)⍞000D····················│4 [1 2 3] append ⊣ 0 [+] fold⍞000D···················4│[1 2 3] append ⊣ 0 [+] fold⍞000D···········4 [1 2 3]│append ⊣ 0 [+] fold⍞000D···········4 [1 2 3]│reverse cons reverse ⊣ 0 [+] fold⍞000D···········4 [3 2 1]│cons reverse ⊣ 0 [+] fold⍞000D···········[4 3 2 1]│reverse ⊣ 0 [+] fold⍞000D···········[1 2 3 4]│⊣ 0 [+] fold⍞000D                  10│quit⍞000D10⍞000D      joy''⊢3[1][*]primrec''                  ⍝ non-interactive [repl←0] trace⍞000D····················│3 [1] [*] primrec⍞000D···················3│[1] [*] primrec⍞000D···············3 [1]│[*] primrec⍞000D···········3 [1] [*]│primrec⍞000D···········2 [1] [*]│primrec 3 swap *⍞000D···········1 [1] [*]│primrec 2 swap * 3 swap *⍞000D···········0 [1] [*]│primrec 1 swap * 2 swap * 3 swap *⍞000D···················1│1 swap * 2 swap * 3 swap *⍞000D·················1 1│swap * 2 swap * 3 swap *⍞000D·················1 1│* 2 swap * 3 swap *⍞000D···················1│2 swap * 3 swap *⍞000D·················1 2│swap * 3 swap *⍞000D·················2 1│* 3 swap *⍞000D···················2│3 swap *⍞000D·················2 3│swap *⍞000D·················3 2│*⍞000D6⍞000D⍞000DHere is a list of supported operators. Those marked "*" are implemented in Joy:⍞000D⍞000Dsupported operators ──┐⍞000D    top of stack ───┐ │⍞000D                    ↓ ↓⍞000D                    a│dup      →                a a│⍞000D*                 b a│dupd     →              b b a│⍞000D                  b a│pop      →                  b│⍞000D*                 b a│popd     →                  a│⍞000D*               c b a│pop2     →                  c│⍞000D*                   a│unit     →                [a]│⍞000D                  b a│swap     →                a b│⍞000D*               c b a│swapd    →              b c a│⍞000D*               c b a│rotate   →              a b c│⍞000D*               c b a│rollup   →              a c b│⍞000D*               c b a│rolldown →              b a c│⍞000D                a [b]│cons     →              [a b]│⍞000D*               a [b]│append   →              [b a]│⍞000D                [a b]│uncons   →              a [b]│⍞000D                [b] a│swons    →              [a b]│⍞000D*           a [f] [g]│cleave   →                   │a f a g⍞000D              [a] [b]│concat   →              [a b]│⍞000D*           x [a] [b]│enconcat →            [a x b]│⍞000D*         [a b] [f] g│shunt    →                   │a f g b f g⍞000D*             [a] [b]│swoncat  →              [b a]│⍞000D                a [f]│dip      →                   │f a⍞000D*             b a [f]│dip2     →                   │f b a⍞000D*           c b a [f]│dip3     →                   │f c b a⍞000D              [a b c]│reverse  →            [c b a]│⍞000D*             [a] [f]│infra    →                  [│a f]⍞000D        [a b ...] [f]│step     →                   │a f b f ...⍞000D*       [a b ...] [f]│map      →        [f¨a b ...]│⍞000D*     [a b ...] i [f]│fold     →      [f/i,a b ...]│⍞000D*       [a b ...] [f]│filter   →  [{f¨⍵)/⍵}a b ...]│⍞000D*       [a b ...] [f]│split    →                   │⍞000D              n [ops]│times    →              ops⍣n│⍞000D            b [t] [f]│branch   →                   │{b:t⋄f}⍞000D*         [b] [t] [f]│ifte     →                   │{b:t⋄f}⍞000D*         ... b a [f]│nullary  →            ... b a│a f⍞000D*       ... c b a [f]│unary    →            ... c b│a f⍞000D*    [[p]a][[q]b[d]] │cond     →                   │p:a⋄q:b⋄d⍞000D                    a│null     →              a∊0[]│⍞000D                    a│small    →      a∊0 1[][atom]│⍞000D               .. b a│stack    →    .. b a [a b ..]│⍞000D             .. [a b]│unstack  →                b a│⍞000D*             [a ...]│size     →                 ≢⍵│⍞000D                    n│succ     →                n+1│⍞000D                    n│pred     →                n-1│⍞000D                  [a]│i        →                   │a⍞000D                    a│id       →                  a│⍞000D            n [a] [f]│primrec  →      (n-1) [a] [f]│primrec n swap f⍞000D        [x y] [a] [f]│primrec  →        [y] [a] [f]│primrec x swap f⍞000D*      true [B][R][J]│linrec   →                   │B⍞000D*     false [B][R][J]│linrec   →                   │R [T][B][R][J]linrec J⍞000D     0/[] [B] [F] [J]│binrec   →                   │B⍞000D    n/[a] [B] [F] [J]│binrec   →              n/[a]│F [B] [F] [J] binrec⍞000D                     │                             │  [B] [F] [J] binrec J⍞000D                  m n│+        →                m+n│⍞000D                  m n│-        →                m-n│⍞000D                  m n│*        →                m×n│⍞000D                  m n│/        →                m÷n│⍞000D                  m n│rem      →               ⌊m÷n│⍞000D                  m n│div      →              0 n⊤m│⍞000D                  m n│<        →                m<n│⍞000D                  m n│<=       →                m≤n│⍞000D                  m n│=        →                m=n│⍞000D                  m n│>=       →                m≥n│⍞000D                  m n│>        →                m>n│⍞000D                  m n│!=       →                m≠n│⍞000D*                   b│not      →               {!⍵}│⍞000D⍞000DIn addition  to these  operators, keyword DEFINE is used to name word sequences.⍞000DFor example primitive combinator "swons" could have been defined:⍞000D⍞000D    DEFINE swons == swap cons .     (* note the terminating "." *)⍞000D⍞000DBugs and restrictions⍞000D---------------------⍞000D- Only boolean and whole, non-negative "natural" numbers are supported: 0 1 2 ..⍞000D- The only aggregate form is the List; there is no support for sets or strings.⍞000D- In interactive mode, only single-line expressions may be entered.⍞000D⍞000DRequirements⍞000D------------⍞000D[joy] calls operator →nats← for its natural-number arithmetic.⍞000D⍞000DTechnical notes⍞000D---------------⍞000D[joy] is an exercise in tail-calling.  In essence, it''s just  a  read-eval-print⍞000Dloop (or "REPL" see: http://en.wikipedia.org/wiki/Read-eval-print_loop) of which⍞000Dthe principal components are inner dfns: read, eval and prt:⍞000D⍞000D        ┌──read─→─eval─→─prt──┐⍞000D        │                     │⍞000D        └───────←──────←──────┘⍞000D⍞000DEach function takes (and notionally returns) the tuple (stk I ops) where:⍞000D⍞000D    stk: Items on Joy''s stack, implemented as a →list←,⍞000D      I: Position of │-separator in interactive session.⍞000D    ops: Stream of yet-to-be-applied operators, also a →list←,⍞000D⍞000D.. together with an association list (see →alists←) as left argument, which maps⍞000Ddefined names to their values.⍞000D⍞000DSo we can define the type of each of these (read, eval, prt) functions as:⍞000D⍞000D    read eval prt :: State ← Dict ∇ State       ⍝ :: "are of type"⍞000D⍞000DDefining names (with capital letters) for types helps to simplify:⍞000D⍞000D      joy   ::  ⍞235E ← ∇ ⍞235E                         ⍝ type of this function⍞000D     Repl   :=  State ← Dict ∇ State            ⍝ state reduction⍞000D     Oper   :=  State ← Dict ∇ Sargs            ⍝ primitive operator⍞000D    Sargs   :=  Stack, [Value]                  ⍝ vector: (⊂stack),args⍞000D     Dict   :=  [Name] [Oseq]                   ⍝ name-value association tuple⍞000D    State   :=  Stack Disp Oseq                 ⍝ machine state⍞000D     Disp   :=  offset                          ⍝ (-ive during tracing)⍞000D     List ⍵ :=  ''∘'' | ⍵ (List ⍵)                ⍝ f(fr(frr ...))⍞000D     Oseq   :=  Word | List Word | List Oseq    ⍝ operator sequence⍞000D    Stack   :=  List Value                      ⍝ value stack⍞000D    Value   :=  Word  | List Value              ⍝ value⍞000D     Word   :=  ⍞235E                               ⍝ character vector⍞000D⍞000DWithin the code,  the convention for naming the first few items of lists borrows⍞000Dfrom  Lisp''s: car cdr cadr cddr ... but using Joy''s terms  "first"  and  "rest".⍞000DSo: f r fr rr ... for first, rest, first-of-rest rest-of-rest and so forth.⍞000D⍞000DPrincipal function "eval" is effectively a Select structure with a case for each⍞000Dof the supported operators.⍞000D⍞000DOn entry, the  top few stack items and first operator are named and a case-match⍞000Dfunction is defined:⍞000D⍞000D    stk I(op ops)←⍵                     ⍝ stack and next operator⍞000D    ...⍞000D    f(fr rr)←f r←stk                    ⍝ top few stack items⍞000D    c←{op≡⍵~'' ''}                        ⍝ case match ignoring blanks⍞000D⍞000DThe line corresponding to each case has this structure:⍞000D⍞000D        c oper: ⍺(patn rgs efn)⍵⍞000Dwhere:⍞000D         c: Matching function.⍞000D      oper: Name of operator to match: ''cons'', ''swap'', etc.⍞000D         ⍺: Current definition dictionary.⍞000D      patn: A vector, the same length as the required number of arguments with⍞000D            expected types:⍞000D                0: number⍞000D                1: non-zero number⍞000D                ∧: boolean (true or false)⍞000D                ⌷: list⍞000D                ⍞235E: non-empty list⍞000D                *: anything⍞000D       rgs: A dyadic operator, which checks the conformability (type and number)⍞000D            of arguments  and  then for failure calls "err" or for success calls⍞000D            its continuation function efn:⍞000D       efn: Evaluation function to call next.⍞000D         ⍵: Operator-stream, including current operator.⍞000D⍞000DFor example:⍞000D⍞000D    c''swons  '':⍺(''⌷*''rgs{⍺ ∆((f fr)rr)I ops})⍵     ⍝    [a] b → [b a]⍞000D    │ │        │ │   │  │                    │⍞000D    │ │        │ │   │  │                    └── operator list⍞000D    │ │        │ │   │  └─────────────────── evaluation fn for remaining ops⍞000D    │ │        │ │   └────────────────────── argument conformability checking fn⍞000D    │ │        │ └────────────────────────── argument pattern vector⍞000D    │ │        └──────────────────────────── definitions⍞000D    │ └───────────────────────────────────── operator⍞000D    └─────────────────────────────────────── operator matching function⍞000D⍞000DPerformance:⍞000D⍞000DFor no particular reason, the arrangement of the cases within subfunction [eval]⍞000Dhas been optimised for "Ackermann''s function" (see ##.scripts._joy). The follow-⍞000Ding operator counts are for the reduction of "3 3 ack", where * indicates a def-⍞000Dined (non-primitive) operator:⍞000D⍞000D    dip      21942⍞000D    cons     20754⍞000D    i        10913⍞000D    swap      9726⍞000D    branch    8539⍞000D*   nullary   8539⍞000D*   swoncat   8539⍞000D    unstack   8539⍞000D    stack     8539⍞000D    concat    8539⍞000D    uncons    7352⍞000D    small     4863⍞000D*   cond      4863⍞000D    pop       3677⍞000D    null      3676⍞000D*   ack       2432⍞000D    pred      2431⍞000D    succ      1188⍞000D    dup       1187⍞000D    DEFINE       1⍞000D            ------⍞000D    total   121866  (omitting * defined operators)⍞000D            ------⍞000D(muse:⍞000D⍞000D    Case selection within subfunction [eval] is a sequence of  guards,  each  of⍞000D    which applies  the  same  matching  function to a number of constant values.⍞000D    This structure occurs frequently enough to make it an attractive  optimisat-⍞000D    ion for the dfn evaluator. Such an optimisation might spot the sequence:⍞000D⍞000D        c←{op≡⍵~'' ''}⍞000D        c''dip   '': ...      ⍝ case[0]⍞000D        c''cons  '': ...      ⍝  ..  1⍞000D        c''i     '': ...      ⍝  ..  2⍞000D        c''swap  '': ...      ⍝  ..  3⍞000D        ...                 ⍝  ..  n⍞000D⍞000D    and, noting that c is a pure function with no side-effects, convert it to:⍞000D⍞000D        → ((c¨''dip   '' ''cons  '' ''i     '' ''swap  '' ...)⍳1)⊃ L0 L1 L2 L3 ... Ldflt⍞000D⍞000D    where L0 L1 ... Ldflt are internal labels for the corresponding lines.⍞000D⍞000D    Then a clever optimiser might transform the above expression:⍞000D⍞000D        CV ←  ''dip   '' ''cons  '' ''i     '' ''swap  '' ...         ⍝ vector of cases⍞000D        LV ←   L0       L1       L2       L3      ...  Ldflt  ⍝ vector of labels⍞000D⍞000D        →((c¨CV)⍳1)⊃LV                  ⍝ expand function c⍞000D           ¯⍞000D    ->  →(({op≡⍵~'' ''}¨CV)⍳1)⊃LV         ⍝ separation: {f g ⍵}¨ → {f ⍵}¨ {g ⍵}¨⍞000D           ¯¯¯¯¯¯¯¯¯¯⍞000D    ->  →(({op≡⍵}¨{⍵~'' ''}¨CV)⍳1)⊃LV     ⍝ ⎕FX-time evaluation: {⍵~'' ''}¨CV → CV1⍞000D                  ¯¯¯¯¯¯¯¯¯¯⍞000D    ->  →(({op≡⍵}¨ CV1)⍳1)⊃LV           ⍝ dfn to tacit form: {A f ⍵} → A∘f⍞000D           ¯¯¯¯¯¯⍞000D    ->  →((op∘≡¨ CV1)⍳1)⊃LV             ⍝ decomposition:  A∘f¨ → (⊂A)f¨⍞000D           ¯¯¯¯¯⍞000D    ->  →(((⊂op)≡¨ CV1)⍳1)⊃LV           ⍝ match-each: (⊂A)≡¨B → B∊⊂A⍞000D           ¯¯¯¯¯¯¯¯¯¯¯⍞000D    ->  →((CV1∊⊂op)⍳1)⊃LV               ⍝ iota-1: (A∊⊂B)⍳1 → A⍳⊂B⍞000D          ¯¯¯¯¯¯¯¯¯¯¯⍞000D    ->  →(CV1⍳⊂op)⊃LV                   ⍝ which is significantly faster.⍞000D)⍞000D⍞000DJoy in Joy⍞000D----------⍞000DWhile some of Joy''s primitive operations are coded directly in APL,  many (those⍞000Dmarked (*) in the table above) are coded in Joy itself - see  towards the end of⍞000Dthe code, via the link ##.joy  at the very top of this page.  The choice of this⍞000Dsplit between primitive and synthetic operators is an interesting one, amounting⍞000Dto choosing a "basis": a set of operators on which all the others are built. The⍞000Dsplit chosen for this implementation, as well as the Joy-coding of the operators⍞000Dreflect JMS''s inexperience with the language and both could be greatly improved.⍞000DFor more about this, see the link to Manfred von Thun''s Metacircular Interpreter⍞000Dabove.⍞000D⍞000DExamples:⍞000D⍞000D      joy ''2 3 +  4 5 *''                ⍝ 2+3 ⋄ 4×5⍞000D5 20⍞000D                                        ⍝ Interactive Joy session:⍞000D      1 joy scripts._joy                ⍝ see: ##.scripts._joy⍞000D                    │2 3 +⍞000D                   5│4 5 *⍞000D                5 20│swap⍞000D                20 5│/⍞000D                   4│→                  (* clear stack *)⍞000D                    │⍞000D                    │                   (* move separator to the right: *)⍞000D                                    │⍞000D                                    │0 9 seq                    (* ⍳10      *)⍞000D               [0 1 2 3 4 5 6 7 8 9]│→                          (* →        *)⍞000D                                    │0 11 seq [fib] map         (* fib¨⍳12  *)⍞000D      [0 1 1 2 3 5 8 13 21 34 55 89]│0 [+] fold                 (* +/⍵      *)⍞000D                                 232│→                          (* →        *)⍞000D                                    │DEFINE sum == 0 [+] fold . (* sum ← +/ *)⍞000D                                    │0 999 seq sum              (* +/⍳1000  *)⍞000D                              499500│→ 30 fac                   (* !30      *)⍞000D   265252859812191058636308480000000│→ 100 2∧                   (* 2*100    *)⍞000D     1267650600228229401496703205376│→ 3 3 ack                  (* 3 ack 3  *)⍞000D                                  61│→ [3 1 4 1 5] qsort        (* ⍵[⍋⍵]    *)⍞000D                         [1 1 3 4 5]│→ quit                     (* )off     *)⍞000D⍞000DSee also: nats lisp bf list repl⍞000D⍞000DIndex:lists|concatenative|applicative|Ackermann''s function|Metacircular⍞000DIndex:dip|dup|swap|swons|unary|nullary|stack⍞000DIndex:Joy|Forth|Postscript⍞000DIndex;Thun M. von|Apter S.|Albrecht K.|Kerby B.' 
