'DEFINE ⍞000D⍞000Dfac ==                  (* primitive-recursive factorial *)⍞000D    [1] [*] primrec ; ⍞000D⍞000Dfac-i ==                (* iterative factorial:         *)⍞000D    [1 1]               (* →                   n [1 1]│ *)⍞000D    dip                 (* →                     1 1 n│ *)⍞000D    [dup [*]dip succ]   (* →   1 1 n [dup [*]dip succ]│ *)⍞000D    times               (* →     ({(×/⍵),1↓⍵+1}⍣n⊢1 1)│ *)⍞000D    pop ;               (* →       ({(×/⍵),1↓⍵+1}⍣n⊢1)│ *)⍞000D⍞000Dfac-r ==                (* recursive factorial: *)⍞000D    [small]             (* test for 0 or 1      *)⍞000D    []                  (* 0 → 0;  1 → 1        *)⍞000D    [                   (*                   n│ *)⍞000D        dup             (* →               n n│ *)⍞000D        pred            (* →           n (n-1)│ *)⍞000D        fac-r           (* →          n (!n-1)│ *)⍞000D        *               (* →         (n×∇ n-1)│ *)⍞000D    ]⍞000D    ifte ;              (* if-then-else         *)⍞000D⍞000DY ==  [dup cons] swoncat dup cons i ;   (* Y combinator *)⍞000D⍞000Dfac-y ==                (* Y-combinator factorial: *)⍞000D    [⍞000D        [pop null]⍞000D        [pop succ]⍞000D        [[dup pred] dip i *]⍞000D        ifte⍞000D     ] Y ;⍞000D⍞000Dfib ==                  (* binary recursive fibonacci *)⍞000D    [small] []          (* 0 → 0; 1 →1          *)⍞000D    [pred dup pred]     (* →           (n-1 2)│ *)⍞000D    [+]                 (* →         (+/n-1 2)│ *)⍞000D    binrec ;⍞000D⍞000Dfib-i ==                (* iterative fibonacci:         *)⍞000D    [0 1]               (* →                   n [0 1]│ *)⍞000D    dip                 (* →                     0 1 n│ *)⍞000D    [dup [+]dip swap]   (* →   0 1 n [dup [+]dip swap]│ *)⍞000D    times               (* →         ({1↓⍵,+/⍵}⍣n⊢0 1)│ *)⍞000D    pop ;⍞000D⍞000Dfib-r ==                (* recursive fibonacci: *)⍞000D    [small]             (* test for 0 or 1      *)⍞000D    []                  (* 0 → 0; 1 → 1         *)⍞000D    [                   (*                   n│ *)⍞000D        pred            (* →             (n-1)│ *)⍞000D        dup             (* →        (n-1)(n-1)│ *)⍞000D        [fib-r]dip      (* →      (∇ n-1)(n-1)│ *)⍞000D        pred            (* →      (∇ n-1)(n-2)│ *)⍞000D        fib-r           (* →    (∇ n-1)(∇ n-2)│ *)⍞000D        +               (* →   ((∇ n-1)+∇ n-2)│ *)⍞000D    ]⍞000D    ifte ;              (* if-then-else         *)⍞000D⍞000D2∧ ==                   (* 2-to-the-power   *)⍞000D    [1]dip              (* →           1 n│ *)⍞000D    [dup +]             (* →   1 n [dup +]│ *)⍞000D    times ;             (* →     {⍵+⍵}⍣n⊢1│ *)⍞000D⍞000Dseq ==                  (* [m .. n]         *)⍞000D    [>] [pop2 []]       (* m>n:         []│ *)⍞000D    [⍞000D        [dup succ]dip   (* →       m ++m n│ *)⍞000D        seq             (* →  m [++m .. n]│ *) ⍞000D        cons            (* →      [m .. n]│ *) ⍞000D    ]⍞000D    ifte ;              (* if-then-else     *)⍞000D⍞000D(* Ackermann''s function:⍞000D *  ack 0 n → n+1⍞000D *  ack m 0 → ack (m-1) 1⍞000D *  ack m n → ack (m-1) (ack m (n-1))⍞000D *)⍞000D⍞000Dack ==                  (* recursive Ackermann *)⍞000D    [⍞000D        [[pop null] popd succ]⍞000D        [[    null] pop pred 1 ack]⍞000D        [           [dup pred swap] dip pred ack ack]⍞000D    ]cond ;⍞000D⍞000Dack-y ==                (* Y-combinator Ackermann *)⍞000D    [                   (* Kubica M.              *)⍞000D        [⍞000D            [[pop pop null] pop popd succ]⍞000D            [[    pop null] [pop pred 1]dip i]⍞000D            [⍞000D                [[dup pred swap]dip pred]dip⍞000D                dup [i]dip i (* ack ack *)⍞000D            ]⍞000D         ] cond⍞000D     ] Y ;⍞000D⍞000Dqsort ==                (* quicksort *)⍞000D    [small] []⍞000D            [uncons [>] split]⍞000D    [enconcat]⍞000D    binrec ;⍞000D⍞000D→ ==                    (*      rest│ *)    (* clear stack *)⍞000D    []                  (* → rest []│ *)⍞000D    unstack ;           (* →        │ *)⍞000D.' 
