'⍝ Generic tree traversal:⍞000D⍞000D    {}''t.r'' ''t.a'' ''t.v''⎕ns¨⊂''''      ⍝ make some spaces.⍞000D    ⍞000D    subs ← {⍵.(1↓⍎¨''0'',↓⎕nl 9)}     ⍝ sub-namespaces for space ⍵.⍞000D⍞000D    accm ← {⍺+1}                    ⍝ counting namespaces.⍞000D    0 accm trav subs t              ⍝ number of spaces.⍞000D4⍞000D    accm ← ,                        ⍝ accumulating into a vector.⍞000D    vec ← ⍬ accm trav subs t        ⍝ vector of spaces.⍞000D⍞000D    vec ≡ t t.a t.r t.v             ⍝ check match.⍞000D1⍞000D    subs ← {⍵.(1↓⍎¨''0'',↓⎕nl 9)~⍺}   ⍝ sub-namespaces with cycle-buster.⍞000D⍞000D    t.a.t ← t                       ⍝ introduce cycle: t → t.a → t.a.t → t⍞000D⍞000D    vec ≡ ⍬ accm trav subs t        ⍝ cycle ignored.⍞000D1⍞000D⍞000D⍝ A nested array may be                             ┌─┴─┐⍞000D⍝ considered a tree with            (1 2)(3 4) ←→  ┌┴┐ ┌┴┐⍞000D⍝ depth-0 items as leaves:                         1 2 3 4⍞000D⍞000D    subs ← {(0≠≡⍵)/⍵}               ⍝ sub-items of array ⍵.⍞000D⍞000D    accm ← {⍺+1}                    ⍝ counting nodes.⍞000D    0 accm trav subs (1 2)(3 4)     ⍝ node-count⍞000D7⍞000D⍞000D    accm ← {⍺,(0=≡⍵)/⍵}             ⍝ accumulating simple scalars⍞000D    ⍬ accm trav subs ''ab''(''cd'' ''e'') ⍝ enlist⍞000Dabcde⍞000D⍞000D⍝ simpler coding if accumulator is on the right:⍞000D⍞000D    vart←{                          ⍝ commuted version of trav,⍞000D        ⊃∇/(⍵⍵ ⍺),⊂⍺ ⍺⍺ ⍵           ⍝ ... give simpler coding.⍞000D    }⍞000D⍞000D    accm←{⍵,⍨(0=≡⍺)/⍺}              ⍝ accumulating simple scalars⍞000D⍞000D    ''ab''(''cd'' ''e'')accm vart subs ⍬  ⍝ enlist⍞000Dabcde⍞000D⍞000D    gcd ← ⊢ trav {|⍵-⍺~0}           ⍝ Euclid''s GCD.⍞000D⍞000D    (2×3×5) gcd (5×7×11)            ⍝ cf: 30∨385⍞000D5⍞000D⍞000D    osc ← {(⍵≠1)/(2|⍵)+⍵×0.5+2.5×2|⍵}   ⍝ next term in osc fn.⍞000D⍞000D    ⍬ , trav osc 11                 ⍝ osc sequence⍞000D11 34 17 52 26 13 40 20 10 5 16 8 4 2 1⍞000D⍞000D    0 {⍺+⍵=1} trav {(⍵-1 2)~¯1 ¯2} ¨ 0 to 10        ⍝ fibonacci sequence⍞000D0 1 1 2 3 5 8 13 21 34 55⍞000D⍞000D    bftrav←{⎕ML←0           ⍝ Generic breadth-first tree traversal.⍞000D        ⍺ ⍺⍺{⍞000D            0=⍴⍵:⍺⍞000D            (⍺ ⍺⍺⊃⍵)∇(1↓⍵),(⍺ ⍵⍵⊃⍵)⍞000D        }⍵⍵,⊂⍵⍞000D    }⍞000D⍞000D    subs ← {⍵.(1↓⍎¨''0'',↓⎕nl 9)}             ⍝ sub-namespaces for space ⍵.⍞000D⍞000D    {}⎕ex''t''                                ⍝ remove old tree.⍞000D⍞000D    {} ''t.r.r'' ''t.a.a'' ''t.v.v'' ⎕ns¨ ⊂''''     ⍝ create new tree.⍞000D⍞000D    vec ← t t.a t.r t.v t.a.a t.r.r t.v.v   ⍝ vector of spaces in⍞000D⍞000D    vec ≡ ⍬ ,bftrav subs t                  ⍝ ... breadth-first order.⍞000D1⍞000D⍞000D⍝ N-queens problem:⍞000D⍞000D    accm ← {⍺,(⍺⍺=⍴⍵)/⊂⍵}       ⍝ accumulated leaves.⍞000D⍞000D    subs←{⎕io←1                 ⍝ possible placements          \|/\  | \/| /⍞000D        dd←⌽⍳⍴⍵                 ⍝ diagonal                      ⍟  \ | /\|/⍞000D        ak←(⍵-dd),⍵,(⍵+dd)      ⍝ attacked cols in next row :       \|/  ⍟⍞000D        ⍵∘,¨(⍳⍺⍺)~ak            ⍝ subnodes                           ⍟⍞000D    }⍞000D⍞000D    ⍬(4 accm)trav(4 subs)⍬      ⍝ 4-queens solutions vector.⍞000D 2 4 1 3  3 1 4 2 ' 
