' ⍝ Brainfuck:⍞000D⍞000D    ∆←{{1:}⍙,←⍵,⎕ucs 13}    ⍝ accumulate into ⍙ buffer.⍞000D    ⍙←''''                    ⍝ null accumulation buffer.⍞000D⍞000D⍝ Here are macros ↓ and ↑ for pushing (down) and popping (up) stack items.⍞000D⍝⍞000D⍝   ┬─┬─┼A┬─┬─┬─┬─┬─┬─⍞000D⍝   │c b│ │ │ │ │ │ │ ∘∘∘⍞000D⍝   ┴─┴─┼0┴1┴2┴3┴4┴5┴─⍞000D⍞000D    ∆''↓=(           ''   ⍝ push:                     S←A,S ⋄ A←0⍞000D    ∆''  ←=[-/<+/>]  ''   ⍝   ← move ⍺ cells left (local macro defn).⍞000D    ∆''  →=[-/>+/<]  ''   ⍝   → move ⍺ cells right    ..  ..  ..⍞000D    ∆''  +           ''   ⍝ increment value to be pushed⍞000D    ∆''  4←          ''   ⍝ copy A to t in stack base (S.t)⍞000D    ∆''  <<<         ''   ⍝ go (move BF''s memory pointer) to S⍞000D    ∆''  [< 2← <]    ''   ⍝ move S.t to (T+1).t, where (T+1) is left of T⍞000D    ∆''  < 1→ >      ''   ⍝ move (T+1).t to (T+1).v⍞000D    ∆''  [>>]        ''   ⍝ skip back to (S-1).v (aka b)⍞000D    ∆''  >           ''   ⍝ go to A⍞000D    ∆'')             ''⍞000D⍞000D    ∆''↑=(           ''   ⍝ pop:                      A+←↑S ⋄ S←1↓A⍞000D    ∆''  →=[-/>+/<]  ''   ⍝   → move ⍺ cells right⍞000D    ∆''  <<<         ''   ⍝ go to S⍞000D    ∆''  [<<] >>     ''   ⍝ go to T⍞000D    ∆''  1→          ''   ⍝ move T.v to (T-1).t⍞000D    ∆''  >>          ''   ⍝ go to T-1⍞000D    ∆''  [< 2→ > >>] ''   ⍝ move value down stack to (S-1).t (aka c)⍞000D    ∆''  <           ''   ⍝ go to c⍞000D    ∆''  2→          ''   ⍝ move c to A⍞000D    ∆''  >>          ''   ⍝ go to A⍞000D    ∆''  -           ''   ⍝ decrement popped value.⍞000D    ∆'')             ''⍞000D⍞000D    stk ⍙←⍙ ''''          ⍝ stack macros ↓ and ↑.⍞000D⍞000D⍝ Macros ; and : code the standard BF sequences that convert between character⍞000D⍝ digits ''0''-''9'' and their numeric equivalents, by adding or subtracting ''0'':⍞000D⍞000D    ∆'';=(           ''   ⍝ ; input digit   A←⎕⍞000D    ∆''  ,           ''   ⍝   input char ''0''-''9''.⍞000D    ∆''  ∆=/-        ''   ⍝   minus.⍞000D    ∆''  <6∆[+>8∆<]> ''   ⍝   subtract ''0''=48.⍞000D    ∆'')''⍞000D⍞000D    ∆'':=(           ''   ⍝ : output digit  ⎕←A⍞000D    ∆''  ∆=/+        ''   ⍝   plus.⍞000D    ∆''  <6∆[->8∆<]> ''   ⍝   add ''0''=48.⍞000D    ∆''  .           ''   ⍝   output char ''0''-''9''.⍞000D    ∆'')             ''⍞000D⍞000D    io ⍙←⍙ ''''           ⍝ numeric I/O macros ; and :.⍞000D⍞000D⍝ Macros ≡, → and ← implement directly-addressable or random-access BF memory:⍞000D⍝⍞000D⍝      ┬─┬─┼A┬─┬─┬─┬─┬─┬─⍞000D⍝      │c b│ │ │ │ │ │ │ ∘∘∘⍞000D⍝      ┴─┴─┼0┴1┴2┴3┴4┴5┴─⍞000D⍞000D    ∆''≡=(           ''   ⍝ ≡ copy <n> to A.  eg: n≡⍞000D    ∆''  />          ''   ⍝   go to <n>⍞000D    ∆''  [-/<+<+>/>] ''   ⍝   move <n> to A and b.⍞000D    ∆''  /<          ''   ⍝   go to A.⍞000D    ∆''  <           ''   ⍝   go to b.⍞000D    ∆''  [->/>+/<<]  ''   ⍝   move b to <n>⍞000D    ∆''  >           ''   ⍝   go to A.⍞000D    ∆'')             ''⍞000D⍞000D    ∆''→=(           ''   ⍝ → move <n> to A.  eg: n→⍞000D    ∆''  />          ''   ⍝   go to <n>⍞000D    ∆''  [-/<+/>]    ''   ⍝   move <n> to A.⍞000D    ∆''  /<          ''   ⍝   go to A.⍞000D    ∆'')             ''⍞000D⍞000D    ∆''←=(           ''   ⍝ ← move A to <n>   eg: n←⍞000D    ∆''  />[-]/<     ''   ⍝   clear <n>⍞000D    ∆''  [-/>+/<]    ''   ⍝   move A to <n>⍞000D    ∆'')             ''⍞000D⍞000D    ram ⍙←⍙ ''''          ⍝ directly-addressable memory macros ≡, → and ←.⍞000D⍞000D⍝ and finally, here are {, ⋄ and }, which give us an if-else-fi control struct:⍞000D⍞000D    ∆''  {=<+>[<->   ''   ⍝ {  if A≠0⍞000D    ∆''  ⋄=<]<[->    ''   ⍝ ⋄  else⍞000D    ∆''  }=<<]>>     ''   ⍝ }  fi⍞000D⍞000D    if ⍙←⍙ ''''           ⍝ if-else-fi macros { ⋄ }.⍞000D⍞000D⍝ Example:⍞000D⍞000D    dark ← ∩∘''[]<>+-,.''         ⍝ without white space.⍞000D⍞000D    dark mac ram,io, ''m=1 n=2 ;m← ;n←''  ⍝ BF: store input digits at [1] and [2].⍞000D,<------[+>--------<]>>[-]<[->+<],<------[+>--------<]>>>[-]<<[->>+<<]⍞000D⍞000D⍝ Now, at last, Ackermann''s function:⍞000D⍞000D    ∆''  m=1 n=2             ''   ⍝   declare posn of local vars.⍞000D⍝   ∆''  ;m← ;n←             ''   ⍝   input m and n⍞000D    ∆''  m→+m←   n→+n←       ''   ⍝   n m+←1⍞000D    ∆''  ↓                   ''   ⍝   push 0⍞000D    ∆''  m≡[                 ''   ⍝   repeat⍞000D    ∆''  ·   -{              ''   ⍝   ·   if 0≠m-1⍞000D    ∆''  ·   ·   ↓           ''   ⍝           push m-1⍞000D    ∆''  ·   ·   n≡-{[-]     ''   ⍝   ·   ·   if 0≠n-1⍞000D    ∆''  ·   ·   ·   m→ ↓    ''   ⍝   ·   ·   ·   push m⍞000D    ∆''  ·   ·   ·   n→-↓    ''   ⍝   ·   ·   ·   push n-1⍞000D    ∆''  ·   ·   ⋄           ''   ⍝   ·   ·   else⍞000D    ∆''  ·   ·   ·    ++↓    ''   ⍝   ·   ·   ·   push 1+1⍞000D    ∆''  ·   ·   }           ''   ⍝   ·   ·   fi⍞000D    ∆''  ·   ⋄               ''   ⍝   ·   else⍞000D    ∆''  ·   ·   n→+↓        ''   ⍝   ·   ·   push n+1⍞000D    ∆''  ·   }               ''   ⍝   ·   fi⍞000D    ∆''  ·   ↑n←             ''   ⍝   ·   pop n⍞000D    ∆''  ·   ↑m←             ''   ⍝   ·   pop m⍞000D    ∆''  m≡]                 ''   ⍝   while stacked items⍞000D    ∆''  n→-                 ''   ⍝   result is n-1⍞000D⍝   ∆''  :                   ''   ⍝   output result.⍞000D    ack ⍙←⍙ ''''⍞000D⍞000D    opt ← {↑{({⍵⍱¯1⌽⍵}⍺⍷⍵)/⍵}⍣≡/''><'' ''<>''⍵}     ⍝ cancelling >< pairs removed.⍞000D⍞000D    ack ← opt dark mac if,io,ram,stk, ack       ⍝ Ackermann in raw BF.⍞000D⍞000D    0~⍨ 0 2 2 bf ack                            ⍝ test: ack(2,2) → 7⍞000D7⍞000D⍞000D    ⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍞000D    ⍝                                                       ⍝⍞000D    ⍝                           ⍝ Ackermann''s function.     ⍝⍞000D    ∆''  m=1 n=2             ''   ⍝   declare local vars.     ⍝⍞000D    ∆''  ;+m← ;+n←           ''   ⍝   input and incr m and n  ⍝⍞000D    ∆''  ↓                   ''   ⍝   push 0                  ⍝⍞000D    ∆''  m≡[                 ''   ⍝   repeat                  ⍝⍞000D    ∆''  ·   -{              ''   ⍝   ·   if 0≠m-1            ⍝⍞000D    ∆''  ·   ·   ↓           ''   ⍝   ·   ·   push m-1        ⍝⍞000D    ∆''  ·   ·   n≡-{[-]     ''   ⍝   ·   ·   if 0≠n-1        ⍝⍞000D    ∆''  ·   ·   ·   m→ ↓    ''   ⍝   ·   ·   ·   push m      ⍝⍞000D    ∆''  ·   ·   ·   n→-↓    ''   ⍝   ·   ·   ·   push n-1    ⍝⍞000D    ∆''  ·   ·   ⋄           ''   ⍝   ·   ·   else            ⍝⍞000D    ∆''  ·   ·   ·    ++↓    ''   ⍝   ·   ·   ·   push 1+1    ⍝⍞000D    ∆''  ·   ·   }           ''   ⍝   ·   ·   fi              ⍝⍞000D    ∆''  ·   ⋄               ''   ⍝   ·   else                ⍝⍞000D    ∆''  ·   ·   n→+↓        ''   ⍝   ·   ·   push n+1        ⍝⍞000D    ∆''  ·   }               ''   ⍝   ·   fi                  ⍝⍞000D    ∆''  ·   ↑n←             ''   ⍝   ·   pop n               ⍝⍞000D    ∆''  ·   ↑m←             ''   ⍝   ·   pop m               ⍝⍞000D    ∆''  m≡]                 ''   ⍝   while stacked items     ⍝⍞000D    ∆''  n→-:                ''   ⍝   output n-1              ⍝⍞000D        ack ⍙←⍙ ''''                                          ⍝⍞000D    ⍝                                                       ⍝⍞000D    ⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍞000D⍞000D    ⍴opt dark mac if,io,ram,stk,ack     ⍝ Size of BF code for Ackermann.⍞000D601⍞000D⍞000D    ⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍞000D    ⍝                                                           ⍝⍞000D    ⍝  Ackermann''s function: second attempt see ##.notes.bfack  ⍝⍞000D    ⍝                                                           ⍝⍞000D    ⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍞000D⍞000D    track←{                             ⍝ Tail-recursive Ackermann.⍞000D        a(m n)←(¯2↓⍵)(¯2↑¯1,⍵)⍞000D        m=¯1:n⍞000D        m=0:∇ a,n+1⍞000D        n=0:∇ a,(m-1)1⍞000D            ∇ a,(m-1)m(n-1)⍞000D    }⍞000D⍞000D    track 3 3                           ⍝ ack 3 3 → 61⍞000D61⍞000D⍞000D    ⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍞000D    ⍝                                                               ⍝⍞000D    ⍝ Macros:                           ⍝ Ackermann''s function.     ⍝⍞000D    ⍝                                   ⍝                           ⍝⍞000D⍝   ∆''  ;=(, ∆=/- >6∆[+<8∆>]<  )· · ''   ⍝ input digit               ⍝⍞000D⍝   ∆''  :=(  ∆=/+ >6∆[-<8∆>]< .)· · ''   ⍝ output digit              ⍝⍞000D    ∆''                              ''   ⍝                           ⍝⍞000D    ∆''  {=/>+/<[/>-/< · · · · · · · ''   ⍝ if                        ⍝⍞000D    ∆''  ⋄=/>]/>[-/< · · · · · · · · ''   ⍝ else                      ⍝⍞000D    ∆''  }=/>/>]/</< · · · · · · · · ''   ⍝ fi                        ⍝⍞000D    ∆''                              ''   ⍝                           ⍝⍞000D    ∆''  ≥=(                         ''   ⍝ dup ⍺ right               ⍝⍞000D    ∆''      [-/>+>+</<]/>>          ''   ⍝   m .. 0  → 0 .. m m      ⍝⍞000D    ∆''      [-</<+/>>]</<           ''   ⍝   m .. m  ←               ⍝⍞000D    ∆''  ) ·                         ''   ⍝                           ⍝⍞000D    ∆''                              ''   ⍝                           ⍝⍞000D    ∆''  ←=[-/<+/>]  · · · · · · · · ''   ⍝ move ⍺ left               ⍝⍞000D    ∆''  →=[-/>+/<]  · · · · · · · · ''   ⍝ move ⍺ right              ⍝⍞000D    ∆''                              ''   ⍝                           ⍝⍞000D    ⍝ Code:                             ⍝                           ⍝⍞000D    ∆''                              ''   ⍝                           ⍝⍞000D    ∆'' -                            ''   ⍝  (¯1)                     ⍝⍞000D    ∆'' >;                           ''   ⍝   ¯1(m)                   ⍝⍞000D    ∆'' >;<                          ''   ⍝   ¯1(m)n                  ⍝⍞000D    ∆'' +[-                          ''   ⍝   a(m)n                   ⍝⍞000D    ∆''      2{                      ''   ⍝   if m≠0:                 ⍝⍞000D    ∆''          >1{                 ''   ⍝       if n≠0:             ⍝⍞000D    ∆''              <3≥             ''   ⍝           a(m)n 0 m       ⍝⍞000D    ∆''              >1→             ''   ⍝           a m(0)n m       ⍝⍞000D    ∆''              >>2←            ''   ⍝           a m m n(0)      ⍝⍞000D    ∆''              <-<<->>         ''   ⍝           a(m-1)(m)(n-1)  ⍝⍞000D    ∆''          1⋄                  ''   ⍝       else if n=0:        ⍝⍞000D    ∆''              <->+            ''   ⍝           a(m+1)1         ⍝⍞000D    ∆''          1}<                 ''   ⍝       fi                  ⍝⍞000D    ∆''      2⋄                      ''   ⍝   else if m=0:            ⍝⍞000D    ∆''          >1←<+<              ''   ⍝       a(a)(n+1)0          ⍝⍞000D    ∆''      2}                      ''   ⍝   fi                      ⍝⍞000D    ∆''  +]                          ''   ⍝ until a(¯1)n              ⍝⍞000D    ∆''  >:                          ''   ⍝ output n                  ⍝⍞000D        ack ⍙←⍙ ''''                                                  ⍝⍞000D    ⍝                                                               ⍝⍞000D    ⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍞000D⍞000D    ⍴ opt dark mac ack⍞000D115⍞000D    0~⍨ 0 2 3 bf opt dark mac ack       ⍝ ack 2 3 → 9⍞000D9⍞000D⍞000D⍝ This program, transliterated from Böhm''s P" language, a precursor to BF,⍞000D⍝ returns the predecessor of a number represented in 2-adic number system:⍞000D⍝ ⍬ 1 2 11 12 21 22 111 112 121 ...⍞000D⍞000D    +1 1 2 bf''>[>]<[-[<[<]]-<]>+''   ⍝ 8-1 → 7⍞000D0 0 1 1 1 0' 
