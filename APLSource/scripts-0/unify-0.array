'⍝ Unification of expressions:⍞000D⍞000D⍝ Here is a parser for simple parenthesised expressions:⍞000D⍞000D    px←{⎕ml←0                   ⍝ Single char token parser.⍞000D        1=⍴⍵:⊃⍵                 ⍝ atom: return scalar.⍞000D        depth←×¯1⌽-⌿+\''()''∘.=⍵  ⍝ within parens.⍞000D        lpars←0 1⍷depth         ⍝ left parens.⍞000D        smask←lpars≥depth       ⍝ segmentation mask.⍞000D        drops←1 ¯1×⊂smask/lpars ⍝ parens drop.⍞000D        ∇¨↑↓¨/drops,⊂smask⊂⍵    ⍝ process each segment.⍞000D    }⍞000D⍞000D⍝ and a corresponding de-parser:⍞000D⍞000D    fx←{                ⍝ Format parse tree.⍞000D        0=≡⍵:⍕⍵         ⍝ atom: done.⍞000D        ↑,/{            ⍝ join branches.⍞000D            0=≡⍵:⍵      ⍝ atom: done.⍞000D            ''('',⍵,'')''   ⍝ parenthesise.⍞000D        }∘∇¨⍵           ⍝ each branch.⍞000D    }⍞000D⍞000D⍝ Expressions in x and y:⍞000D⍞000D    lexp rexp←px¨ ''(1×2)+y'' ''x+(3×4)''⍞000D⍞000D    disp¨ lexp rexp⍞000D ┌───┬─┬─┐  ┌─┬─┬───┐ ⍞000D │1×2│+│y│  │x│+│3×4│ ⍞000D └───┴─┴─┘  └─┴─┴───┘ ⍞000D⍞000D⍝ Unification of expressions:⍞000D⍞000D    disp ''xy''unify lexp rexp⍞000D┌───┬─┬───┐⍞000D│1×2│+│3×4│⍞000D└───┴─┴───┘⍞000D⍞000D⍝ ... formatted.⍞000D⍞000D    fx ''xy''unify lexp rexp⍞000D(1×2)+(3×4)⍞000D⍞000D⍝ More complex expressions:⍞000D⍞000D    xa←'' a    + (b÷n) - (b × a) + a    ''⍞000D    xb←''(1-c) + (c÷2) -  d      + e    ''⍞000D    xc←'' f    +  g    -  h      + (i-3)''⍞000D⍞000D    vars←lcase ⎕a       ⍝ vars: a b ··· z⍞000D⍞000D    fx vars unify px¨xa xb xc~¨'' ''⍞000D(1-3)+(3÷2)-(3×(1-3))+(1-3)⍞000D⍞000D⍞000D⍝ Unify can be used to resolve "logical syllogisms", such as:⍞000D⍝⍞000D⍝   Socrates is a man; all men are mortal; ergo, Socrates is mortal.⍞000D⍞000D    s1←''Socrates'' ''is'' ''man''⍞000D⍞000D    s2←''Man'' ''is'' ''mortal''⍞000D⍞000D    ''man'' ''Man''unify s1 s2⍞000D Socrates  is  mortal ⍞000D⍞000D⍝ Unify works on any conformable arrays, including those of higher rank.⍞000D⍞000D    a←2 13⍴2/13↑⎕a⍞000D    b←2 13⍴13↓⎕a⍞000D⍞000D    disp a b⍞000D┌─────────────┬─────────────┐⍞000D│AABBCCDDEEFFG│NOPQRSTUVWXYZ│⍞000D│GHHIIJJKKLLMM│NOPQRSTUVWXYZ│⍞000D└─────────────┴─────────────┘⍞000D⍞000D                        ⍝ Variable ''A'' propogates through variables A-Z:⍞000D    ⎕a unify a b        ⍝ A matches N matches G matches Z matches M ... B.⍞000DAAAAAAAAAAAAA⍞000DAAAAAAAAAAAAA⍞000D⍞000D⍝ replace one variable with a constant:⍞000D⍞000D    (⊃⌽,b)←''*''⍞000D⍞000D    disp a b⍞000D┌─────────────┬─────────────┐⍞000D│AABBCCDDEEFFG│NOPQRSTUVWXYZ│⍞000D│GHHIIJJKKLLMM│NOPQRSTUVWXY*│⍞000D└─────────────┴─────────────┘⍞000D⍞000D                        ⍝ Constant ''*'' propogates through variables A-Z:⍞000D    ⎕a unify a b        ⍝ * matches M matches Y matches F matches X ... A.⍞000D*************⍞000D*************⍞000D⍞000D⍝ Expression unification is used to infer type in some functional languages.⍞000D⍝ Here is the BNF for a tiny right-associative type expression:⍞000D⍝⍞000D⍝   texp := func | atom⍞000D⍝   func := atom→texp | (texp)→texp⍞000D⍝   atom := tcon | tvar⍞000D⍝   tcon := #⍞000D⍝   tvar := ⍺ | ∆ | ∊ | ⍳ | ⍵⍞000D⍝⍞000D⍝ Type variables are ⍺ ∆ ∊ ⍳ ⍵,⍞000D⍝ # is the only type constant and⍞000D⍝ → is the only type operator.⍞000D⍞000D⍝ Examples of expressions:⍞000D⍝⍞000D⍝   #, ⍺, ⍺→⍵, (⍺→∆)→∊→#⍞000D⍞000D⍝ Parser for such expressions:⍞000D⍞000D    pt←{⎕ML←0                           ⍝ Parse type expression.⍞000D        ⊃⍬{                             ⍝ Parse tree and remainder.⍞000D            0=⍴⍵:⍺ ⍵                    ⍝ done: parse tree and remainder.⍞000D            hd tl←(⊃⍵)(1↓⍵)             ⍝ head and tail of expr.⍞000D            ''(''=hd:↑∇/⍬ ∇ tl            ⍝ parenthesised sub-expr:⍞000D            '')''=hd:⍺ tl                 ⍝ complete sub-expression:⍞000D            ''→''=hd:⌽⍺{⍺⍺ hd ⍵}\⌽⍬ ∇ tl  ⍝ function:⍞000D            hd ∇ tl                     ⍝ atom:⍞000D        }⍵~'' ''                          ⍝ ignoring blanks.⍞000D    }⍞000D⍞000D⍝ and a corresponding de-parser:⍞000D⍞000D    ft←{⎕ML←1                   ⍝ Format parse tree.⍞000D        0=≡⍵:⍕⍵                 ⍝ atom: done.⍞000D        0=≡⊃⍵:∊∇¨⍵              ⍝ atomic left branch: no parens.⍞000D        ''('',(∇⊃⍵),'')'',∊∇¨1↓⍵    ⍝ parenthesised left branch.⍞000D    }⍞000D⍞000D⍝ Parse trees for type expressions:⍞000D⍞000D    disp pt''⍺→∊→⍳→⍵''⍞000D┌─┬─┬─────────┐⍞000D│⍺│→│┌─┬─┬───┐│⍞000D│ │ ││∊│→│⍳→⍵││⍞000D│ │ │└─┴─┴───┘│⍞000D└─┴─┴─────────┘⍞000D⍞000D    disp pt''(⍺→∊)→⍳→⍵''⍞000D┌───┬─┬───┐⍞000D│⍺→∊│→│⍳→⍵│⍞000D└───┴─┴───┘⍞000D⍞000D⍝ Formatted parse tree. Note how redundant parentheses are ignored:⍞000D⍞000D    ft pt''(⍺→∊)→(⍳→⍵)''⍞000D(⍺→∊)→⍳→⍵⍞000D⍞000D⍝ Vars: ⍺ ∆ ∊ ⍳ ⍵⍞000D⍞000D    vars←''⍺∆∊⍳⍵''⍞000D⍞000D⍝ Some type expressions:⍞000D⍞000D    xa←''(⍺→⍺)→∊    ''⍞000D    xb←''    ∆→∆    ''⍞000D    xc←''    ⍳→(⍵→#)''⍞000D⍞000D⍝ Unified type expressions:⍞000D⍞000D    ft vars unify pt¨xa xb xc⍞000D(#→#)→#→#⍞000D⍞000D⍝ The following expressions can''t be unified:⍞000D⍞000D    clash←pt¨ ''(⍺→⍺)→⍵'' ''⍺→(⍵→⍵)''⍞000D⍞000D⍝ However, if the intention is that the variables⍞000D⍝ in the expressions be independent,  they can be⍞000D⍝ distinguished by:⍞000D⍞000D    dv←{⎕ML←1                   ⍝ Distinguish Variables ⍺ in exprs ⍵.⍞000D        vlft vrgt←⍺∘∩∘∊¨⍵       ⍝ vars in left and right exprs⍞000D        (vlft∩vrgt){            ⍝ duplicate vars.⍞000D            (⊂⍵)∊⍺⍺:(⍺⍺⍳⊂⍵)⊃⍵⍵  ⍝ var in old: subs new.⍞000D            0=≡⍵:⍵              ⍝ atom: pass through.⍞000D            ∇¨⍵                 ⍝ tree: traverse.⍞000D        }(⍺~vlft)\⍵             ⍝ translated right expr.⍞000D    }⍞000D⍞000D⍝ The left argument of dv is the "pool" of⍞000D⍝ variables, available for substitution.⍞000D⍞000D    ft¨clash⍞000D (⍺→⍺)→⍵  ⍺→⍵→⍵ ⍞000D⍞000D⍝ Distinguish variables:⍞000D⍞000D    ft¨vars dv clash⍞000D (⍺→⍺)→⍵  ∆→∊→∊ ⍞000D⍞000D⍝ Unify succeeds:⍞000D⍞000D    ft vars unify vars dv clash⍞000D(⍺→⍺)→∊→∊⍞000D⍞000D⍝ Errors:⍞000D⍞000D    ⎕a unify ''ABC'' ''12''     ⍝ length error.⍞000D5::Can''t unify⍞000D⍞000D    ⎕a unify ''X'' ''X+1''      ⍝ occurs check.⍞000D11::Can''t unify' 
