'⍝ Evaluator for a subset of Scheme:⍞000D⍞000D    s ← ''((lambda (cons car cdr)''⍞000D    s,← ''         (car  (cons 123 456)))''⍞000D    s,← ''''⍞000D    s,← '' (lambda (x y) (lambda (i) (cond (i x) (else y))))''⍞000D    s,← '' (lambda (xy) (xy 0))''⍞000D    s,← '' (lambda (xy) (xy 1)))''⍞000D⍞000D    lisp s⍞000D456⍞000D⍞000D    lisp  ''''''(* 4 5)''⍞000D *  4 5⍞000D                                                    ⍝  f→(x→x x)(x→f(y→(x x)y))⍞000D    Y ← ''(\(f)((\(x)(x x))(\(x)(f(\(y)((x x)y))))))''            ⍝ fixpoint Y''⍞000D⍞000D    fac ← ''(\(f)(\(n)(cond((= n 0)1)(else(* n(f(- n 1)))))))''   ⍝ factorial⍞000D    lisp ''(('',Y,fac,'')4)''⍞000D24⍞000D    ⍝ Ackermann:⍞000D    ack  ← ''(\(a)(\(m)(\(n)(cond((= m 0)(+ n 1))''⍞000D    ack ,← ''                    ((= n 0)((a(- m 1))1))''⍞000D    ack ,← ''                    (else((a(- m 1))((a m)(- n 1))))))))''⍞000D    lisp''((('',Y,ack,'')2)2)''⍞000D7⍞000D    ⍝ Fibonacci:⍞000D    fib ← ''(\(f)(\(n)(cond((= n 0)0)((= n 1)1)(else(+(f(- n 1))(f(- n 2)))))))''⍞000D⍞000D    rec←{''(('',Y,⍺,'')'',⍵,'')''}                    ⍝ Y applicator⍞000D⍞000D    lisp¨ fib∘rec¨ ⎕d                           ⍝ fib¨ 0..9⍞000D0 1 1 2 3 5 8 13 21 34⍞000D⍞000D    pdep ← {+\1 ¯1 0[''()''⍳⍵]}                   ⍝ paren depth⍞000D⍞000D    pchk←{0 ¯1↓1 0⌽'' '',⍕↑pdep\⍵ ⍵}              ⍝ handy paren depth checker⍞000D⍞000D    pchk Y⍞000D( \ ( f ) ( ( \ ( x ) ( x   x ) ) ( \ ( x ) ( f ( \ ( y ) ( ( x   x ) y ) ) ) ) ) )⍞000D 1 1 2 2 1 2 3 3 4 4 3 4 4 4 4 3 2 3 3 4 4 3 4 4 5 5 6 6 5 6 7 7 7 7 6 6 5 4 3 2 1 ⍞000D⍞000D    pic2←{                                      ⍝ 2D paren depth picture⍞000D        d←(⍵='')'')+pdep ⍵            ⍝ depth⍞000D        ⊖d⊖⍵⍪((¯1+⌈/d),⍴⍵)⍴''·''      ⍝ pic⍞000D    }                         ⍞000D⍞000D    pic2 Y                                      ⍝ applicative order Y combinator⍞000D(\·······································)⍞000D··(f)(··································)·⍞000D······(\········)(\····················)··⍞000D········(x)(x x)···(x)(f··············)···⍞000D························(\···········)····⍞000D··························(y)(·····y)·····⍞000D······························(x x)·······⍞000D                                                ⍝ h→(x→h(x x))(x→h(x x))⍞000D    pic2 ''(\(h)((\(x)(h(x x)))(\(x)(h(x x)))))'' ⍝ normal order Y combinator⍞000D(\·································)⍞000D··(h)(····························)·⍞000D······(\···········)(\···········)··⍞000D········(x)(h·····)···(x)(h·····)···⍞000D·············(x x)·········(x x)····⍞000D⍞000D    pic2 ''(h→(x→h(x x))(x→h(x x)))''             ⍝ same again using → notation⍞000D(h→····················)⍞000D···(x→h·····)(x→h·····)·⍞000D·······(x x)·····(x x)··⍞000D                                                ⍝ h→(y→y y)(x→h(x x))⍞000D    pic2 ''(\(h)((\(y)(y y))(\(x)(h(x x)))))''    ⍝ recoding of the above⍞000D(\······························)⍞000D··(h)(·························)·⍞000D······(\········)(\···········)··⍞000D········(y)(y y)···(x)(h·····)···⍞000D························(x x)····⍞000D⍞000D    pic2 ''(h→(y→y y)(x→h(x x)))''                ⍝ same again using → notation⍞000D(h→·················)⍞000D···(y→y y)(x→h·····)·⍞000D··············(x x)··⍞000D⍞000D    svec ← ('' ('' ''('')(''lambda'' ''\'')             ⍝ substitution vector.⍞000D    trim ← {(~''  ''⍷⍵)/⍵}                        ⍝ without superfluous blanks.⍞000D    pic2 ↑subs/ svec,⊂trim s                    ⍝ Nick''s example:⍞000D(·······························································································)⍞000D·(\·································)(\······························)(\··········)(\··········)·⍞000D···(cons car cdr)(car··············)···(x y)(\······················)···(xy)(xy 0)···(xy)(xy 1)··⍞000D·····················(cons 123 456)···········(i)(cond·············)·····························⍞000D······················································(i x)(else y)······························' 
