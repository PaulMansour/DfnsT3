'⍝ Subset of the Joy language:⍞000D⍞000D    joy'' 3 1 4 6 2 / - + * ''        ⍝ postfix evaluation⍞000D6⍞000D    joy'' 2 3 + 4+ ''                 ⍝ error: words must be blank-separated⍞000D5 4+⍞000D    joy'' 2 (* parenthesised *) 3 (* (* nested *) comments *) + ''⍞000D5⍞000D    joy'' 1 2 3 4                    (* stack grows to the right *)''⍞000D1 2 3 4⍞000D⍞000D    joy'' 1 dup  ;                   (* top stack item duplicated *)⍞000D       2 3 swap ;                   (* top two stack items swapped *)⍞000D       4 5 pop                      (* top item popped from stack *)''⍞000D1 1 ; 3 2 ; 4⍞000D⍞000D    joy'' [[[]]]                     (* nested list *)⍞000D         [a] [b c] concat   ;       (* joined lists *)⍞000D         a [b c] cons       ;       (* cons *)⍞000D         [a b c] uncons     ;       (* uncons *)⍞000D         3 4 [dup] dip + +          (* dip *)''⍞000D[[[]]] [a b c] ; [a b c] ; a [b c] ; 10⍞000D⍞000D    joy'' [1 2 3 4] 1 [*] fold     ; (* ×/⍳4         *)⍞000D         [1 2 3] [dup +] map      ; (* {⍵+⍵}¨⍳3     *)⍞000D         10 [1 2 3][+]map         ; (* 10+¨1 2 3    *)⍞000D         10 [[succ][pred]][i] map ; (* 10+¨1 ¯1     *)⍞000D         10 [5 +] [2 *] cleave    ; (* (10+5)(10×2) *)⍞000D         3 4 [+] [*] cleave       ; (* (3+4)(3×4)   *)⍞000D         [2 3] [+ 4 5 *] infra    ; (* (2+3)(4×5)   *)⍞000D         [1 2] [3 4] infra          (* (⌽1 2),3 4   *) ''⍞000D24 ; [2 4 6] ; 10 [11 12 13] ; 10 [11 9] ; 15 20 ; 7 12 ; [5 20] ; [2 1 3 4]⍞000D⍞000D    joy'' 0 null                     (* null *)⍞000D         1 null⍞000D        [] null⍞000D       [1] null''⍞000Dtrue false true false⍞000D⍞000D    joy'' 0 small                    (* small *)⍞000D         1 small⍞000D         2 small⍞000D        [] small⍞000D       [1] small⍞000D     [1 2] small''⍞000Dtrue true false true true false⍞000D⍞000D    joy'' [0 1 2] [[dup null] [] [pred] ifte] map ''⍞000D[0 0 1]⍞000D⍞000D    joy'' [0 1 2 0 1 2] [small] filter ;⍞000D         [0 1 2 0 1 2] [1 >=]  filter ;⍞000D       1 [0 1 2 0 1 2] [!=]    filter ''⍞000D[0 1 0 1] ; [1 2 1 2] ; 1 [0 2 0 2]⍞000D⍞000D    joy'' [0 1 2 0 1 3] [small] split ;      (* (1 0=⊂⍺⍺ ⍵)/¨⊂⍵ *)⍞000D         [0 1 2 0 1 3] [2 <  ] split ; ⍞000D       2 [0 1 2 0 1 3] [  <= ] split ''⍞000D[0 1 0 1] [2 3] ; [0 1 0 1] [2 3] ; 2 [2 3] [0 1 0 1]⍞000D⍞000D    joy'' DEFINE iftest == [null] [pop y] [pop n] ifte.⍞000D           <<  [] iftest >>⍞000D           << [1] iftest >>⍞000D           <<  0  iftest >>⍞000D           <<  1  iftest >> ''⍞000D<< y >> << n >> << y >> << n >>⍞000D⍞000D    joy''[1 2 3] [[]] [[]cons cons] primrec ;    (* primrec *)⍞000D        [1 2 3] [[]] [cons]        primrec ;⍞000D             5  [1]  [*]           primrec ''⍞000D[1 [2 [3 []]]] ; [1 2 3] ; 120⍞000D⍞000D    joy''10[null][succ][dup pred][*]linrec''      ⍝ linrec⍞000D3628800⍞000D⍞000D    joy''5[small][][pred dup pred][+]binrec''     ⍝ binrec⍞000D5⍞000D⍞000D    display scripts._joy⍞000D┌→────────────────────────────────────────────────────────────┐⍞000D│DEFINE                                                       │⍞000D│                                                             │⍞000D│fac ==                  (* primitive-recursive factorial *)  │⍞000D│    [1] [*] primrec ;                                        │⍞000D│                                                             │⍞000D│fac-i ==                (* iterative factorial:         *)   │⍞000D│    [1 1]               (* →                   n [1 1]│ *)   │⍞000D│    dip                 (* →                     1 1 n│ *)   │⍞000D│    [dup [*]dip succ]   (* →   1 1 n [dup [*]dip succ]│ *)   │⍞000D│    times               (* →     ({(×/⍵),1↓⍵+1}⍣n⊢1 1)│ *)   │⍞000D│    pop ;               (* →       ({(×/⍵),1↓⍵+1}⍣n⊢1)│ *)   │⍞000D│                                                             │⍞000D│fac-r ==                (* recursive factorial: *)           │⍞000D│    [small]             (* test for 0 or 1      *)           │⍞000D│    []                  (* 0 → 0;  1 → 1        *)           │⍞000D│    [                   (*                   n│ *)           │⍞000D│        dup             (* →               n n│ *)           │⍞000D│        pred            (* →           n (n-1)│ *)           │⍞000D│        fac-r           (* →          n (!n-1)│ *)           │⍞000D│        *               (* →         (n×∇ n-1)│ *)           │⍞000D│    ]                                                        │⍞000D│    ifte ;              (* if-then-else         *)           │⍞000D│                                                             │⍞000D│Y ==  [dup cons] swoncat dup cons i ;   (* Y combinator *)   │⍞000D│                                                             │⍞000D│fac-y ==                (* Y-combinator factorial: *)        │⍞000D│    [                                                        │⍞000D│        [pop null]                                           │⍞000D│        [pop succ]                                           │⍞000D│        [[dup pred] dip i *]                                 │⍞000D│        ifte                                                 │⍞000D│     ] Y ;                                                   │⍞000D│                                                             │⍞000D│fib ==                  (* binary recursive fibonacci *)     │⍞000D│    [small] []          (* 0 → 0; 1 →1          *)           │⍞000D│    [pred dup pred]     (* →           (n-1 2)│ *)           │⍞000D│    [+]                 (* →         (+/n-1 2)│ *)           │⍞000D│    binrec ;                                                 │⍞000D│                                                             │⍞000D│fib-i ==                (* iterative fibonacci:         *)   │⍞000D│    [0 1]               (* →                   n [0 1]│ *)   │⍞000D│    dip                 (* →                     0 1 n│ *)   │⍞000D│    [dup [+]dip swap]   (* →   0 1 n [dup [+]dip swap]│ *)   │⍞000D│    times               (* →         ({1↓⍵,+/⍵}⍣n⊢0 1)│ *)   │⍞000D│    pop ;                                                    │⍞000D│                                                             │⍞000D│fib-r ==                (* recursive fibonacci: *)           │⍞000D│    [small]             (* test for 0 or 1      *)           │⍞000D│    []                  (* 0 → 0; 1 → 1         *)           │⍞000D│    [                   (*                   n│ *)           │⍞000D│        pred            (* →             (n-1)│ *)           │⍞000D│        dup             (* →        (n-1)(n-1)│ *)           │⍞000D│        [fib-r]dip      (* →      (∇ n-1)(n-1)│ *)           │⍞000D│        pred            (* →      (∇ n-1)(n-2)│ *)           │⍞000D│        fib-r           (* →    (∇ n-1)(∇ n-2)│ *)           │⍞000D│        +               (* →   ((∇ n-1)+∇ n-2)│ *)           │⍞000D│    ]                                                        │⍞000D│    ifte ;              (* if-then-else         *)           │⍞000D│                                                             │⍞000D│2∧ ==                   (* 2-to-the-power   *)               │⍞000D│    [1]dip              (* →           1 n│ *)               │⍞000D│    [dup +]             (* →   1 n [dup +]│ *)               │⍞000D│    times ;             (* →     {⍵+⍵}⍣n⊢1│ *)               │⍞000D│                                                             │⍞000D│seq ==                  (* [m .. n]         *)               │⍞000D│    [>] [pop2 []]       (* m>n:         []│ *)               │⍞000D│    [                                                        │⍞000D│        [dup succ]dip   (* →       m ++m n│ *)               │⍞000D│        seq             (* →  m [++m .. n]│ *)               │⍞000D│        cons            (* →      [m .. n]│ *)               │⍞000D│    ]                                                        │⍞000D│    ifte ;              (* if-then-else     *)               │⍞000D│                                                             │⍞000D│(* Ackermann''s function:                                     │⍞000D│ *  ack 0 n → n+1                                            │⍞000D│ *  ack m 0 → ack (m-1) 1                                    │⍞000D│ *  ack m n → ack (m-1) (ack m (n-1))                        │⍞000D│ *)                                                          │⍞000D│                                                             │⍞000D│ack ==                  (* recursive Ackermann *)            │⍞000D│    [                                                        │⍞000D│        [[pop null] popd succ]                               │⍞000D│        [[    null] pop pred 1 ack]                          │⍞000D│        [           [dup pred swap] dip pred ack ack]        │⍞000D│    ]cond ;                                                  │⍞000D│                                                             │⍞000D│ack-y ==                (* Y-combinator Ackermann *)         │⍞000D│    [                   (* Kubica M.              *)         │⍞000D│        [                                                    │⍞000D│            [[pop pop null] pop popd succ]                   │⍞000D│            [[    pop null] [pop pred 1]dip i]               │⍞000D│            [                                                │⍞000D│                [[dup pred swap]dip pred]dip                 │⍞000D│                dup [i]dip i (* ack ack *)                   │⍞000D│            ]                                                │⍞000D│         ] cond                                              │⍞000D│     ] Y ;                                                   │⍞000D│                                                             │⍞000D│qsort ==                (* quicksort *)                      │⍞000D│    [small] []                                               │⍞000D│            [uncons [>] split]                               │⍞000D│    [enconcat]                                               │⍞000D│    binrec ;                                                 │⍞000D│                                                             │⍞000D│→ ==                    (*      rest│ *)    (* clear stack *)│⍞000D│    []                  (* → rest []│ *)                     │⍞000D│    unstack ;           (* →        │ *)                     │⍞000D│.                                                            │⍞000D└─────────────────────────────────────────────────────────────┘⍞000D⍞000D    joy scripts._joy,''⍞000D        DEFINE 0-5 == 0 5 seq.  (* sequence  *)⍞000D        0-5 [fac]   map         (* factorial *)⍞000D        0-5 [fac-y] map         (* factorial *)⍞000D        0-5 [fib]   map         (* fibonacci *)⍞000D        0-5 [2 rem] map         (* parity    *)⍞000D        [3 1 4 1 5] qsort       (* quicksort *)⍞000D        0 2 seq [dup ack] map   (* Ackermann *) ''⍞000D[1 1 2 6 24 120] [1 1 2 6 24 120] [0 1 1 2 3 5] [0 1 0 1 0 1] [1 1 3 4 5] [1 3 7]⍞000D⍞000D    joy''  11 4 /; 11 4 rem; 11 4 div ''          ⍝ division / remainder⍞000D2 ; 3 ; 2 3⍞000D⍞000D    joy'' -- X Y Z stack''            ⍝ push stack onto stack⍞000D-- X Y Z [Z Y X --]⍞000D⍞000D    joy''poof [X Y Z --] unstack''    ⍝ replace stack with top item⍞000D-- Z Y X⍞000D⍞000D    joy''[] [1 2 3]shunt [4 5]shunt'' ⍝ shunt⍞000D[5 4 3 2 1]⍞000D⍞000D    joy ''3[stack]times''             ⍝ cf: disp {⍺ ⍵}\3⍴⊂⍬⍞000D[] [[]] [[[]] []]⍞000D⍞000D    joy ''(* null program *)''⍞000D⍞000D    joy ''DEFINE 3 == 4.             (* redefinition of operator: 3  *)⍞000D         2 3 +                      (* 2 3 + → 6                    *)⍞000D        DEFINE 3 == 2 succ.         (* redefinition of operator: 3  *)⍞000D        2 3 +                       (* 2 3 + → 5                    *) ''⍞000D6 5⍞000D⍞000D⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝  Errors show the failing operator to the right of the │:⍞000D⍞000D    joy ''3 5 -''                     ⍝ error: subtrahend too big⍞000D3 5│-⍞000D⍞000D    joy ''1 2 3 4 5 + ? * /''         ⍝ error: ? not in domain of *⍞000D1 2 3 9 ?│* /⍞000D⍞000D    joy ''1 [2] concat''              ⍝ error: concat needs two lists⍞000D1 [2]│concat⍞000D⍞000D    joy ''[] uncons''                 ⍝ error: uncons of empty list⍞000D[]│uncons⍞000D⍞000D    joy ''1 2 cons''                  ⍝ error: cons to atom⍞000D1 2│cons⍞000D⍞000D    joy ''3 2 dup - /''               ⍝ error: divide by zero⍞000D3 0│/⍞000D⍞000D    joy ''0 [y] [t] branch''          ⍝ error: branch first arg must be bool⍞000D0 [y] [t]│branch⍞000D⍞000D    joy ''true 0 <''                  ⍝ error: relational fn needs a number⍞000Dtrue 0│<⍞000D⍞000D    joy ''0 pred''                    ⍝ error: 0 has no predecessor⍞000D0│pred' 
