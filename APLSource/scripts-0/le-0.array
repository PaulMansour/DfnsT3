'⍝ Total array ordering: ⍺≤⍵⍞000D⍞000D    2 le 3                  ⍝ simple scalar comparison: 2≤3 → 1⍞000D1⍞000D    4 le ,3                 ⍝ items 4>3 more significant than rank⍞000D0⍞000D    3 le ,3                 ⍝ items match: rank decides⍞000D1⍞000D    1 2 le 1 1 3            ⍝ short array extended with fill items⍞000D0⍞000D    1 1 0 le 1 1            ⍝ items match (after fill): initial shape decides⍞000D0⍞000D    1 2 3 9 le 2 3⍴⍳6       ⍝ same as (2 4↑1 4⍴1 2 3 9) le (2 4↑2 3⍴1 2 3 4 5 6)⍞000D0⍞000D    (⍳2 2) le ⌽⍳2 2         ⍝ nested⍞000D1⍞000D    3 le ''3''                ⍝ num >> char⍞000D0⍞000D    ''''le ⍬                  ⍝ comparison of nulls => comparison of prototypes.⍞000D1⍞000D    ''k''9 le 4''t''            ⍝ mixed arrays⍞000D1⍞000D    nss ← ⎕ns¨'''' ''''         ⍝ pair of "equal" namespaces.⍞000D    le/nss                  ⍝ identical.⍞000D1⍞000D    nss.v←''world'' ''hello''   ⍝ distinguishing values.⍞000D    le/nss                  ⍝ distinct.⍞000D0⍞000D    notes le ⎕or''notes''     ⍝ namespace vs ⎕OR of namespace.⍞000D1⍞000D    le/⎕or¨''test'' ''le''      ⍝ function ⎕OR comparison⍞000D0⍞000D    le/¨1 0⌽¨⊂{⍵.ref←⌽⍵}⎕ns¨'''' ''''   ⍝ ref-cycle detection.⍞000D1 1⍞000D    qsort←{                         ⍝ quicksort.⍞000D        1≥⍴⍵:⍵                      ⍝ single item or null: done.⍞000D        head tail←(1↑⍵)(1↓⍵)        ⍝ first and remaining items.⍞000D        le gt←1 0=⊂tail ⍺⍺¨head     ⍝ comparison with first item.⍞000D        (∇ le/tail),head,∇ gt/tail  ⍝ sorted vector.⍞000D    }⍞000D⍞000D    display le qsort 3(,3)''3''(,''3'')     ⍝ char << num; scalar << vector⍞000D┌→────────────┐⍞000D│   ┌→┐   ┌→┐ │⍞000D│ 3 │3│ 3 │3│ │⍞000D│ - └─┘   └~┘ │⍞000D└∊────────────┘⍞000D⍞000D    ip←+.×                                      ⍝ named function.⍞000D⍞000D    stuff ← ⎕SE ⍬ # (⎕or''ip'') '''' ⍬              ⍝ assorted stuff.⍞000D⍞000D    display le qsort stuff                      ⍝   sorted stuff.⍞000D┌→────────────────────────┐⍞000D│ ┌⊖┐ ┌⊖┐ ┌⊖┐       ┌───┐ │⍞000D│ │ │ │0│ │0│ # ⎕SE │+.×│ │⍞000D│ └─┘ └~┘ └~┘       └∇──┘ │⍞000D└∊────────────────────────┘⍞000D⍞000D⍝ Other relationships can be derived from le:⍞000D⍞000D    cmp ← {⍺⍺/le/¨1 0⌽¨⊂⍺ ⍵}                    ⍝ comparison⍞000D⍞000D    ge ← ≥cmp                                   ⍝ greater or equal⍞000D    eq ← =cmp                                   ⍝ equal⍞000D    ne ← ≠cmp                                   ⍝ not equal⍞000D    lt ← <cmp                                   ⍝ less than⍞000D    gt ← >cmp                                   ⍝ greater than⍞000D⍞000D    (⎕ns'''')eq ⎕ns''''                             ⍝ distinct spaces deemed equal.⍞000D1⍞000D    ∘.ge⍨ 0 1                                   ⍝ truth-table for ≥⍞000D1 0⍞000D1 1⍞000D    grade←{| ⊢/↑ ⍺⍺ qsort ⍵ {⍺ ⍵}¨ ⍵⍵ ⍳⍴⍵}      ⍝ grade up/down.⍞000D⍞000D    gu ← le grade +                             ⍝ grade-up   ⍋⍞000D    gd ← ge grade -                             ⍝ grade-down ⍒⍞000D⍞000D    gu 3 1 4 1 5                                ⍝ grade-up of numeric vector.⍞000D2 4 1 3 5⍞000D⍞000D    gd 3 1 4 1 5                                ⍝ grade-down of numeric vector.⍞000D5 3 1 2 4⍞000D⍞000D    display stuff                               ⍝ assorted stuff.⍞000D┌→────────────────────────┐⍞000D│     ┌⊖┐   ┌───┐ ┌⊖┐ ┌⊖┐ │⍞000D│ ⎕SE │0│ # │+.×│ │ │ │0│ │⍞000D│     └~┘   └∇──┘ └─┘ └~┘ │⍞000D└∊────────────────────────┘⍞000D⍞000D    gu stuff                                    ⍝ grade-up of stuff.⍞000D5 2 6 3 1 4⍞000D⍞000D    gd stuff                                    ⍝ grade-down of stuff.⍞000D4 1 3 2 6 5⍞000D⍞000D    q ← ''to'' ''be'' ''or'' ''not'' ''to'' ''be''          ⍝ that is the question.⍞000D⍞000D    gu q                                        ⍝ grade-up of char vectors ...⍞000D2 6 4 3 1 5⍞000D⍞000D    ⍋∘↑ q                                       ⍝ ... concurs with ⍋∘↑⍞000D2 6 4 3 1 5⍞000D⍞000D    nvs ← (1 1) ⍬ (2 3 4) (1 1) ⍬ (2 3)         ⍝ numeric vectors.⍞000D⍞000D    gd  nvs                                     ⍝ grade-down ...⍞000D3 6 1 4 2 5⍞000D⍞000D    ⍒∘↑ nvs                                     ⍝ ... concurs with ⍒∘↑⍞000D3 6 1 4 2 5⍞000D⍞000D    refs ← {}∘(⎕ns∘{''''}∘⎕ex¨ ⍨) ⍝ refs to new spaces.⍞000D⍞000D    refs''xy''                    ⍝ new spaces⍞000D    x.(a c)←1 3                 ⍝ with names a c⍞000D    y.(a b)←1 4                 ⍝ ... and a b⍞000D    x le y                      ⍝ (a c) supersedes (a b)⍞000D0⍞000D    x.b←2                       ⍝ new name b in x⍞000D    x le y                      ⍝ (a:1 b:2 ...) precedes (a:1 b:4 ...)⍞000D1⍞000D    refs''xyz''                   ⍝ new spaces⍞000D    x.le←⎕nr''le''                ⍝ x.le is ⎕nr of function.⍞000D    y.le←⎕or''le''                ⍝ y.le is ⎕or of function.⍞000D    {}z.⎕fx ⎕cr''le''             ⍝ z.le is function.⍞000D⍞000D    cmp ← ∘.le⍨                 ⍝ comparison table.⍞000D    cmp x y z                   ⍝ x ≤ y ≤ z.⍞000D1 1 1⍞000D0 1 1⍞000D0 0 1⍞000D⍞000D    refs''xy''                    ⍝ new spaces⍞000D    {}x.?1                      ⍝ mutate x.⎕rl⍞000D    x le y                      ⍝ x.⎕rl >> y.⎕rl⍞000D0⍞000D    refs''xy''                    ⍝ new spaces.⍞000D    x.(ref←⎕ns'''')               ⍝ inward-pointing ref.⍞000D    y.(ref←##.x)                ⍝ outward-pointing ref.⍞000D    cmp x y                     ⍝ comparisons⍞000D1 1⍞000D0 1⍞000D⍞000D    le qsort 3 4 3j4 3j¯4 ¯3j4 ¯3j¯4  4j3 4j¯3 ¯4j3 ¯4j¯3⍞000D¯4J¯3 ¯4J3 ¯3J¯4 ¯3J4 3J¯4 3 3J4 4J¯3 4 4J3⍞000D⍞000D    gu 3j5 3j4 4j3 3j4          ⍝ complex number grade-up.⍞000D2 4 1 3⍞000D⍞000D:If {11::0 ⋄ (⎕ex''f''){1}''f''⎕wc ⍵}''Form''(''Visible'' 0)        ⍝ support for GUI?⍞000D⍞000D        {}''eg''{⍺ ⎕wc''Form'' ⍵ (''Visible'' 0)}¨''Echo'' ''Golf''   ⍝ two forms.⍞000D⍞000D        g le e                  ⍝ compared on Caption property⍞000D    0⍞000D        e g←0                   ⍝ remove forms.⍞000D⍞000D:EndIf⍞000D⍞000D    cmp {⍵⊣⍵.(p q)←↓⍉↑1 ¯1⌽¨⊂⍵}⎕NS¨3/⊂⍬         ⍝ Nick''s example⍞000D1 1 1⍞000D1 1 1⍞000D1 1 1⍞000D⍞000D    cmp {⍵⊣⍵.(p q r s)←↓⍉↑(⍳4)⌽¨⊂⍵} ⎕ns¨4/⊂⍬    ⍝ 4-way Nick⍞000D1 1 1 1⍞000D1 1 1 1⍞000D1 1 1 1⍞000D1 1 1 1⍞000D⍞000D    (x←⎕ns ⍬).(x←⎕ns ⍬).(x←##)                  ⍝ 3-cycle⍞000D    (y←⎕ns ⍬).(y←⎕ns ⍬).(y←⎕ns ⍬).(y←##.##)     ⍝ 4-cycle⍞000D    x y ≡ x.x.x y.y.y.y                         ⍝ check for cycles⍞000D1⍞000D    cmp x y                                     ⍝ shorter cycle is less⍞000D1 1⍞000D0 1⍞000D⍞000D⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝ some checking fuctions:⍞000D⍞000D    v ← x 3 1 4 1 5 y       ⍝ vector of values⍞000D⍞000D    cmp v⍞000D1 0 0 0 0 0 1⍞000D1 1 0 1 0 1 1⍞000D1 1 1 1 1 1 1⍞000D1 0 0 1 0 1 1⍞000D1 1 1 1 1 1 1⍞000D1 0 0 0 0 1 1⍞000D0 0 0 0 0 0 1⍞000D⍞000D    tc ← (⊢ ∨ ∨.∧)⍨ ⍣≡      ⍝ transitive closure⍞000D    tc cmp v                ⍝ no effect: le is transitive⍞000D1 0 0 0 0 0 1⍞000D1 1 0 1 0 1 1⍞000D1 1 1 1 1 1 1⍞000D1 0 0 1 0 1 1⍞000D1 1 1 1 1 1 1⍞000D1 0 0 0 0 1 1⍞000D0 0 0 0 0 0 1⍞000D⍞000D    tck ← ≡∘tc⍨∘cmp         ⍝ check of transitivity⍞000D    tck v⍞000D1⍞000D    rc ← ∨∘⍉ ⍨              ⍝ reflexive closure⍞000D    rc cmp v                ⍝ complete: le is total⍞000D1 1 1 1 1 1 1⍞000D1 1 1 1 1 1 1⍞000D1 1 1 1 1 1 1⍞000D1 1 1 1 1 1 1⍞000D1 1 1 1 1 1 1⍞000D1 1 1 1 1 1 1⍞000D1 1 1 1 1 1 1⍞000D⍞000D    rck ← 0∘(~∊)∘rc∘cmp     ⍝ check of (reflexive) totality⍞000D    rck v⍞000D1⍞000D    chk ← tck ∧ rck         ⍝ check⍞000D    chk v                   ⍝ Hoorah!⍞000D1⍞000D⍞000D⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝ regression tests:⍞000D⍞000D    chk (# #)(# # #)        ⍝ extension of ref-arrays.⍞000D1' 
