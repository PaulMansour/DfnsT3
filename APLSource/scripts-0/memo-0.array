'⍝ Function memoization:⍞000D⍞000D      ⎕io←1⍞000D⍞000D      afib←{⎕io←0                   ⍝ Naïve coding of ⍺-fibonacci number.⍞000D          ⍵∊⍳⍺:⍵                    ⍝ small number: done,⍞000D          +/⍺ afib¨⍵-1+⍳⍺           ⍝ otherwise: sum of preceding ⍺ fib numbers.⍞000D      }⍞000D⍞000D      2 afib¨⍳10                    ⍝ *slow* ⍺-fibonacci sequence.⍞000D1 1 2 3 5 8 13 21 34 55⍞000D⍞000D      afib←(afib)memo(cache ⍬)      ⍝ Memoize afib.⍞000D⍞000D      2 afib¨⍳20                    ⍝ *fast* ⍺-fibonacci sequence.⍞000D1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765⍞000D⍞000D⍝ Notice that afib is coded to use its own name explicitly, rather than ''∇''⍞000D⍝ for the recursion. This is so that the recursive call references the newly-⍞000D⍝ assigned derived function, whereas ''∇'' would have referenced the original⍞000D⍝ function and circumvented the memoization.⍞000D⍞000D⍝ Perhaps surprisingly, the cache can be relied upon to supply the "base values"⍞000D⍝ of the recursion, thus simplifying the initial function coding.⍞000D⍞000D      fib←{                         ⍝ Naïve coding of regular fibonacci number.⍞000D          +/fib¨⍵-1 2               ⍝ sum of preceding 2 fib numbers.⍞000D      }⍞000D⍞000D      fib←(fib)memo(cache 2/¨0 1)   ⍝ Cache pre-populated with base values.⍞000D⍞000D      fib¨⍳20                       ⍝ Fast fibonacci sequence.⍞000D1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765⍞000D⍞000D      div←÷ memo (cache ⍬)          ⍝ Ambivalent operand function⍞000D⍞000D      2 div 7                       ⍝ Dyadic use distinct from ...⍞000D0.2857142857⍞000D⍞000D      div 2 7                       ⍝ ... monadic use.⍞000D0.5 0.1428571429⍞000D⍞000D      osc←{                         ⍝ Oscillate - probably returns 1.⍞000D          2|⍵:osc 1+3×⍵             ⍝ odd:  triple ''n add-one,⍞000D              osc ⍵÷2               ⍝ even: halve.⍞000D      }⍞000D⍞000D      ∆osc←cache⊂1 1                ⍝ Initialise cache for osc.⍞000D⍞000D      osc←(osc)memo ∆osc            ⍝ derive "fast" osc function.⍞000D⍞000D      ∆osc.⎕nl 2                    ⍝ cache-space contents.⍞000Dkeys⍞000Dvals⍞000D⍞000D      show←{⎕ML←0                       ⍝ Show cache <rslts ← args>⍞000D          ↑⍵.(vals{⍺''←'',⊂¯1↓⍵}¨keys)    ⍝ (dropping extra rarg).⍞000D      }⍞000D⍞000D      show ∆osc                     ⍝ Show initial cache.⍞000D1 ← 1 ⍞000D⍞000D      osc 2                         ⍝ Apply derived function, extending cache.⍞000D1⍞000D      show ∆osc                     ⍝ Show extended cache.⍞000D1 ← 1 ⍞000D1 ← 2 ⍞000D⍞000D      osc 3                         ⍝ Apply function again.⍞000D1⍞000D⍞000D      show ∆osc                     ⍝ Show extended cache.⍞000D1 ← 1  ⍞000D1 ← 2  ⍞000D1 ← 4  ⍞000D1 ← 8  ⍞000D1 ← 16 ⍞000D1 ← 5  ⍞000D1 ← 10 ⍞000D1 ← 3  ⍞000D⍞000D      zap←{⎕ml←0                        ⍝ Remove value ⍵ from cache ⍺.⍞000D          ⍺.{⎕ml←0                      ⍝ within cache:⍞000D              mask←⍵∘≡¨↓⍉↑vals keys     ⍝ mask of matches.⍞000D              {1}vals keys/⍨←⊂~mask     ⍝ retain non-matches.⍞000D          }(⊃⍵)(1↓⍵,¯1↑⍵)               ⍝ target value and key.⍞000D      }⍞000D⍞000D      ∆osc∘zap¨(1 16)(1 10)(1 3)    ⍝ Zap selected cache entries.⍞000D1 1 1⍞000D⍞000D      show ∆osc                     ⍝ Show compacted cache.⍞000D1 ← 1 ⍞000D1 ← 2 ⍞000D1 ← 4 ⍞000D1 ← 8 ⍞000D1 ← 5 ⍞000D⍞000D      osc 3                         ⍝ Re-run function.⍞000D1⍞000D⍞000D      show ∆osc                     ⍝ Partially restored cache.⍞000D1 ← 1  ⍞000D1 ← 2  ⍞000D1 ← 4  ⍞000D1 ← 8  ⍞000D1 ← 5  ⍞000D1 ← 10 ⍞000D1 ← 3  ⍞000D⍞000D      +⎕ex''∆osc''                    ⍝ Seal access to osc''s cache.⍞000D1⍞000D      osc¨⍳10                       ⍝ Derived function still operates normally.⍞000D1 1 1 1 1 1 1 1 1 1' 
