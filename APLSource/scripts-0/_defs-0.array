'⍝ Bunda-Gerth definitions for a dfns-like language, in which:⍞000D⍝ - An expression may evaluate to:⍞000D⍝ - - An Array,⍞000D⍝ - - A Function,⍞000D⍝ - - An Operator,⍞000D⍝ - - A dyadic function bound (curried) with its left argument,⍞000D⍝ - - A dyadic operator bound (curried) with its right operand,⍞000D⍝ - - A train of arrays and functions with a function as rightmost item.⍞000D⍝ - The result of any expression may be named.⍞000D⍝ - Only an Array expression may be guarded.⍞000D⍝ - A diamond-separated expression list must terminate in an Array expression.⍞000D⍞000D⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝ Categories:⍞000DA a b c  0 1 2 3 4 5 6 7 8 9  ⍺ ⍵  #    ⍝ Arrays⍞000DF + - × ÷ ⍳ ⍴ = | ↑ ↓ ⊢ ⊣ ∇             ⍝ Functions⍞000DN x y z                                 ⍝ Names (unassigned).⍞000DH / ⌿ \ ⍀                               ⍝ Hybrid function/operators⍞000DAF                                      ⍝ bound left argument⍞000DJOT ∘                                   ⍝ compose / null operand.⍞000DDOT .                                   ⍝ ref / product.⍞000DDX                                      ⍝ dotted ...⍞000DMOP ¨ ⍨ &                               ⍝ Monadic operators⍞000DDOP ⍣                                   ⍝ Dyadic operators⍞000DIDX                                     ⍝ index/axis⍞000DXAS                                     ⍝ indexed assignment: [IDX]←⍞000DSL  ;                                   ⍝ subscript list  ..;..;..⍞000DCLN :                                   ⍝ colon token⍞000DGRD                                     ⍝ guard :⍞000DXL  ⋄                                   ⍝ expression list ..⋄..⋄..⍞000DARO ←                                   ⍝ assignment arrow⍞000DASG                                     ⍝ name assignment⍞000DERR                                     ⍝ error⍞000D() [IDX] {F}                            ⍝ brackets⍞000D⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍞000D⍞000D⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝ Macros:⍞000Dfun=F.H                 ⍝ function⍞000Drand=A.fun.AF.N         ⍝ operand⍞000Dthing=rand.MOP.DOP.JOT  ⍝ nameable object⍞000D⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍞000D⍞000DDX:thing→thing          ⍝ dotted expression.⍞000D⍞000DA:DOT→DX                ⍝ dotted expression⍞000D⍞000D  N:ARO→ASG             ⍝ name to assignment arrow⍞000DIDX:ARO→XAS             ⍝ indexed assign ]←⍞000D⍞000DN:XAS→ASG               ⍝ n[x]←⍞000D⍞000DA:A→A                   ⍝ array stranding⍞000DN:N→N                   ⍝ name stranding⍞000DDOT:A→ERR               ⍝   to prevent #.a+b → #.(a+b)⍞000D⍞000Drand:MOP→F              ⍝ monadic and⍞000DDOP:rand→MOP            ⍝ ... dyadic operators⍞000Dfun:H→F                 ⍝ hybrid as operator⍞000DDOT:fun→MOP             ⍝ inner product⍞000DJOT:MOP→F DOP:JOT→MOP   ⍝ jot-as-null: outer product⍞000DJOT:rand→MOP            ⍝ compose⍞000Drand:IDX→rand           ⍝ axis / index⍞000DMOP:H→ERR               ⍝   top prevent +¨/¨ → (+¨)(/¨)⍞000D⍞000DA:fun→AF                ⍝ left argument to its function⍞000DIDX:A.fun→ERR           ⍝   to prevent v[0]+1 → v[0](+1)⍞000D⍞000DF.AF:A→A                ⍝ function to its right argument⍞000D⍞000Dfun.AF:F→F  F.AF:AF→F   ⍝ function trains⍞000D⍞000DA.SL:SL→SL SL:A→SL      ⍝ subscript list: [2;] [2;;]⍞000D⍞000DASG:thing→thing         ⍝ naming leaves / as hybrid⍞000DASG:DOT→DOP             ⍝ naming fixes  . as product⍞000D⍞000DA:CLN→GRD               ⍝ guard expr is a bool scalar⍞000DGRD:A→A                 ⍝ guard returns an Array.⍞000DCLN:A→ERR               ⍝   to prevent: 1:2⋄ → 1:(2⋄)⍞000DARO:thing→ERR           ⍝   to prevent a←1⋄2 → a←(1⋄2)⍞000D⍞000Dthing.DOT.XL:XL→XL      ⍝ leading side-effect thing-expressions⍞000DXL:A→A                  ⍝ expression list returns only an array' 
