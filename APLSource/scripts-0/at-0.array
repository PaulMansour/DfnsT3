'⍝ ⍺ at ⍵⍵ in ⍵⍞000D⍞000D⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝ selection by index:⍞000D⍞000D    ''*''⊣at 2 4 ⊢5↑⎕A            ⍝ * at 2nd and 4th items⍞000DA*C*E⍞000D⍞000D    M←5 5⍴⍳25⍞000D⍞000D    0 ⊣at 2 4 ⊢M                ⍝ 0 at 2nd and 4th rows⍞000D 1  2  3  4  5⍞000D 0  0  0  0  0⍞000D11 12 13 14 15⍞000D 0  0  0  0  0⍞000D21 22 23 24 25⍞000D⍞000D    (2 5⍴⎕a) ⊣at 2 4 ⊢M         ⍝ A..J at 2nd and 4th rows⍞000D 1  2  3  4  5⍞000D A  B  C  D  E⍞000D11 12 13 14 15⍞000D F  G  H  I  J⍞000D21 22 23 24 25⍞000D⍞000D    0 ⊣at 2 4⍤1 ⊢M              ⍝ 0 at 2nd and 4th cols⍞000D 1 0  3 0  5⍞000D 6 0  8 0 10⍞000D11 0 13 0 15⍞000D16 0 18 0 20⍞000D21 0 23 0 25⍞000D⍞000D   (⍉2 5⍴⎕a) ⊣at 2 4⍤1 ⊢M       ⍝ A..J at 2nd and 4th cols⍞000D 1 A  3 F  5⍞000D 6 B  8 G 10⍞000D11 C 13 H 15⍞000D16 D 18 I 20⍞000D21 E 23 J 25⍞000D⍞000D    ⌽ at 2 4 ⊢M                 ⍝ reverse of 2nd and 4th row (boustrophedon)⍞000D 1  2  3  4  5⍞000D10  9  8  7  6⍞000D11 12 13 14 15⍞000D20 19 18 17 16⍞000D21 22 23 24 25⍞000D⍞000D    0 ⊣at 2 4⍤1 at 2 4 ⊢M       ⍝ cf: M[2 4;2 4]←0⍞000D 1  2  3  4  5⍞000D 6  0  8  0 10⍞000D11 12 13 14 15⍞000D16  0 18  0 20⍞000D21 22 23 24 25⍞000D⍞000D    0 ⊣at (2 4∘.,2 4) ⊢5 5⍴⍳25  ⍝ ditto using choose indexing⍞000D 1  2  3  4  5⍞000D 6  0  8  0 10⍞000D11 12 13 14 15⍞000D16  0 18  0 20⍞000D21 22 23 24 25⍞000D⍞000D    (2 2⍴⎕a)⊣at 2 4⍤1 at 2 4 ⊢M             ⍝ cf: M[2 4;2 4]←2 2⍴⎕A⍞000D 1  2  3  4  5⍞000D 6  A  8  B 10⍞000D11 12 13 14 15⍞000D16  C 18  D 20⍞000D21 22 23 24 25⍞000D⍞000D    (2 2 5⍴lcase ⎕a)⊣at(2 2⍴⍳4)⊢5 5⍴⎕A      ⍝ check conformability rules⍞000Dabcde⍞000Dfghij⍞000Dklmno⍞000Dpqrst⍞000DUVWXY⍞000D⍞000D    ''⍟''⊣at(1 5)(2 2)⊢''hello'' ''world''        ⍝ reach⍞000D hell⍟  w⍟rld ⍞000D⍞000D    10×at 2 4 ⊢⍳5               ⍝ 10× at ...⍞000D1 20 3 40 5⍞000D⍞000D    1+at 2 2 ⊢5/0               ⍝ nb: dups ignored⍞000D0 1 0 0 0⍞000D⍞000D    0 at 1 ⍳2                   ⍝ error: left operand must be a function⍞000D2::SYNTAX ERROR⍞000D⍞000D⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝ boolean selection:⍞000D⍞000D    ''*''⊣at(∊∘''AEIOU'') ⎕A        ⍝ vowels⍞000D*BCD*FGH*JKLMN*PQRST*VWXYZ⍞000D⍞000D    100×at(2∘|)⍤1 ⊢M            ⍝ alternately × 100⍞000D 100    2  300    4  500⍞000D   6  700    8  900   10⍞000D1100   12 1300   14 1500⍞000D  16 1700   18 1900   20⍞000D2100   22 2300   24 2500⍞000D⍞000D    {∊¨(0=3 5∘|¨⍵)/¨⊂''fizz'' ''buzz''}at(0∨.=3 5∘.|⊢)⍤1 ⊢3 4 5⍴⍳60⍞000D    1     2  fizz     4  buzz     ⍞000D fizz     7     8  fizz  buzz     ⍞000D   11  fizz    13    14  fizzbuzz ⍞000D   16    17  fizz    19  buzz     ⍞000D                                  ⍞000D fizz    22    23  fizz  buzz     ⍞000D   26  fizz    28    29  fizzbuzz ⍞000D   31    32  fizz    34  buzz     ⍞000D fizz    37    38  fizz  buzz     ⍞000D                                  ⍞000D   41  fizz    43    44  fizzbuzz ⍞000D   46    47  fizz    49  buzz     ⍞000D fizz    52    53  fizz  buzz     ⍞000D   56  fizz    58    59  fizzbuzz ⍞000D⍞000D    ''*''⊣at(⍉∊∘''AEIOU'')4 5⍴⎕A        ⍝ mask not conformable with right arg⍞000D5::LENGTH ERROR⍞000D⍞000D⍝ Roger Hui''s model of "Mesh" and "Mask", implemented using [at]:⍞000D⍞000D⍝ Mesh (APL, 1962) -------------------------------------------------------------⍞000D⍞000D⍝   c ← a (u Mesh) b    ←→    ((~u)⌿c)≡a and (u⌿c)≡b⍞000D⍞000D    ⎕io←0⍞000D⍞000D    a ← 33 44 55⍞000D    b ← ⍳10⍞000D    u ← 1 1 0 1 1 1 1 0 1 1 1 0 1⍞000D⍞000D    ↑ u (b ⊣at(u⊣⊣) (~u)⍀a)⍞000D1 1  0 1 1 1 1  0 1 1 1  0 1⍞000D0 1 33 2 3 4 5 44 6 7 8 55 9⍞000D⍞000D    c←b ⊣at(u⊣⊣) (~u)⍀a⍞000D    a ≡ (~u)⌿c⍞000D1⍞000D    b ≡ u⌿c⍞000D1⍞000D    c ≡ b ⊣at(u/⍳≢u) ⊢(~u)⍀a⍞000D1⍞000D⍞000D⍝ The last version with the integer right operand is required for meshing major⍞000D⍝ cells.⍞000D⍞000D    a←2⍴⍤0 ⊢33 44 55⍞000D    b←2⍴⍤0 ⍳10⍞000D    c ← b ⊣at(u/⍳≢u) ⊢(~u)⍀a⍞000D    a ≡ (~u)⌿c⍞000D1⍞000D    b ≡ u⌿c⍞000D1⍞000D⍞000D⍝ Mask (APL, 1962) -------------------------------------------------------------⍞000D⍞000D⍝   c ← a (u Mask) b    ←→    ((~u)⌿c)≡(~u)⌿a and (u⌿c)≡u⌿b⍞000D⍞000DFor numeric vectors a and b,⍞000D⍞000D    a ← ⍳13⍞000D    b ← 20+⍳13⍞000D    u ← 13⍴0 0 1⍞000D    c ← (a×~u) + b×u⍞000D⍞000D    ↑ u (b (u⌿⊣)at(u⊣⊣) a)⍞000D0 0  1 0 0  1 0 0  1 0  0  1  0⍞000D0 1 22 3 4 25 6 7 28 9 10 31 12⍞000D⍞000D    c ← b (u⌿⊣)at(u⊣⊣) a⍞000D    ((~u)⌿c) ≡ (~u)⌿a⍞000D1⍞000D    (u⌿c)≡u⌿b⍞000D1⍞000D    c ≡ b (u⌿⊣)at(u/⍳≢u) ⊢a⍞000D1⍞000D⍞000D⍝ Again, the last version with the integer right operand is required for masking⍞000D⍝ major cells.⍞000D⍞000D    a ← 2⍴⍤0 ⊢⍳13⍞000D    b ← 2⍴⍤0 ⊢20+⍳13⍞000D    c ← b (u⌿⊣)at(u/⍳≢u) ⊢a⍞000D    ((~u)⌿c) ≡ (~u)⌿a⍞000D1⍞000D    (u⌿c)≡u⌿b⍞000D1⍞000D⍞000D⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝ example: gauss-jordan elimination⍞000D⍞000D    ⎕io←0⍞000D    ⍞000D    gauss_jordan 2 2⍴⍳5         ⍝ test current coding⍞000D¯1.5 0.5⍞000D 1   0  ⍞000D⍞000D    gauss_jordan←{⎕IO ⎕ML←0 1                   ⍝ recoded to use [at]:⍞000D⍞000D        elim←{                                  ⍝ elimination of row/col ⍺.⍞000D            p←⍺+{⍵⍳⌈/⍵}|⍺↓⍺⌷⍉⍵                  ⍝ index of pivot row.⍞000D            swap←⊖at ⍺ p⊢⍵                      ⍝ exchange of ⍺th and pth rows.⍞000D            mat←(⍺ ⍺⌷swap)÷⍨at ⍺⊢swap           ⍝ with col diagonal reduced to 1.⍞000D            mat-((⍺⌷⍉mat)×⍺≠⍳⊃⍴⍵)∘.×⍺⌷mat       ⍝ col off-diagonals reduced to 0⍞000D        }⍞000D⍞000D        0::⎕SIGNAL ⎕EN                          ⍝ pass back error to caller.    ⍞000D                                                                            ⍞000D        ⍺←=/↑⍳⍴⍵                                ⍝ id matrix for monadic case.⍞000D⍞000D        (⍴⍺)⍴(0 1×⍴⍵)↓↑elim/(⌽⍳⌊/⍴⍵),⊂⍵,⍺       ⍝ elimination/ ··· 2 1 0 (⍵,⍺)⍞000D    }⍞000D⍞000D    gauss_jordan 2 2⍴⍳5         ⍝ same result⍞000D¯1.5 0.5⍞000D 1   0  ⍞000D⍞000D⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝ extended versions:⍞000D⍝⍞000D⍝ This version avoids name-clashes by applying operand functions⍞000D⍝ at the outer lexical level:⍞000D⍞000D    at←{⍺←⊢                             ⍝ ⍺ at ⍵⍵ in ⍵⍞000D        ⍺ ⍺⍺{⍺←⊢                        ⍝ external operand⍞000D            ⍺ ⍺⍺ ⍵                      ⍝   to hide name "A"⍞000D        }{⍺←⊢                           ⍝ selection⍞000D            A⊣A[⍵]←⍺ ⍺⍺(A←⍵⍵)[⍵]        ⍝ replaced values⍞000D        }⍵⊢⍺⍺{                          ⍝ choose-indices for selection⍞000D            3=⎕NC''⍵⍵'':(,~~⍵⍵ ⍵)/,⍳⍴⍵    ⍝ function: bool selection⍞000D            (⊂⍵⍵)⌷[⎕IO]⍳⍴⍵              ⍝ choose-indices⍞000D        }⍵⍵⊢⍵                           ⍝ ⍵ is subject array⍞000D    }⍞000D⍞000D    exec←⍎∘(''⎕nl-⍳10''∘⊣)        ⍝ list of visible names⍞000D⍞000D    (exec 1)≡⊃(⊂ exec)at{1},0   ⍝ check left operand sees no local names⍞000D1⍞000D    ones ← 1 ⊣¨ exec            ⍝ 1 1 .. 1 for each visible name.⍞000D⍞000D    ∧/(ones 1)⊣at ones ⎕nl-⍳10  ⍝ check right operand (should not LENGTH ERROR)⍞000D1⍞000D⍞000D⍝ In addition, the following version produces extended error messages:⍞000D⍞000D    at←{⍺←⊢                                 ⍝ ⍺ at ⍵⍵ in ⍵⍞000D        {⍞000D            err rslt←⍵                      ⍝ error code and result⍞000D            err=0:rslt                      ⍝ no error: replaced values⍞000D            msg←⎕io⊃⎕dm                     ⍝ main message⍞000D            sub←{                           ⍝ subsidiary message⍞000D                1=⍵:''left''                  ⍝ modifier operand error⍞000D                2=⍵:''indexing right''        ⍝ indexing selector error⍞000D                3=⍵:''boolean right''         ⍝ mask selector error⍞000D            }err                            ⍝ error code⍞000D            dmx←'': '',sub,'' operand''         ⍝ message extension⍞000D            (msg,dmx)⎕signal ⎕en            ⍝ signal error to calling line⍞000D        }⍺ ⍺⍺{⍺←⊢                           ⍝ external evaluation of modifier fn⍞000D            0::1 ⍬                          ⍝ error:⍞000D            0,⊂⍺ ⍺⍺ ⍵                       ⍝ code and value⍞000D        }{⍺←⊢                               ⍝ selection⍞000D            err indx←⍵                      ⍝ error code and index vector⍞000D            err>0:⍵                         ⍝ error: quit⍞000D            0::1 ⍬                          ⍝ 1: left operand error⍞000D            err new←⍺ ⍺⍺ ⍵⍵[indx]           ⍝ error code and successor value⍞000D            ×err:err new                    ⍝ error: quit⍞000D            0,⊂A⊣A[indx]←new⊣A←⍵⍵           ⍝ replaced values⍞000D        }⍵⊢⍺⍺{                              ⍝ choose-indices for selection⍞000D            0::3 ⍬                          ⍝ 3: function right-operand error⍞000D            3=⎕nc''⍵⍵'':0,⊂(,~~⍵⍵ ⍵)/,⍳⍴⍵     ⍝ function: bool selection⍞000D            0::2 ⍬                          ⍝ 2: array right-operand error⍞000D            0,⊂(⊂⍵⍵)⌷[⎕io]⍳⍴⍵               ⍝ choose-indices⍞000D        }⍵⍵⊢⍵                               ⍝ ⍵ is subject array⍞000D    }⍞000D⍞000D    ⊢at⊃ ⎕a⍞000D11::DOMAIN ERROR: boolean right operand⍞000D    1+at{0 2}3 4⍞000D11::DOMAIN ERROR: boolean right operand⍞000D    ⊢at{1 1}⎕A⍞000D5::LENGTH ERROR: boolean right operand⍞000D    ⊢at ¯1⊢⎕A⍞000D3::INDEX ERROR: indexing right operand⍞000D    ⊢at''a''⊢⎕A⍞000D11::DOMAIN ERROR: indexing right operand⍞000D⍞000D    1 2+at 1⊢3 4 5⍞000D5::LENGTH ERROR: left operand⍞000D    ''a''+at 1⊢3 4 5⍞000D11::DOMAIN ERROR: left operand⍞000D⍞000D    (exec 1)≡⊃(⊂ exec)at{1},0   ⍝ check left operand sees no local names⍞000D1⍞000D    ∧/(ones 1)⊣at ones ⎕nl-⍳10  ⍝ check right operand (should not LENGTH ERROR)⍞000D1' 
